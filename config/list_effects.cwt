#####################################
#
# EVERY EFFECT
#
#####################################

single_alias[every_effect] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all province locations of the phases of the activity, optionally limited to unique locations.
## scope = activity
## push_scope = province
alias[effect:every_activity_phase_location] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. ('future' does not include any started phase)
## scope = activity
## push_scope = province
alias[effect:every_activity_phase_location_future] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. ('past' only includes ended phases)
## scope = activity
## push_scope = province
alias[effect:every_activity_phase_location_past] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all characters attending an activity. Invited guests that have not accepted/declined yet are not part of this list.Supports an optional state the character must be in.
## scope = activity
## push_scope = character
alias[effect:every_attending_character] = {
    ## cardinality = 0..1
    state = enum[activity_state]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through characteres within the specified subset of the current phase.
## scope = activity
## push_scope = character
alias[effect:every_guest_subset] = {
    name = value[guest_subset]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    phase = value[activity_phase]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through characteres within the specified subset of the current phase.
## scope = activity
## push_scope = character
alias[effect:every_guest_subset_current_phase] = {
    name = value[guest_subset]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all counties in the region. Put 'region = region_name' inside it
## push_scope = landed_title
alias[effect:every_county_in_region] = {
    region = <geographical_region>
    ## cardinality = 0..1
    variable = value[global_variable]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in global list. list = name or variable = name
alias[effect:every_in_global_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[global_variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in list. list = name or variable = name
## push_scope = any
alias[effect:every_in_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in local list. list = name or variable = name
alias[effect:every_in_local_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[local_variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all characters in the pool of the given province
## push_scope = character
alias[effect:every_pool_character] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    province = scope[province]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all traits in a given category. any_trait_in_category = { category = fame/health/etc } every_trait_in_category = { limit = { <triggers> } <effects> }
## push_scope = trait
alias[effect:every_trait_in_category] = {
    category = enum[trait_category]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }
## scope = character
## push_scope = struggle 
alias[effect:every_character_struggle] = {
    ## cardinality = 0..1
    involvement = enum[involvement]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all every_claim = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_claim] = {
    explicit = enum[yesnoall]
    pressed = enum[yesnoall]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through all characters employed by the scoped character in the target court position.
## scope = character
## push_scope = character
alias[effect:every_court_position_holder] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    type = <court_position>
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through scripted relations of a given type every_relation = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_relation] = {
    type = <scripted_relation>
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal
### This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is
### ..._de_jure_vassal_and_below = { continue = { conditions } }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_in_de_facto_hierarchy] = {
    ## cardinality = 0..1
    continue = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is ..._de_jure_vassal_and_below = { continue = { conditions } } every_in_de_jure_hierarchy = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_in_de_jure_hierarchy] = {
    ## cardinality = 0..1
    continue = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

#####################################
#
# RANDOM EFFECT
#
#####################################

single_alias[random_effect] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all province locations of the phases of the activity, optionally limited to unique locations.
## scope = activity
## push_scope = province
alias[effect:random_activity_phase_location] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. ('future' does not include any started phase)
## scope = activity
## push_scope = province
alias[effect:random_activity_phase_location_future] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. ('past' only includes ended phases)
## scope = activity
## push_scope = province
alias[effect:random_activity_phase_location_past] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all characters attending an activity. Invited guests that have not accepted/declined yet are not part of this list.Supports an optional state the character must be in.
## scope = activity
## push_scope = character
alias[effect:random_attending_character] = {
    ## cardinality = 0..1
    state = enum[activity_state]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through characteres within the specified subset of the current phase.
## scope = activity
## push_scope = character
alias[effect:random_guest_subset] = {
    name = value[guest_subset]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    phase = value[activity_phase]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through characteres within the specified subset of the current phase.
## scope = activity
## push_scope = character
alias[effect:random_guest_subset_current_phase] = {
    name = value[guest_subset]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all counties in the region. Put 'region = region_name' inside it
## push_scope = landed_title
alias[effect:random_county_in_region] = {
    region = <geographical_region>
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in global list. list = name or variable = name
alias[effect:random_in_global_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[global_variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in list. list = name or variable = name
## push_scope = any
alias[effect:random_in_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in local list. list = name or variable = name
alias[effect:random_in_local_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[local_variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all characters in the pool of the given province
## push_scope = character
alias[effect:random_pool_character] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    province = scope[province]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all traits in a given category
## push_scope = trait
alias[effect:random_trait_in_category] = {
    category = enum[trait_category]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }
## scope = character
## push_scope = struggle 
alias[effect:random_character_struggle] = {
    ## cardinality = 0..1
    involvement = enum[involvement]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all random_claim = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_claim] = {
    ## cardinality = 0..1
    explicit = enum[yesnoall]
    ## cardinality = 0..1
    pressed = enum[yesnoall]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through all characters employed by the scoped character in the target court position.
## scope = character
## push_scope = character
alias[effect:random_court_position_holder] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    type = <court_position>
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through scripted relations of a given type random_relation = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:random_relation] = {
    type = <scripted_relation>
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is ..._de_jure_vassal_and_below = { continue = { conditions } } random_in_de_facto_hierarchy = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_in_de_facto_hierarchy] = {
    continue = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is ..._de_jure_vassal_and_below = { continue = { conditions } } random_in_de_jure_hierarchy = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_in_de_jure_hierarchy] = {
    continue = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alternative_limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    weight = single_alias_right[weight_block]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

#####################################
#
# ORDERED EFFECT
#
#####################################

single_alias[ordered_effect] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all province locations of the phases of the activity, optionally limited to unique locations.
## scope = activity
## push_scope = province
alias[effect:ordered_activity_phase_location] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. ('future' does not include any started phase)
## scope = activity
## push_scope = province
alias[effect:ordered_activity_phase_location_future] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. ('past' only includes ended phases)
## scope = activity
## push_scope = province
alias[effect:ordered_activity_phase_location_past] = {
    ## cardinality = 0..1
    unique = bool
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all characters attending an activity. Invited guests that have not accepted/declined yet are not part of this list.Supports an optional state the character must be in.
## scope = activity
## push_scope = character
alias[effect:ordered_attending_character] = {
    ## cardinality = 0..1
    state = enum[activity_state]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through characteres within the specified subset of the current phase.
## scope = activity
## push_scope = character
alias[effect:ordered_guest_subset] = {
    name = value[guest_subset]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    phase = value[activity_phase]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through characteres within the specified subset of the current phase.
## scope = activity
## push_scope = character
alias[effect:ordered_guest_subset_current_phase] = {
    name = value[guest_subset]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all counties in the region. Put 'region = region_name' inside it
## push_scope = landed_title
alias[effect:ordered_county_in_region] = {
    region = <geographical_region>
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in global list. list = name or variable = name
alias[effect:ordered_in_global_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[global_variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in list. list = name or variable = name
## push_scope = any
alias[effect:ordered_in_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all items in local list. list = name or variable = name
alias[effect:ordered_in_local_list] = {
    ## cardinality = 0..1
    list = value[list]
    ## cardinality = 0..1
    variable = value[local_variable_list]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all characters in the pool of the given province
## push_scope = character
alias[effect:ordered_pool_character] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    province = scope[province]
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all traits in a given category
## push_scope = trait
alias[effect:ordered_trait_in_category] = {
    category = enum[trait_category]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }
## scope = character
## push_scope = struggle
alias[effect:ordered_character_struggle] = {
    ## cardinality = 0..1
    involvement = enum[involvement]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all ordered_claim = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_claim] = {
    explicit = enum[yesnoall]
    pressed = enum[yesnoall]
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterates through all characters employed by the scoped character in the target court position.
## scope = character
## push_scope = character
alias[effect:ordered_court_position_holder] = {
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    type = <court_position>
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through scripted relations of a given type ordered_relation = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_relation] = {
    type = <scripted_relation>
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is ..._de_jure_vassal_and_below = { continue = { conditions } } ordered_in_de_facto_hierarchy = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_in_de_facto_hierarchy] = {
    continue = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is ..._de_jure_vassal_and_below = { continue = { conditions } } ordered_in_de_jure_hierarchy = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_in_de_jure_hierarchy] = {
    continue = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    # TODO: Work out what exactly this is restricted to
    order_by = alias_keys_field[int_value]
    order_by = single_alias_right[score_formula]
    order_by = value_field
    ## cardinality = 0..1
    max = alias_keys_field[int_value]
    ## cardinality = 0..1
    max = value_field
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    check_range_bounds = no
    ## cardinality = 0..1
    custom = localisation
    alias_name[effect] = alias_match_left[effect]
}