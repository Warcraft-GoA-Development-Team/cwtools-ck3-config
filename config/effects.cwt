###################################
# DYNASTY SCOPE
###################################

### Add a modifier to a dynasty add_dynasty_modifier = name add_dynasty_modifier = { modifier = name days/weeks/months/years = int }
## scope = dynasty
alias[effect:add_dynasty_modifier] = single_alias_right[added_modifier]

### Adds dynasty perk. add_dynasty_perk = key
## scope = dynasty
alias[effect:add_dynasty_perk] = <dynasty_perk> # TODO: Define dynasty perks.

### adds dynasty prestige
## scope = dynasty
alias[effect:add_dynasty_prestige] = alias_keys_field[int_value]

### adds dynasty prestige levels
## scope = dynasty
alias[effect:add_dynasty_prestige_level] = alias_keys_field[int_value] # TODO: Test out if variables/values work?

### Remove all instances of a modifier from a dynasty remove_all_dynasty_modifier_instances = name
## scope = dynasty
alias[effect:remove_all_dynasty_modifier_instances] = <modifier_container>

### Remove a modifier from a dynasty remove_dynasty_modifier = name
alias[effect:remove_dynasty_modifier] = <modifier_container>

### Remove all instances of a modifier from a dynasty remove_all_dynasty_modifier_instances = name
## scope = dynasty
alias[effect:remove_dynasty_perk] = <dynasty_perk>

### Sets dynasty name
## scope = dynasty
alias[effect:set_dynasty_name] = localisation

###################################
# TASK CONTRACT SCOPE
###################################

# todo: see valid targets for contract
### complete_task_contract = task_contract_reward 
## scope = task_contract
alias[effect:complete_task_contract] = scalar

### Invalidate contract
## scope = task_contract
alias[effect:complete_task_contract] = yes

### set_task_task_contract_target = CHARACTER_SCOPE
## scope = task_contract
alias[effect:set_task_contract_target] = scope[character]

###################################
# ACTIVITY SCOPE
###################################

### add_activity_log_entry = {	key = <loc_key>	score = <script_value>	tags = { <a> <b> <c> } # Optional	show_in_conclusion = yes/no # Optional, defaults to no	character = <character>	target = <character> # Optional	location = <province> # Optional, defaults to current activity loction	artifact = <artifact> # Optional } Add a new log entry to the scoped activity
## scope = activity
alias[effect:add_activity_log_entry] = {
    key = localisation
    ## cardinality = 0..1
    score = int_value_field
    ## cardinality = 0..1
    tags = {
        ## cardinality = 1..inf
        scalar
    }
    ## cardinality = 0..1
    show_in_conclusion = bool
    character = scope[character]
    ## cardinality = 0..1
    target = scope[character]
    ## cardinality = 0..1
    location = scope[province]
    ## cardinality = 0..1
    artifact = scope[artifact]
    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

### add_to_current_phase_guest_subset = { name = <subset_key> target = scope:character } Adds the target character to the designated subset in the current phase.
## scope = activity
alias[effect:add_to_current_phase_guest_subset] = {
    name = value[guest_subset]
    target = scope[character]
}

### add_to_guest_subset = { name = <subset_key> target = scope:character phase = <phase_key> # Optional } Adds the target character to the designated subset. Will add to all phases and ongoing subsets if phase is not specified. If a phase is specified, they will be added to all phases of that type.
## scope = activity
alias[effect:add_to_guest_subset] = {
    name = value[guest_subset]
    target = scope[character]
    ## cardinality = 0..1
    phase = value[activity_phase]
}

### Progress the current activity phase forward after X days.
## scope = activity
alias[effect:progress_activity_phase_after] = single_alias_right[duration_block]

### Removes the target character from the designated subset in the current phase.remove_from_current_phase_guest_subset = {	name = <subset_key>	target = scope:character }
## scope = activity
alias[effect:remove_from_guest_subset] = {
	name = <subset_key>
	target = scope:character
}

### add_to_guest_subset = {	name = <subset_key>	target = scope:character phase = <phase_key> # Optional } Removes the target character from the designated subset. Will remove from all upcoming and ongoing subsets if phase is not specified. If a phase is specified, they will be removed from all phases of that type.
## scope = activity
alias[effect:remove_from_guest_subset] = {
    name = value[guest_subset]
    target = scope[character]
    ## cardinality = 0..1
    phase = value[activity_phase]
}

### set_activity_host = character The host of the scoped activity is set to the target character
## scope = activity
alias[effect:set_activity_host] = scope[character]

### Skip the current activity phase, either directly to the next phase, or to completion. (fast-forwards) skip_activity_phase = yes/no.
## scope = activity
alias[effect:set_activity_host] = bool

###################################
# CULTURE SCOPE
###################################

### Adds the cultural tradition scope specified in the RHS to the scope culture.add_culture_tradition = tradition_court_eunuchs
## scope = culture
alias[effect:add_culture_tradition] = <tradition>

### Add innovation to a culture
## scope = culture
alias[effect:add_innovation] = <innovation>

### Adds the name list to the culture
## scope = culture
alias[effect:add_innovation] = <name_list>

### Add random available innovation<culture> = { add_random_innovation = culture_group_military/culture_group_civic/culture_group_regional/yes }
## scope = culture
alias[effect:add_random_innovation] = enum[innovation_group]

### Add random available innovation<culture> = { add_random_innovation = culture_group_military/culture_group_civic/culture_group_regional/yes }
## scope = culture
alias[effect:add_random_innovation] = yes

### Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, an error is loggedadd_random_valid_tradition = scope:character
## scope = culture
alias[effect:add_random_valid_tradition] = scope[character]

### Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, a random existing tradition is removedadd_random_valid_tradition_replace_if_necessary = scope:character
## scope = culture
alias[effect:add_random_valid_tradition_replace_if_necessary] = scope[character]

### Changes cultural acceptance with the target culture change_cultural_acceptance = {    target = <culture>    value = script value    desc = dynamic desc. Description that'll show when hovering over the acceptance tooltip in the culture window     }
## scope = culture
## push_scope = culture
alias[effect:change_cultural_acceptance] = {
    target = scope[culture]
    value = alias_keys_field[int_value]
    ## cardinality = 0..1
    desc = single_alias_right[complex_desc]
    ## cardinality = 0..1
    desc = localisation
}

### Removes all cultural traditions from the scope culture.clear_culture_traditions = yes
## scope = culture
alias[effect:clear_culture_traditions] = bool

### Replaces all traditions of scoped culture with traditions from the given culturecopy_all_traditions_from = scope:target_culture
## scope = culture
alias[effect:copy_all_traditions_from] = scope[culture]

### Discover all innovations from the target culture get_all_innovations_from = <culture>
## scope = culture
alias[effect:get_all_innovations_from] = scope[culture]

### Get random available innovation from another culture
## scope = culture
alias[effect:get_random_innovation_from] = scope[culture]

### Joins all culture eras up to and including the given one
## scope = culture
alias[effect:join_era] = <era>

### Leaves all culture eras down to and including the given one
## scope = culture
alias[effect:leave_era] = <era>

### Sets cultural acceptance with the target culture
## scope = culture
alias[effect:set_cultural_acceptance] = { target = scope[culture] value = alias_keys_field[int_value] }

### Permanently sets the name of the scope culture to the parsed text from the provided localization string. Like 'set_title_name', the new name is static and unchanging (i.e., if the localization key provided is 'Neo-[old_culture.GetName]' and the old culture is French, the new name is just be saved as a simple string, 'Neo-French', so that if/when the old_culture scope is cleaned up the localization does not break.set_culture_name = { noun = dynamic description    collective_noun = dynamic description    prefix = dynamic description    }
## scope = culture
## push_scope = culture
alias[effect:set_culture_name] = {
    noun = single_alias_right[complex_desc]
    collective_noun = single_alias_right[complex_desc]
    prefix = single_alias_right[complex_desc]
}

### Adds the current pillar specified in the RHS to the scope culture, replacing the pillar in the matching slot.set_culture_pillar = ethos_warmonger
## scope = culture
alias[effect:set_culture_pillar] = <pillar>

### Set the heritage from the RHS on the scope culture.set_heritage_from = culture:norwegian
## scope = culture
alias[effect:set_ethos_from] = scope[culture]

### Set the language from the RHS on the scope culture.set_language_from = culture:norwegian
## scope = culture
alias[effect:set_language_from] = scope[culture]

###  Set the martial custom from the RHS on the scope culture.set_martial_custom_from = culture:norwegian
## scope = culture
alias[effect:set_martial_custom_from] = scope[culture]

###  Remove all existing name lists then adds the specified name list to the culture <culture> = { set_name_list = name }
## scope = culture
alias[effect:set_name_list] = <name_list>

###################################
# DYNASTY HOUSE SCOPE
###################################

###  Adds a claim on the target artifact to the scoped house
## scope = dynasty_house
alias[effect:add_house_artifact_claim] = scope[artifact]

### Add a modifier to a house add_house_modifier = name add_house_modifier = { modifier = name days/weeks/months/years = int }
## scope = dynasty_house
## push_scope = dynasty_house
alias[effect:add_house_modifier] = single_alias_right[added_modifier]

### Add a modifier to a house add_house_unity_modifier = name add_house_unity_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = dynasty_house
## push_scope = dynasty_house
alias[effect:add_house_unity_modifier] = single_alias_right[added_modifier]

### Adds value to the house unity. Usage: add_unity_value = {    value = VALUE    character = CHARACTER    desc = localization_key}
## scope = dynasty_house
## push_scope = dynasty_house
alias[effect:add_unity_value] = {
    value = alias_keys_field[int_value]
    character = scope[character]
    desc = single_alias_right[complex_desc]
}

### Remove all instances of a modifier from a house
## scope = dynasty_house
alias[effect:remove_all_house_modifier_instances] = <modifier_container>

### Remove all instances of a modifier from a house unity
## scope = dynasty_house
alias[effect:remove_all_house_unity_modifier_instances] = <modifier_container>

### Removes a claim on the target artifact from the scoped house
## scope = dynasty_house
alias[effect:remove_house_artifact_claim] = scope[artifact]

### Remove a modifier from a house remove_house_modifier = name
## scope = dynasty_house
alias[effect:remove_house_modifier] = <modifier_container>

### Remove a modifier from a house unity
## scope = dynasty_house
alias[effect:remove_house_unity_modifier] = <modifier_container>

### Set house head for the house. Also transfers noble family title.
## scope = dynasty_house
alias[effect:set_house_head] = scope[character]

### Sets dynasty house name
## scope = dynasty_house
alias[effect:set_house_name] = localisation

### Sets dynasty house name from another dynasty's name
## scope = dynasty_house
alias[effect:set_house_name_from_dynasty] = scope[dynasty]

### Sets dynasty house name from another dynasty house's name
## scope = dynasty_house
alias[effect:set_house_name_from_house] = scope[dynasty_house]

###################################
# SECRET SCOPE
###################################

### Adds an participant to the secret
## scope = secret
alias[effect:add_secret_participant] = scope[character]

### Forbids the target character from exposing the secret, disable_exposure_by = target_character
## scope = secret
alias[effect:disable_exposure_by] = scope[character]

### Exposes the scope secret
## scope = secret
alias[effect:expose_secret] = scope[character]

### Removes the scope secret
## scope = secret
alias[effect:remove_secret] = bool # Only seen used as `= yes` in vanilla files.

### Reveals the scope secret to the target character
## scope = secret
alias[effect:reveal_to] = scope[character]

### Sets a new owner for the secret
## scope = secret
alias[effect:set_secret_owner] = scope[character]

### Spends the scope secret, spend_by = target_character
## scope = secret
alias[effect:spend_by] = scope[character]

###################################
# ARMY SCOPE
###################################

### Adds loot to the currently scoped raiding army. Usage: add_loot = VALUE
## scope = army
alias[effect:add_loot] = alias_keys_field[int_value]

### Assign a commander for the scoped army
## scope = army
alias[effect:assign_commander] = scope[character]

### Removes the currently assigned commander from the scoped army
## scope = army
alias[effect:remove_commander] = bool

### Teleports the army to the given location. Cannot be done while in combat. Will cause combat to happen with this army as the attacker if there's hostiles in the target
## scope = army
alias[effect:set_army_location] = scope[province]

### Reduce current army size by the giver percentage. Value on the right side determines what portions of soldiers shall perish
## scope = army
alias[effect:set_army_location] = float_value_field

###################################
# TRAVEL PLAN SCOPE
###################################

### Abort the travel plan immediately - no further travelling is executed, the on_action effect 'on_travel_plan_abort' will be run.
## scope = travel_plan
alias[effect:abort_travel_plan] = bool

### Add X days towards the progress of the travel plan to the next destination. If the next destination is reached, excess progress is discarded. 'on_travel_plan_movement' on_action will not be triggered for any of the provinces.'on_travel_plan_arrival' will be triggered. 
## scope = travel_plan
alias[effect:abort_travel_plan] = single_alias_right[duration_block]

### Adds the travel option specified in the RHS to the scope travel plan.<travel_plan> = { add_travel_option = name } 
## scope = travel_plan
alias[effect:abort_travel_plan] = <travel_option>

### Add a modifier to a travel plan add_travel_plan_modifier = name add_travel_plan_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = travel_plan
## push_scope = travel_plan
alias[effect:add_travel_plan_modifier] = {
    modifier = <modifier_container>
    enum[duration] = alias_keys_field[int_value]
    ## cardinality = 0..1
    desc = single_alias_right[complex_desc]
}

### Add a modifier to a travel plan add_travel_plan_modifier = name add_travel_plan_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = travel_plan
## push_scope = travel_plan
alias[effect:add_travel_plan_modifier] = <modifier_container>

### Adds a travel waypoint just ahead of the current travel location, and change the path accordingly.
## scope = travel_plan
alias[effect:add_travel_waypoint] = scope[province]

### Cancel travel plan future path, leave any associated activities, and reroute to home.
## scope = travel_plan
alias[effect:cancel_travel_plan] = bool

### Complete the travel plan immediately - no further travelling is executed, and the on_action effect 'on_travel_plan_complete' is run.
## scope = travel_plan
alias[effect:complete_travel_plan] = bool

### Delay the travel plan by specific time duration. Will pause the travel plan, and resume after the duration ends. Will add to any existing delay duration, unless 'add = no' is set.delay_travel_plan = {	days/weeks/months/years = X	add = yes/no [optional]}
## scope = travel_plan
alias[effect:delay_travel_plan] = {
    enum[duration] = alias_keys_field[int_value]
    ## cardinality = 0..1
    add = bool
}

### Pause the travel plan, until explicitly resumed. Any existing pause resume date is removed.
## scope = travel_plan
alias[effect:pause_travel_plan] = bool

### Pause the travel plan, until resumed, if in multiplayer. Any existing pause resume date is removed.
## scope = travel_plan
alias[effect:pause_travel_plan_mp] = bool

### Remove all instances of a modifier from a travel plan
## scope = travel_plan
alias[effect:remove_all_travel_plan_modifier_instances] = <modifier_container>

### Remove character from a travel plan. You cannot remove the travel plan owner.
## scope = travel_plan
alias[effect:remove_all_travel_plan_modifier_instances] = scope[character]

### Removes the travel option specified in the RHS from the scope travel plan.<travel_plan> = { remove_travel_option = name }
## scope = travel_plan
alias[effect:remove_travel_option] = <travel_option>

### Remove a modifier from a travel plan
## scope = travel_plan
alias[effect:remove_travel_plan_modifier] = <modifier_container>

### Remove future destinations of the travel plan and set the next destination to home (travel plan owner default location)
## scope = travel_plan
alias[effect:reroute_to_home] = bool

### Resume the travel plan, if paused.
## scope = travel_plan
alias[effect:resume_travel_plan] = bool

### Resume the travel plan, if paused for multiplayer purposes via 'pause_travel_plan_mp'.
## scope = travel_plan
alias[effect:resume_travel_plan_mp] = bool

### Set a character as the travel leader on the scoped travel plan. Any current leader is moved to be a regular companion in the entourage. set_travel_leader = CHARACTER
## scope = travel_plan
alias[effect:set_travel_leader] = scope[character]

### Set a character as the owner of the scoped travel plan. If they're already the travel leader or an entourage member, it will remove them from those positions. The current owner is moved to be a regular companion in the entourage.
## scope = travel_plan
alias[effect:set_travel_plan_owner] = scope[character]

###################################
# FAITH SCOPE
###################################

### Activate an inactive holy site<faith_scope> = { activate_holy_site = <holy_site_name> }
## scope = faith
alias[effect:activate_holy_site] = <holy_site>

### Add doctrine to faith<faith_scope> = { add_doctrine = <doctrine_name> }
## scope = faith
alias[effect:add_doctrine] = <doctrine>

### Changes the fervor of the faith by the given value. change_fervor = script value
## scope = faith
alias[effect:change_fervor] = alias_keys_field[int_value]

### Changes the fervor of the faith by the given value. change_fervor = script value
## scope = faith
alias[effect:change_fervor] = {
    value = alias_keys_field[int_value]
    desc = localisation
}

### Deactivate an active holy site<faith_scope> = { deactivate_holy_site = <holy_site_name> }
## scope = faith
alias[effect:deactivate_holy_site] = int_value_field # TODO: ?

### Remove doctrine from faith<faith_scope> = { remove_doctrine = <doctrine_name> }
## scope = faith
alias[effect:remove_doctrine] = <doctrine>

### Removes the religious head title of the faith remove_religious_head_title = yes
## scope = faith
alias[effect:remove_religious_head_title] = yes

### Sets the religious head title of the faith to the given title. set_religious_head_title = scope
## scope = faith
alias[effect:set_religious_head_title] = scope[landed_title]

### Starts a great holy war. start_great_holy_war = {target_character = someonetarget_title = some titledelay = script value # Number of days until the war should startwar = some war # Optional. Will make this a directed GHW instead of undirected, and tie it to this specific war}
## scope = faith
alias[effect:start_great_holy_war] = {
    target_character = scope[character]
    target_title = scope[landed_title]
    ## cardinality = 0..1
    delay = value_field
    ## cardinality = 0..1
    war = scope[war]
}

###################################
# STRUGGLE SCOPE
###################################

### Activate a catalyst, activate_struggle_catalyst = { catalyst = X character = Y}where X is a catalystY is scope:character
## scope = struggle
alias[effect:activate_struggle_catalyst] = {
    catalyst = <struggle_catalyst>
    character = scope[character]
}

### Change the phase from the current one to a listed scripted phase without going into transition phase change_struggle_phase = X change_struggle_phase = { struggle_phase = X with_transition = yes/no } where X is a struggle phase type
## scope = struggle
alias[effect:change_struggle_phase] = {
    struggle_phase = <struggle_phase>
    with_transition = bool
}

### Change the current phase duration in the scoped Struggle. change_struggle_phase_duration = { duration = { points = X } } or change_struggle_phase_duration = { duration = { days/weeks/months/years = Y } where X is amount of points(can be negative);Y is amount of days/weeks/months/years (can be negative)
## scope = struggle
alias[effect:change_struggle_phase_duration] = {
    ## cardinality = 0..1
    points = int_value_field
    ## cardinality = 0..1
    duration = single_alias_right[duration_block]
}

### End a struggle, end_struggle = yes
## scope = struggle
alias[effect:end_struggle] = bool

### Set a culture as involved in the scoped Struggle.
## scope = struggle
alias[effect:set_culture_as_involved] = scope[culture]

### Set a culture as involved in the scoped Struggle.
## scope = struggle
alias[effect:set_culture_as_involved] = scope[culture]

### Set a faith as involved in the scoped Struggle.
## scope = struggle
alias[effect:set_faith_as_involved] = scope[faith]

### Set a faith as uninvolved in the scoped Struggle.
## scope = struggle
alias[effect:set_faith_as_uninvolved] = scope[faith]

###################################
# GHW SCOPE
###################################

### Changes the amount of gold in the war chest by the given amount. change_war_chest_gold = script value
## scope = ghw
alias[effect:change_war_chest_gold] = value_field

### Changes the amount of piety in the war chest by the given amount. change_war_chest_piety = script value
## scope = ghw
alias[effect:change_war_chest_piety] = alias_keys_field[int_value]

### Changes the amount of prestige in the war chest by the given amount. change_war_chest_prestige = script value
## scope = ghw
alias[effect:change_war_chest_prestige] = alias_keys_field[int_value]

### The scoped GHW gives out its war-chest in full or in part. divide_war_chest = { 	defenders = yes (default to attackers instead) 	faction = script value (default 1 for 100%) 	gold = no (default = yes) 	piety = no (default = yes) 	prestige = no (default = yes) }
## scope = ghw
alias[effect:divide_war_chest] = {
    ## cardinality = 0..1
    defenders = bool
    ## cardinality = 0..1
    fraction = value_field
    ## cardinality = 0..1
    gold = bool
    ## cardinality = 0..1
    piety = bool
    ## cardinality = 0..1
    prestige = bool
}

### Hands out titles in the target kingdom to the GHW attacker beneficiaries. do_ghw_title_handout = scope:title_and_vassal_change
## scope = ghw
alias[effect:do_ghw_title_handout] = scope[title_and_vassal_change]


### The target character pledges themselves as a defender in the GHW. Must be of the same faith as the GHW target. pledge_defender = some character
## scope = ghw
alias[effect:pledge_attacker] = scope[character]

### The target character pledges themselves as a defender in the GHW. Must be of the same faith as the GHW target. pledge_defender = some character
## scope = ghw
alias[effect:pledge_defender] = scope[character]


### The GHW stops having a designated winner. reset_designated_winner = yes
## scope = ghw
alias[effect:reset_designated_winner] = yes

### The target character becomes the designated winner of the GHW. set_designated_winner = some character
## scope = ghw
alias[effect:set_designated_winner] = scope[character]

### Sets the target of the great holy war. set_great_holy_war_target = { target_character = someone target_title = some title }
## scope = ghw
alias[effect:set_great_holy_war_target] = {
    target_character = scope[character]
    target_title = scope[landed_title]
}

### The target character becomes the character that should declare war instead of the religious head. set_war_declarer = some character
## scope = ghw
alias[effect:set_war_declarer] = scope[character]

### Starts the GHW war. start_ghw_war = undirected_great_holy_war
## scope = ghw
alias[effect:start_ghw_war] = <casus_belli_type>

### The target character removes their pledge as a defender in the GHW. unpledge_defender = some character
## scope = ghw
alias[effect:unpledge_attacker] = scope[character]

### The target character removes their pledge as a defender in the GHW. unpledge_defender = some character
## scope = ghw
alias[effect:unpledge_defender] = scope[character]

###################################
# EPIDEMIC SCOPE
###################################

enums = {
    enum[outbreak_intensity] = {
        major
        minor
        apocalyptic
    }
}

###  Sets the epidemic outbreak intensity to the new value.
## scope = ghw
alias[effect:set_epidemic_outbreak_intensity] = enum[outbreak_intensity]

###################################
# MULTI SCOPE
###################################

### Generates a coat of arms for the scoped landed title, dynasty or house generate_coa = yes
## scope = {landed_title dynasty dynasty_house }
alias[effect:generate_coa] = yes

### Rest the coat of arms for the scoped landed title, dynasty or house to its template reset_coa = yes
## scope = {landed_title dynasty dynasty_house }
alias[effect:reset_coa] = bool # Only used once as ` = THIS`.

### Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type set_coa = k_england set_coa = scope:new_coa
## scope = {landed_title dynasty dynasty_house }
alias[effect:set_coa] = <coat_of_arms>

### Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type set_coa = k_england set_coa = scope:new_coa
## scope = {landed_title dynasty dynasty_house }
alias[effect:set_coa] = scope[landed_title]

### Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type set_coa = k_england set_coa = scope:new_coa
## scope = {landed_title dynasty dynasty_house }
alias[effect:set_coa] = scope[dynasty]

### Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type set_coa = k_england set_coa = scope:new_coa
## scope = {landed_title dynasty dynasty_house }
alias[effect:set_coa] = scope[dynasty_house]

###################################
# CASUS BELLI SCOPE
###################################

### Adds prestige, gold and piety based on contribution to allied attackers. parameters: prestige, gold, piety.
## scope = casus_belli
alias[effect:add_from_contribution_attackers] = {
    ## cardinality = 0..1
    prestige = value_field
    ## cardinality = 0..1
    piety = value_field
    ## cardinality = 0..1
    gold = value_field # TODO: Verify. Never used in vanilla files.
    ## cardinality = 0..1
    opinion = { # Not sure. Only used like this.
        modifier = <opinion_modifier>
    }
}

### Adds prestige, gold and piety based on contribution to allied defenders. parameters: prestige, gold, piety.
## scope = casus_belli
alias[effect:add_from_contribution_defenders] = {
    ## cardinality = 0..1
    prestige = value_field
    ## cardinality = 0..1
    piety = value_field
    ## cardinality = 0..1
    gold = value_field # TODO: Verify. Never used in vanilla files.
    ## cardinality = 0..1
    opinion = { # Not sure. Only used like this.
        modifier = <opinion_modifier>
    }
}

###################################
# ARTIFACT SCOPE
###################################

enums = {
    enum[artifact_history] = {
        created_before_history
        created
        prize_created
        discovered
        creator_discovered
        claimed_by_house
        given
        stolen
        inherited
        conquest
        taken_in_siege
        taken_in_battle
        won_in_duel
        purchased
        prize_awarded
        ransomed
        reforged
    }
}

### Adds a history entry to the artifact, could for example be a reforging event. type = enum - history entry type.; date = jomini date - when this historical event took place; actor = character - who is the actor in the event, for example who created it; recipient = character - who is the recipient in the event, for example who was the artifact given to; location = province - where the event took place
## scope = artifact
alias[effect:add_artifact_history] = single_alias_right[artifact_history_block]

### Adds a static modifier to the given artifact
## scope = artifact
alias[effect:add_artifact_modifier] = <modifier_container>

### Adds the title history of the given title to the scoped artifacts history.add_artifact_title_history = { target = title scope - landed title to take history from; date = game date - from which date onwards to copy historical entries }
## scope = artifact
alias[effect:add_artifact_title_history] = {
    target = scope[landed_title]
    date = replace_me_date
}

### Add this much to the artifacts durability
## scope = artifact
alias[effect:add_durability] = alias_keys_field[int_value]

### Copies the modifiers of the target artifact. Does *not* clear out existing modifiers
## scope = artifact
alias[effect:copy_artifact_modifiers] = scope[artifact]

### Makes the owner of the scoped artifact equip it, will fail if there already is an equipment in the artifact's slot.
## scope = artifact
alias[effect:equip_artifact_to_owner] = bool

### Reforges the given artifact, restoring its durability and potentially changing any other attributes such as type or modifiers unless those fields are left empty. Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals. name = dynamic description - artifact name; description = dynamic description - artifact description; rarity = enum - artifact rarity, ex. legendary; type = flag - inventory slot type, ex. trinket; modifier = static modifier - applied to the character whom wields this artifact; durability = script value - new durability, will be max by default; max_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines; decaying = yes/no - Optional. Set if artifact decays with time. Yes by default; history = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner;   type = artifact history entry type - available types:    created_before_history     created     prize_created    discovered    creator_discovered    claimed_by_house    given    stolen   inherited    conquest    taken_in_siege    taken_in_battle    won_in_duel    purchased    prize_awarded    ransomed    reforged; template = artifact scripted template - a scripted base template with triggers and modifiers; visuals = artifact visual type - how this artifact should appear visually; generate_history = bool - automatically generate a new history entry if none has been scripted?; quality = script value - new quality, used in AI scoring; wealth = script value - new wealth, used in AI scoring; creator = character scope - set a custom creator of the artifact ( default is the owner ); visuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact (only few artifact models actually make use of it. Most notable - banners)
## scope = artifact
## push_scope = artifact
alias[effect:reforge_artifact] = {
    name = single_alias_right[complex_desc]
    description = single_alias_right[complex_desc]
    rarity = enum[artifact_rarity]
    type = <inventory_slot>
    durability = int_value_field
    max_durability = int_value_field
    ## cardinality = 0..1
    decaying = bool
    ## cardinality = 0..1
    history = single_alias_right[artifact_history_block]
    template = <template>
    visuals = <artifact_visual>
    ## cardinality = 0..1
    generate_history = bool
    ## cardinality = 0..1
    quality = int_value_field
    ## cardinality = 0..1
    wealth = int_value_field
    ## cardinality = 0..1
    visuals_source = scope[landed_title]
    ## cardinality = 0..1
    visuals_source = scope[dynasty]
    ## cardinality = 0..1
    visuals_source = scope[dynasty_house]
    alias_name[modifier] = alias_match_left[modifier]
}

### Removes th feature from the specified group from the artifact. Cannot remove required groups.
## scope = artifact
alias[effect:remove_artifact_feature_group] = <feature_group>

### Removes a static modifier to the given artifact. NOTE: does not support duration!
## scope = artifact
alias[effect:remove_artifact_feature_group] = <modifier_container>

### Sets the description of the given artifact
## scope = artifact
## push_scope = artifact
alias[effect:set_artifact_description] = single_alias_right[complex_desc]

### Sets the specified feature on the artifact. If there's already a feature of that group, it gets overridden.
## scope = artifact
alias[effect:set_artifact_feature] = <artifact_feature>

### Sets the name of the given artifact
## scope = artifact
## push_scope = artifact
alias[effect:set_artifact_feature] = single_alias_right[complex_desc]

### Sets the artifact's max durability
## scope = artifact
alias[effect:set_max_durability] = alias_keys_field[int_value]

### Change the artifacts owner and transfer it to the given character set_artifact_owner = {}target = character scope - the new owner character; history = artifact history entry - custom history entry to denote for example that this is artifact was stolen rather than given;generate_history = bool - automatically generate a new history entry if none has been scripted?
## scope = artifact
alias[effect:set_owner] = {
    target = scope[character]
    ## cardinality = 0..1
    history = single_alias_right[artifact_history_block]
    ## cardinality = 0..1
    generate_history = bool
}

### Set if the scoped artifact should decay with time or not
## scope = artifact
alias[effect:set_should_decay] = bool

### Makes the owner of the scoped artifact unequip it.
## scope = artifact
alias[effect:unequip_artifact_from_owner] = bool

single_alias[artifact_history_block] = {
    type = enum[artifact_history] # documentation not explicit
    date = replace_me_date
    ## cardinality = 0..1
    actor = scope[character]
    ## cardinality = 0..1
    recipient = scope[character]
    ## cardinality = 0..1
    location = scope[province]
}

###################################
# NONE SCOPE
###################################

#NOTE: some of these have implied scopes despite not being documented

### Adds diplomacy skill
## scope = character
alias[effect:add_diplomacy_skill] = alias_keys_field[int_value]

### Adds focus progress
## scope = character
alias[effect:add_focus_progress] = alias_keys_field[int_value]

### adds effect to be read internally (no effect in the gamestate)
## scope = character
alias[effect:add_internal_flag] = scalar # Not sure.

### Adds intrigue skill
## scope = character
alias[effect:add_intrigue_skill] = alias_keys_field[int_value]

### Adds learning skill
## scope = character
alias[effect:add_learning_skill] = alias_keys_field[int_value] # TODO: Should check all those add_*_skill effects if they accept a field or just a constant int.

### Adds martial skill
## scope = character
alias[effect:add_martial_skill] = alias_keys_field[int_value]

### Adds prowess skill
## scope = character
alias[effect:add_prowess_skill] = alias_keys_field[int_value]

### Adds stewardship skill
## scope = character
alias[effect:add_stewardship_skill] = alias_keys_field[int_value]

### add law to scoped title, overriding any current law from the same group add_title_law = princely_elective_succession_law
## scope = landed_title
alias[effect:add_title_law] = <law.title_specific>

### add law to scoped title, overriding any current law from the same group. DOES apply law change costs and effects. add_title_law = princely_elective_succession_law
## scope = landed_title
alias[effect:add_title_law_effects] = <law.title_specific>

### Adds the event target to a variable list add_to_variable_list = { name = X target = Y days/week/months/years = z } Where X is the name of the variable Where Y is an event target An optional days where Z is the number of days or script value
alias[effect:add_to_global_variable_list] = {
    name = value_set[global_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
    ## cardinality = 0..1
    enum[duration] = alias_keys_field[int_value]
}

### Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain add_to_list = <string> NOTE, if adding a permanent target to a temporary list, the whole list becomes permanent
alias[effect:add_to_list] = value_set[list]

### Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain add_to_list = <string> NOTE, if adding a permanent target to a temporary list, the whole list becomes permanent
alias[effect:add_to_list] = {
    name = value_set[list]
    value = value_field
}

### Adds the event target to a variable list for the given duration add_to_variable_list = { name = X target = Y days/weeks/months/years = Z } Where X is the name of the variable Where Y is an event target. An optional days where Z is the number of days or script value
alias[effect:add_to_local_variable_list] = {
    name = value_set[local_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field

    ## cardinality = 0..1
    enum[duration] = alias_keys_field[int_value]

}

### Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect add_to_temporary_list = <string> NOTE, if adding a temporary target to a permanent list, the list will stay permanent  This is used to build lists in triggers. If used within an any-trigger, placement within the trigger is quite important. The game will iterate through every instance of the any-trigger until it finds a single instance that fulfills the requirements, and then it will stop. In order to add every instance of a scope that fulfills certain conditions, use "count = all" while also placing this "effect" at the very end of the any-trigger (so that every condition is evaluated for every iteration).
alias[effect:add_to_temporary_list] = value_set[temporary_list]

### Adds the event target to a variable list for the given duration add_to_variable_list = { name = X target = Y days/weeks/months/years = Z } Where X is the name of the variable Where Y is an event target. An optional days where Z is the number of days or script value
alias[effect:add_to_variable_list] = {
    name = value_set[variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field

    ## cardinality = 0..1
    enum[duration] = alias_keys_field[int_value]
}

### Conditionally cause an assert during run time assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string
alias[effect:assert_if] = {
    limit = {
        ## cardinality = 1..inf
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    text = localisation
}

### Conditionally cause an assert during read time assert_read = X, where X is yes or the string to be printed in the assert
alias[effect:assert_read] = yes

### Conditionally cause an assert during read time assert_read = X, where X is yes or the string to be printed in the assert
alias[effect:assert_read] = scalar

### Breaks the betrothal between the scope character to the target character, break_betrothal = target
alias[effect:break_betrothal] = scope[character]

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_global_variable] = {
    name = value[global_variable]
    alias_name[score_operation] = single_alias_right[score_arithmetic]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_local_variable] = {
    name = value[local_variable]
    alias_name[score_operation] = single_alias_right[score_arithmetic]
    alias_name[arithmetic_operation] = alias_match_left[arithmetic_operation]
}

### = { holder = 'Character that should get the title' change = 'previously created title_and_vassal_change', adds a title change, will not transfer vassalstake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a county
alias[effect:change_title_holder] = single_alias_right[title_change]

### = { holder = 'Character that should get the title' change = 'previously created title_and_vassal_change', adds a title change, will transfer vassals take_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a county
alias[effect:change_title_holder_include_vassals] = single_alias_right[title_change]

### Changes the value or a numeric variable change_variable = { name = X operation = Y } Where X is the name of the numeric variable to modify Where the valid operations are add, subtract, multiply, divide and modulo Where Y is a fixed point value, script value or event target of a value type
alias[effect:change_variable] = {
    name = value[variable]
    alias_name[score_operation] = single_alias_right[score_arithmetic]
    alias_name[arithmetic_operation] = alias_keys_field[int_value]
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_global_variable] = {
    name = value[global_variable]
    max = value_field
    min = value_field
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_local_variable] = {
    name = value[local_variable]
    max = value_field
    min = value_field
}

### Clamps a variable the specified max and min clamp_variable = { name = X max = Y min = Z } Where X is the name of the variable Where Y and Z are script values
alias[effect:clamp_variable] = {
    name = value[variable]
    max = value_field
    min = value_field
}

### Empties the list clear_variable_list = variable_name
alias[effect:clear_global_variable_list] = value[global_variable_list]

### Empties the list clear_variable_list = variable_name
alias[effect:clear_local_variable_list] = value[local_variable_list]

### Clears a saved scope from the top scope save_scope_as = cool_scope -> clear_saved_scope = cool_scope
alias[effect:clear_saved_scope] = value[event_target]

### Removes all traits for the character. clear_traits = yes
alias[effect:clear_traits] = bool

### Empties the list clear_variable_list = variable_name
alias[effect:clear_variable_list] = value[variable_list]

### Closes all views. close_all_views = yes
alias[effect:close_all_views] = yes

### Tries to close the defined view. Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players. close_view = {     view = <view name>     player = scope:character # optional, else closes for all players who execute the effect }simplified: close_view = <view name>
alias[effect:close_view] = replace_me # TODO: Handle views.

### Adds all traits of the target to the character. Skips any traits that the character isn't allowed to have. Will not remove the character's existing traits. copy_traits = scope:character
## scope = character
alias[effect:copy_traits] = scope[character]

### Create an accolade for the scoped character with the given knight and types. The name is an optional loc key, a default name will be generated otherwise. create_accolade = { knight = scope:character primary = accolade_type secondary = accolade_type name = loc_key }
## scope = character
alias[effect:create_accolade] = {
    knight = scope[character]
    primary = <accolade>
    secondary = <accolade>
    ## cardinality = 0..1
    name = localisation
}

### Create a title for a landless adventurer. usage:create_adventurer_title = \" name = key/dynamic description holder = <character> (intended holder of the new title) save_scope_as = <name> prefix = key/dynamic description (optional; name used if not specified)adjective = key/dynamic description (optional; name used if not specified)}
alias[effect:create_adventurer_title] = {
    name = single_alias_right[complex_desc]
    holder = scope[character]
    save_scope_as = value_set[scope]
    ## cardinality = 0..1
    prefix = localisation
    ## cardinality = 0..1
    adjective = localisation
}

### Betroth the scope character to the target character, create_betrothal = target (at least one of the characters need to not be adult)
## scope = character
alias[effect:create_betrothal] = scope[character]

### Betroth the scope character to the target character matrilineally, create_betrothal_matrilineal = target (at least one of the characters need to not be adult)
## scope = character
alias[effect:create_betrothal_matrilineal] = scope[character]

### Creates a character save_event_target_as = flag - save the character as an event target save_temporary_event_target_as = flag - save the character as a temporary event target name =  age =  gender = male/female/character scope gender_female_chance = script_value  - Range (0..100)opposite_gender = character scope trait = add this trait random_traits_list = { count = { 1 5 } traitID = { some triggers } traitID = { some triggers } } - A number of traits specified by count (1 if not specified) will be picked from the traits that have their triggers met. Scopes are the same as where create_character is used. More than one grouping like this can be defined  random_traits = yes/no health =  fertility =  mother =  father =  real_father = (should only be set if the real father is not the same as father=) employer = will end up in this court, will become a pool character unless specified or father/mother is landed location = pool province; mutually exclusive with employer template_character =  faith, culture and dynasty are set from 1. template_character 2. father 3. mother 4. employer (not employer for dynasty) unless specified directly faith = faith tag OR a faith scope random_faith = { catholic = { some triggers } cathar = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used  random_faith_in_religion = religion tag OR a faith scope (there's no religion scope) culture = culture name OR a culture scope random_culture = { norse = { some triggers } norwegian = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used  random_culture_in_group = culture group name OR a culture scope (there's no group scope) dynasty_house = dynasty house name OR a dynasty house scope dynasty = generate/none - What to do if dynasty_house is not specified, rather than falling back to template character etc. ethnicity = culture/mother/father/parents/<ethnicity> - How to select ethnicity, culture by default. ethnicities = { <key> = { some_triggers } } - Pick randomly from these ethnicities instead. martial/diplomacy/intrigue...  =  will get random unles
alias[effect:create_character] = {
    ## cardinality = 0..1
    save_scope_as = value_set[event_target]
    ## cardinality = 0..1
    save_temporary_scope_value_as = value_set[temporary_scope]
    ## cardinality = 0..1
    name = localisation
    ## cardinality = 0..1
    age = alias_keys_field[int_value]
    ## cardinality = 0..1
    age = single_alias_right[score_arithmetic]
    ## cardinality = 0..1
    age = {int_value_field int_value_field }
    ## cardinality = 0..1
    gender = enum[genders]
    ## cardinality = 0..1
    gender = scope[character]
    ## cardinality = 0..1
    gender_female_chance = value_field
    ## cardinality = 0..1
    opposite_gender = scope[character]
    ## cardinality = 0..inf
    trait = <trait>
    ## cardinality = 0..inf
    random_traits_list = single_match_right[random_traits_list]
    ## cardinality = 0..1
    random_traits = bool
    ## cardinality = 0..1
    health = float
    ## cardinality = 0..1
    fertility = float
    ## cardinality = 0..1
    mother = scope[character]
    ## cardinality = 0..1
    father = scope[character]
    ## cardinality = 0..1
    real_father = scope[character]
    ## cardinality = 0..1
    employer = scope[character]
    ## cardinality = 0..1
    location = scope[province]
    ## cardinality = 0..1
    template = <scripted_character_template>
    ## cardinality = 0..1
    template_character = scope[character]
    ## cardinality = 0..1
    faith = <faith>
    ## cardinality = 0..1
    faith = scope[faith]
    ## cardinality = 0..1
    random_faith = {
        ## cardinality = 0..inf
        <faith> = {
            ## cardinality = 0..inf
            alias_name[trigger] = alias_match_left[trigger]
        }
        ## cardinality = 0..inf
        scope[faith] = {
            ## cardinality = 0..inf
            alias_name[trigger] = alias_match_left[trigger]
        }
    }
    ## cardinality = 0..1
    random_faith_in_religion = <religion>
    ## cardinality = 0..1
    random_faith_in_religion = scope[faith]
    ## cardinality = 0..1
    culture = <culture>
    ## cardinality = 0..1
    culture = scope[culture]
    ## cardinality = 0..1
    random_culture = {
        ## cardinality = 0..inf
        <culture> = {
            ## cardinality = 0..inf
            alias_name[trigger] = alias_match_left[trigger]
        }
        ## cardinality = 0..inf
        scope[culture] = {
            ## cardinality = 0..inf
            alias_name[trigger] = alias_match_left[trigger]
        }
    }
    ## cardinality = 0..1
    random_culture_in_group = <culture_group>
    ## cardinality = 0..1
    random_culture_in_group = scope[culture]
    ## cardinality = 0..1
    dynasty_house = <house> # TODO: Define dynasty house type.
    ## cardinality = 0..1
    dynasty_house = scope[dynasty_house]
    ## cardinality = 0..1
    dynasty = enum[dynasty_inheritance]
    ## cardinality = 0..1
    ethnicity = enum[ethnicity_picker]
    ## cardinality = 0..1
    ethnicity = <ethnicity>
    ## cardinality = 0..1
    ethnicities = {
        ## cardinality = 1..inf
        <ethnicity> = single_alias_right[trigger_clause]
    }

    ## cardinality = 0..1
    enum[attribute] = int_value_field
    ## cardinality = 0..1
    ## push_scope = character
    after_creation = {
        alias_name[effect] = alias_match_left[effect]
    }
}

enums = {
    enum[ethnicity_picker] = {
        culture
        mother
        father
        parents

    }
}

### Creates a dynamic title The title will be saved to scope:new_title usage: create_dynamic_title = { 	tier = <tier> 	name = key/dynamic description	adjective = key/dynamic description (optional; name used if not specified)}
alias[effect:create_dynamic_title] = {
    tier = enum[title_tier]
    name = localisation
    ## cardinality = 0..1
    adjective = localisation
}

### Create a new holy order create_holy_order = {     leader = scope:a_character     capital = scope:a_barony_title     save_scope_as = new_holy_order # optional way to get a reference to the new holy order }
## push_scope = holy_order
alias[effect:create_holy_order] = {
    save_scope_as = value_set[event_target]
}

### starts a title and vassal change and saves it as a temporary event target create_title_and_vassal_change = { type = conquest (or other type) save_scope_as = change (name of resulting saved scope) add_claim_on_loss = yes (optional) }
alias[effect:create_title_and_vassal_change] = {
    type = value[event_target]
    save_scope_as = value_set[event_target]
    ## cardinality = 0..1
    add_claim_on_loss = bool
}

### Wraps effects that get a custom description instead of the auto-generated one custom_description = { 	text = <effect_localization_key> 	subject = <optional subject scope> #defaults to current scope 	object = <optional object scope> 	value = <optional script value> 	... effects ... }
alias[effect:custom_description] = {
    text = <effect_localization>
    alias_name[effect] = alias_match_left[effect]
}

### Wraps effects that get a custom description instead of the auto-generated one. Also ensures no bullet point appears custom_description_no_bullet = { 	text = <effect_localization_key> 	subject = <optional subject scope> #defaults to current scope 	object = <optional object scope> 	value = <optional script value> 	... effects ... }
alias[effect:custom_description_no_bullet] = {
    text = <effect_localisation>
    ## cardinality = 0..1
    subject = scope_field
    ## cardinality = 0..1
    object = scope_field
    ## cardinality = 0..1
    value = value_field
    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

### just a tooltip, the scope as object (for grouping, localization)
alias[effect:custom_label] = localisation

### just a tooltip, the scope as subject (for grouping, localization)
alias[effect:custom_tooltip] = {
    text = localisation
    alias_name[effect] = alias_match_left[effect]
}

### just a tooltip, the scope as subject (for grouping, localization)
alias[effect:custom_tooltip] = localisation

### Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
alias[effect:debug_log] = localisation

### Logs the current date to the debug.log
alias[effect:debug_log_date] = yes

### Log the current scope to the game log when this effect executes yes = full scope info, no=only current scope
alias[effect:debug_log_scopes] = bool

### Like trigger_event, except it'll print the trigger fulfillment and immediate effects of the event too
alias[effect:debug_trigger_event] = <event>

### Destroy given artifact, regardless of owner.
alias[effect:destroy_artifact] = scope[artifact]

### Destroys the targeted character memory, do not use the destroyed scope after calling this since it will have been removed
alias[effect:destroy_character_memory] = scope[character_memory]

### Destroys the targeted inspiration, do not use the destroyed scope after calling this since it will have been removed
alias[effect:destroy_inspiration] = scope[inspiration]

### Destroy artifact owned by character. Safer version of 'destroy_artifact'.
## scope = character
alias[effect:destroy_owned_artifact] = scope[artifact]

### Divorces the scope character from the target character. divorce = target
## scope = character
alias[effect:divorce] = scope[character]

### duel effect that selects an effect based on comparing specified skill of a character to a value or another character's skill. Alternatively, the compare value can be scripted completely duel = { 	skill = X 	target = Y 	value = Z 	localization = W ... random list body } Where X is the skill to compare, Y is the target character (requires skill to be set) or integer value Z (works with or without the skill), the rest of the effect is the same as random_list If the skill is unspecified, the effect needs a value Z (which can use scripted math) which it will then use as the duel vlue directly If localization = W is specified, the effect localization W will be used (entry in effect_localization database, not a localization key directly) The skill difference (or scripted duel value) is available as scope:duel_value inside the outcome entries, the duel target is accessible as scope:duel_target Valid skill, target, combinations: skill + target, skill + value, only value  Since there is now no automatic weighting, we should be using weight numbers in a comparable range to the scope:duel_value value. Since that will always be between -20 and 20 (unless you do something very unusual), and typically in a more narrow range than that, we should stick to those ranges.  Only use larger weights if you want the duel_value to have a smaller impact on the weighting, and only use smaller weights if you want the duel_value to have a huge impact on the weighting.  In addition, it is fully possible for the compare_modifier to reduce the weight to 0, which would mean that it will not be possible to happen at all. I've requested code support to make it so that we can define min and max values for weights, but until further notice we should use ranges that are guaranteed to not hit 0, or include min values in the compare_modifier itself.  Lastly, remember that if you want the outcome of a duel to scale linearly from (almost) 0% to (almost) 100%, the duel_value should be applied 50% to the good outcome, and -50% to the bad outcome. If you only apply it on one side, you will retain a (presumably significant) chunk of chance for the other outcome.
alias[effect:duel] = {
    ## cardinality = 0..1
    skill = enum[attribute]

    ## cardinality = 0..1
    ### Requires `skill` to be set.
    target = scope[character]

    ## cardinality = 0..1
    ### Works with or without `skill`. Required if `skill` not set.
    value = value_field

    ## cardinality = 0..1
    localization = <effect_localisation> # Never used in vanilla.

    ## cardinality = 0..1
    desc = localisation

    ## cardinality = 0..inf
    int = {
        ## cardinality = 0..1
        desc = localisation
        ## cardinality = 0..1
        trigger = single_alias_right[trigger_clause]

        ## cardinality = 0..inf
        alias_name[weight] = alias_match_left[weight]

        alias_name[effect] = alias_match_left[effect]
    } # TODO: Check this is everything.
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met if = { limit = { <triggers> } <effects> } else = { <effects> }
alias[effect:else] = {
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met if = { limit = { <triggers> } <effects> } else_if = { limit = { <triggers> } <effects> }
alias[effect:else_if] = {
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    alias_name[effect] = alias_match_left[effect]
}

### end_inspiration_sponsorship = inspiration. Stops the sponsorship of the targeted inspiration
alias[effect:end_inspiration_sponsorship] = scope[inspiration]

### Log a string to the error log when this effect executes, error_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
alias[effect:error_log] = localisation

### Log a string to the error log when this effect executes, error_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
alias[effect:error_log] = scalar

### Effect not shown in tooltips
alias[effect:hidden_effect] = {
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Suppress errors for effects using to-be created objects (like artifacts or characters) in tooltips. The effects inside are hidden from the tooltip, with no description generated whatsoever!
alias[effect:hidden_effect_new_object] = {
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria are met if = { limit = { <triggers> } <effects> }
alias[effect:if] = {
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    alias_name[effect] = alias_match_left[effect]
}

### Invalidate and destroy the target activity, running its on_invalidate effect. invalidate_activity = scope:activity
alias[effect:invalidate_activity] = scope[activity]

### Multiplies focus progress
alias[effect:multiply_focus_progress] = replace_me # TODO: Not used in vanilla.

### Tries to open the defined view. interaction = interaction_key - the interaction object key to open redirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid) actor = character_actor - must be defined, must coincide with the current player recipient = character_actor - must be defined secondary_actor = character_secontary_actor - optional secondary_recipient = character_secondary_recipient - optional
alias[effect:open_interaction_window] = {
    interaction = <character_interaction>
    ## cardinality = 0..1
    redirect = bool
    ### Must coincide with the current player.
    actor = scope[character]
    recipient = scope[character]
    ## cardinality = 0..1
    secondary_actor = scope[character]
    ## cardinality = 0..1
    secondary_recipient = scope[character]
}

### Tries to open the defined view without scope data. Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players. open_view = { view = <view name> view_message = <view specific instruction> # optional player = scope:character # optional, else shows for all players who execute the effect } simplified: open_view = <view name>
alias[effect:open_view] = scalar # TODO: How to handle GUI files?

### Tries to open the defined view without scope data. Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players. open_view = { view = <view name> view_message = <view specific instruction> # optional player = scope:character # optional, else shows for all players who execute the effect } simplified: open_view = <view name>
alias[effect:open_view] = {
    view = scalar # TODO: How to handle GUI files?
    ## cardinality = 0..1
    view_message = scalar # TODO: No idea.
    ## cardinality = 0..1
    player = scope[character]
}

# Tries to open the defined view with scope data. Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players. open_view_data = { view = <view name> view_message = <view specific instruction> # optional player = scope:character # optional, else shows for all players who execute the effect } simplified: open_view_data = <view name> for example: scope:faith = { open_view_data = faith_conversion }
alias[effect:open_view_data] = replace_me # TODO: Figure out views.

### Pans the camera to the specified province pan_camera_to_province = scope:army.location
alias[effect:pan_camera_to_province] = scope[province]

### Pans the camera to the specified title pan_camera_to_title = capital_barony
alias[effect:pan_camera_to_title] = scope[landed_title]

### a random effect, random = { chance = X modifier = Y effects... } where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y
alias[effect:random] = {
    chance = int_value_field
    chance = single_alias_right[score_formula]

    ## cardinality = 0..inf
    modifier = single_alias_right[weight_chance_modifier]

    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

###random_list - a random list effect random_list = { X1 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y1 effect1 } X2 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y2 effect2 } ... }Selects one effect from the list and fires it. The effects are weighted by numbers X1, X2... (the higher the number, the higher the chance of the effect being picked). The chances can be modified by optional value modifier lists Y1, Y2... (AKA MTTH)
alias[effect:random_list] = {
    ## cardinality = 1..inf
    int = {
        ## cardinality = 0..1
        trigger = single_alias_right[trigger_clause]

        ## cardinality = 0..inf
        alias_name[weight] = alias_match_left[weight]

        alias_name[effect] = alias_match_left[effect]
    }
}

### Removes the current scope from a named list remove_from_list = <string>
alias[effect:remove_from_list] = value[list]

### Removes a variable remove_variable = variable_name
alias[effect:remove_global_variable] = value[global_variable]


### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_global_variable] = {
    name = value[global_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_local_variable] = {
    name = value[local_variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes the target from a variable list remove_list_variable = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[effect:remove_list_variable] = {
    name = value[variable_list]

    ## cardinality = 0..1
    target = value_field
    ## cardinality = 0..1
    target = scope_field
}

### Removes a variable remove_variable = variable_name
alias[effect:remove_local_variable] = value[local_variable]

### remove law from scoped title. This will leave the law group empty, so only do this if you're getting rid of a law group. DOES NOT apply law removal costs and effects. remove_title_law = princely_elective_succession_law
alias[effect:remove_title_law] = <law.title_specific>

### remove law from scoped title. This will leave the law group empty, so only do this if you're getting rid of a law group. DOES apply law removal costs and effects. remove_title_law = princely_elective_succession_law
alias[effect:remove_title_law_effects] = <law.title_specific>

### Removes a variable remove_variable = variable_name
alias[effect:remove_variable] = value[variable]

### = scope:change Execute and destory the target title and vassal change, the change cannot be used after calling this effect
alias[effect:resolve_title_and_vassal_change] = scope[title_and_vassal_change]

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_global_variable] = {
    name = value[global_variable]
    nearest = value_field
}

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_local_variable] = {
    name = value[local_variable]
    nearest = value_field
}

### Rounds a variable to the nearest specified value clamp_variable = { name = X nearest = Y } Where X is the name of the variable Where Y is a script value
alias[effect:round_variable] = {
    name = value[variable]
    nearest = value_field
}

#TODO Move all these enums
enums = {
    enum[interaction_response] = {
        accept
        maybe
        decline
    }
}

### Execute/send the given interaction. interaction = interaction_key - the interaction object key to run; redirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid) actor = character_actor - must be defined; recipient = character_actor - must be defined;secondary_actor = character_secontary_actor - optional; secondary_recipient = character_secondary_recipient - optional; execute_threshold = accept/maybe/decline - will be executed immediately if the AI response is at least this; send_threshold = accept/maybe/decline - will be sent if the AI response is at least this; At least one of execute_threshold and send_threshold must be set
alias[effect:run_interaction] = {
    interaction = <character_interaction>
    redirect = bool
    actor = scope[character]
    recipient = scope[character]
    ## cardinality = 0..1
    secondary_actor = scope[character]
    ## cardinality = 0..1
    secondary_recipient = scope[character]
    ## cardinality = 0..1
    execute_threshold = enum[interaction_response]
    ## cardinality = 0..1
    send_threshold = enum[interaction_response]
}

### Saves the scoped character's opinion of the target character as an arbitrarily-named target to be referenced later in the (unbroken) event chain. save_opinion_value_as = { name = <string> target = x }
## scope = character
alias[effect:save_opinion_value_as] = {
    name = value_set[variable]
    target = scope[character]
}

### Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain
alias[effect:save_scope_as] = value_set[event_target]

### Saves a numerical or bool value as an arbitrarily-named target to be referenced later in the (unbroken) event chain save_scope_value_as = { name = <string> value = x }
alias[effect:save_scope_value_as] = {
    name = value_set[event_target]
    ## cardinality = 0..1
    value = alias_keys_field[int_value]
    ## cardinality = 0..1
    value = scope_field
    ## cardinality = 0..1
    value = bool
    ## cardinality = 0..1
    value = single_alias_right[score_formula]
}

### Saves the scoped character's opinion of the target character as an arbitrarily-named target to be referenced later in the in the same effect save_temporary_opinion_value_as = { name = <string> target = x 
alias[effect:save_temporary_opinion_value_as] = {
    name = value_set[variable]
    target = scope[character]
}

### Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_event_target_as = <string>
alias[effect:save_temporary_scope_as] = value_set[temporary_scope]

### Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_scope_value_as = { name = <string> value = x }
alias[effect:save_temporary_scope_value_as] = {
    name = value_set[temporary_scope]
    value = alias_keys_field[int_value]
}

### send_long_tutorial_finished_telemetry - Sends a tutorial_finished telemetry event with LongVersion = true
alias[effect:send_long_tutorial_finished_telemetry] = true

### send_short_tutorial_finished_telemetry - Sends a tutorial_finished telemetry event with LongVersion = false
alias[effect:send_long_tutorial_started_telemetry] = true

### send_short_tutorial_finished_telemetry - Sends a tutorial_finished telemetry event with LongVersion = false
alias[effect:send_short_tutorial_finished_telemetry] = false

### send_short_tutorial_started_telemetry - Sends a tutorial_started telemetry event with LongVersion = false
alias[effect:send_short_tutorial_started_telemetry] = false

### Sets focus progress
alias[effect:set_focus_progress] = replace_me # TODO: Check. Never used in vanilla.

### Sets the chance for a generated character to be asexual set_generated_asexuality_chance = 20
alias[effect:set_generated_asexuality_chance] = int

### Sets the chance for a generated character to be bisexual set_generated_bisexuality_chance = 20
alias[effect:set_generated_bisexuality_chance] = int

### Sets the chance for a generated character to be homosexual set_generated_homosexuality_chance = 20
alias[effect:set_generated_homosexuality_chance] = int

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_global_variable] = {
    name = value_set[global_variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    value = alias_keys_field[int_value]
    ## cardinality = 0..1
    value = scope_field
    ## cardinality = 0..1
    value = bool
    ## cardinality = 0..1
    value = single_alias_right[score_formula]
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_global_variable] = value_set[global_variable]

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_local_variable] = {
    name = value_set[local_variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    value = alias_keys_field[int_value]
    ## cardinality = 0..1
    value = scope_field
    ## cardinality = 0..1
    value = bool
    ## cardinality = 0..1
    value = single_alias_right[score_formula]
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_local_variable] = value_set[local_variable]

enums = {
    enum[pregnancy_gender] = {
        male
        female
        random
    }
}

### Set the gender of the unborn child. set_pregnancy_gender = female/male/random
alias[effect:set_pregnancy_gender] = enum[pregnancy_gender]

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_variable] = {
    name = value_set[variable]

    ## cardinality = 0..1
    enum[duration] = int

    ## cardinality = 0..1
    value = alias_keys_field[int_value]
    ## cardinality = 0..1
    value = scope_field
    ## cardinality = 0..1
    value = bool
    ## cardinality = 0..1
    value = single_alias_right[score_formula]
}

### Sets a variable set_variable = { name = X value = Y days = Z } Where X is the name of the variable used to then access it Where Y is any event target, bool, value, script value or flag (flag:W) An optional days where Z is the number of days or script value This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
alias[effect:set_variable] = value_set[variable]

### setup_claim_cb - This effect will add a scope:cb_prestige_factor with a value based on what's being taken. Won't steal land from people not vassalized. setup_claim_cb = {	attacker = scope:attacker	defender = scope:defender	claimant = scope:claimant	change = scope:change	victory = yes/no	take_occupied = yes/no	# Will vassalize people based on their capital location rather than being fully contained.	civil_war = yes}
alias[effect:setup_claim_cb] = {
    titles = value[list]
    attacker = scope[character]
    defender = scope[character]
    claimant = scope[character]
    ## cardinality = 0..1
    change = scope[title_and_vassal_change]
    ## cardinality = 0..1
    victory = bool
    ## cardinality = 0..1
    take_occupied = bool
    ## cardinality = 0..1
    civil_war = bool
}

### setup_de_jure_cb - This effect will add a scope:cb_prestige_factor with a value based on what's being taken setup_de_jure_cb = {	attacker = scope:attacker	defender = scope:defender	change = scope:change	victory = yes/no	# Optional; will make it target a specific dejure title rather than *everything* that is dejure the attacker's	title = scope:title}
alias[effect:setup_de_jure_cb] = {
    ## cardinality = 0..1
    title = scope[landed_title]
    attacker = scope[character]
    defender = scope[character]
    ## cardinality = 0..1
    change = scope[title_and_vassal_change]
    ## cardinality = 0..1
    victory = bool
}

### setup_invasion_cb - This effect will add a scope:cb_prestige_factor with a value based on what's being taken setup_invasion_cb = {	attacker = scope:attacker	defender = scope:defender	change = scope:change	victory = yes/no	take_occupied = yes/no}
alias[effect:setup_invasion_cb] = {
    titles = value[list]
    attacker = scope[character]
    defender = scope[character]
    claimant = scope[character]
    ## cardinality = 0..1
    change = scope[title_and_vassal_change]
    ## cardinality = 0..1
    victory = bool
    ## cardinality = 0..1
    take_occupied = bool
}

### Effect only shown in tooltips (but not executed)
alias[effect:show_as_tooltip] = single_alias_right[effect_clause]

### Start a struggle, start_struggle = { struggle_type = X start_phase = Y }where X is a struggle type, Y is a phase
alias[effect:start_struggle] = {
    struggle_type = <struggle>
    start_phase = <struggle_phase>
}

### Starts the tutorial lesson with the given key. Does nothing if the tutorial is not running, the lesson is completed (or already running), or the lesson cannot be triggered (e.g. trigger fails)
alias[effect:start_tutorial_lesson] = replace_me # TODO: Define tutorials.

### Log key value pairs to a given category via the elastic logging statistics. stats_log = { category = string <string> = <loc_key> } The loc keys will have ROOT, SCOPE, THIS, and PREV available
alias[effect:stats_log] = {
    category = localisation
    scalar = localisation
}

### Switch on a trigger for the evaluation of another trigger with an optional fallback trigger. switch = { 	trigger = simple_assign_trigger 	case_1 = { <effects> } 	case_2 = { <effects> } 	case_n = { <effects> } 	fallback = { <effects> }
alias[effect:switch] = {
    trigger = alias_keys_field[trigger]
    trigger = bool

    ## cardinality = 0..inf
    scope_field = {
        alias_name[effect] = alias_match_left[effect]
    }
    ## cardinality = 0..inf
    int = {
        alias_name[effect] = alias_match_left[effect]
    }
    ## cardinality = 0..inf
    scalar = {
        alias_name[effect] = alias_match_left[effect]
    }
    ## cardinality = 0..1
    fallback = {
        alias_name[effect] = alias_match_left[effect]
    }
}

### triggers an event or on_action trigger_event = { id = X days/months/years = Y } (for events) or trigger_event = { on_action = X days/months/years = Y } (for on_actions) Days/months/years are optional and equal to 0 if not specified. If specified, Y can be a value or an inclusive interval "{ A B }" from which the duration will be picked randomly.
alias[effect:trigger_event] = <event>

### triggers an event or on_action trigger_event = { id = X days/months/years = Y } (for events) or trigger_event = { on_action = X days/months/years = Y } (for on_actions) Days/months/years are optional and equal to 0 if not specified. If specified, Y can be a value or an inclusive interval "{ A B }" from which the duration will be picked randomly.
alias[effect:trigger_event] = {
    alias_name[trigger_event] = alias_match_left[trigger_event]
    ## cardinality = 0..1
    enum[duration] = int
    ## cardinality = 0..1
    enum[duration] = {
        ## cardinality = 2..2
        int
    }
}

### Tries to create an important action notification. Will keep the current one if already exists. important_action_type = important_action_type_key - the important action object key to create. Must be defined. actor = character_actor - optional, can be used by the important action effect recipient = character_actor - optional, can be used by the important action effect secondary_actor = character_secontary_actor - optional, can be used by the important action effect secondary_recipient = character_secondary_recipient - optional, can be used by the important action effect landed_title = landed_title - optional, can be used by the important action effect
alias[effect:try_create_important_action] = replace_me # TODO: Important actions type.

### Tries to create an suggestuib notification. Will keep the current one if already exists. suggestion_type = suggestion_type_key - the suggestion action object key to create. Must be defined. actor = character_actor - optional, can be used by the suggestion effect recipient = character_actor - optional, can be used by the suggestion effect secondary_actor = character_secontary_actor - optional, can be used by the suggestion effect secondary_recipient = character_secondary_recipient - optional, can be used by the suggestion effect landed_title = landed_title - optional, can be used by the suggestion effect
alias[effect:try_create_suggestion] = {
    suggestion_type = <suggestion>
    ## cardinality = 0..1
    actor = scope[character]
    ## cardinality = 0..1
    recipient = scope[character]
    ## cardinality = 0..1
    secondary_actor = scope[character]
    ## cardinality = 0..1
    secondary_recipient = scope[character]
    ## cardinality = 0..1
    landed_title = scope[landed_title]
}

### Repeats enclosed effects while limit criteria are met or until set iteration count is reached while = { limit = { <triggers> } <effects> }  while = { count = 3 <effects> } Default max of 1000.
alias[effect:while] = {
    limit = {
        ## cardinality = 1..inf
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

### Repeats enclosed effects while limit criteria are met or until set iteration count is reached while = { limit = { <triggers> } <effects> }  while = { count = 3 <effects> } Default max of 1000.
alias[effect:while] = {
    count = int
    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

###################################
# PROVINCE SCOPE
###################################

### Add building to the province<province> = { add_building = <building_name> }
## scope = province
alias[effect:add_building] = <building>

### Adds the target legend as spread to the scoped province.
## scope = province
alias[effect:add_legend_spread] = scope[legend]

### Add a modifier to a province add_province_modifier = name add_province_modifier = { modifier = name days/weeks/months/years = int }
## scope = province
alias[effect:add_province_modifier] = single_alias_right[added_modifier]

### Add a special building to the province (will also add/change a special slot if needed)
## scope = province
alias[effect:add_special_building] = <building>

### Add a special building slot to the province<province> = { add_special_building_slot = <building_name> }
## scope = province
alias[effect:add_special_building_slot] = <building>

### Start construction of the specified holding type. By default player won't get anything if manually cancels the construction. scope:my_province = {	begin_create_holding = castle_holding } Optionally refund cost can be set to some value. scope:my_province = {	begin_create_holding = {		type = castle_holding		refund_cost = {			gold = 100		}	}}
## scope = province
alias[effect:begin_create_holding] = {
    type = <holding>
    refund_cost = {
        ## cardinality = 0..1
        gold = int
        ## cardinality = 0..1
        piety = int
        ## cardinality = 0..1
        prestige = int
    }
}

### Creates a new epidemic in the scoped province. create_epidemic_outbreak = {	type = smallpox	intensity = major	save_scope_as = new_epidemic # optional}
## scope = province
alias[effect:begin_create_holding] = {
    type = <epidemic_type>
    intensity = enum[outbreak_intensity]
    save_scope_as = value_set[temporary_scope]
}

### Start construction of the specified holding type. By default player won't get anything if manually cancels the construction. scope:my_province = {	begin_create_holding = castle_holding } Optionally refund cost can be set to some value. scope:my_province = {	begin_create_holding = {		type = castle_holding		refund_cost = {			gold = 100		}	}}
## scope = province
alias[effect:begin_create_holding] = <holding>

### Adds a random building to the province, using the AI's construction logic<province> = { generate_building = yes }
## scope = province
alias[effect:generate_building] = yes

### The scoped province gets its garrison refilled. refill_levy = yes/no
## scope = province
alias[effect:refill_garrison] = bool

### The scoped province gets its levy refilled. refill_levy = yes/no
## scope = province
alias[effect:refill_levy] = bool

### Remove all instances of a modifier from a province. remove_all_province_modifier_instances = name
## scope = province
alias[effect:remove_all_province_modifier_instances] = <modifier_container>

### Remove building from the province<province> = { remove_building = <building_name> }
## scope = province
alias[effect:remove_building] = <building>

### Removes the holding in scoped province, cannot remove capital holdings
## scope = province
alias[effect:remove_holding] = bool

### Removes the target legend as spread to the scoped province.remove_legend_spread = legend
## scope = province
alias[effect:remove_legend_spread] = scope[legend]

### Remove a modifier from a province remove_province_modifier = name
## scope = province
alias[effect:remove_province_modifier] = <modifier_container>

### Remove a travel point of interest type in this province. remove_travel_point_of_interest = point_of_interest_type
## scope = province
alias[effect:remove_travel_point_of_interest] = <point_of_interest>

### Changes the scoped province's holding to another type, removing all buildings that are invalid for the new holding. This might also allow to construct a new holding in an empty province, but it is untested.
## scope = province
alias[effect:set_holding_type] = <holding>

###################################
# WAR SCOPE
###################################

### adds the target character to the scope war as an attacker
## scope = war
alias[effect:add_attacker] = scope[character]

### adds the target character to the scope war as a defender
## scope = war
alias[effect:add_defender] = scope[character]

### Removes the claimant from a war
## scope = war
alias[effect:clear_claimant] = scope[character]

### ends the war with the specified winner, end_war = attacker/defender/white_peace
## scope = war
alias[effect:end_war] = enum[war_ender]

### removes the target character from the scope war
## scope = war
alias[effect:remove_participant] = scope[character]

### sets the target character as already called to the scope war
## scope = war
alias[effect:set_called_to] = scope[character]

### sets the casus belli of the scope war
## scope = war
alias[effect:set_casus_belli] = <casus_belli_type>

###################################
# ACCOLADE SCOPE
###################################

### Activates the scoped Accolade, if there are free slots available else it will be deactivated. activate_accolade = yes
## scope = accolade
alias[effect:activate_accolade] = bool

### Add this much to the Accolades glory
## scope = accolade
alias[effect:add_glory] = alias_keys_field[int_value]

### Deactivates the scoped Accolade, does nothing if it's already inactive
## scope = accolade
alias[effect:deactivate_accolade] = bool

### Removes the acclaimed knight from this Accolade and passes it onto the successor ( if any )
## scope = accolade
alias[effect:remove_acclaimed_knight] = bool

###################################
# LEGEND SCOPE
###################################

### Add a modifier to a legend whose effects should be applied to the county add_legend_county_modifier = name add_legend_county_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = legend
alias[effect:add_legend_county_modifier] = <modifier_container>

### Add a modifier to a legend whose effects should be applied to the county add_legend_province_modifier = name add_legend_province_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = legend
alias[effect:add_legend_owner_modifier] = <modifier_container>

### Add a modifier to a legend whose effects should be applied to the county add_legend_province_modifier = name add_legend_province_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = legend
alias[effect:add_legend_owner_modifier] = {
    modifier = <modifier_container>
    enum[duration] = alias_keys_field[int_value]
    ## cardinality = 0..1
    desc = single_alias_right[complex_desc]
}

### Add a modifier to a legend whose effects should be applied to the owner add_legend_province_modifier = name add_legend_province_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = legend
alias[effect:add_legend_owner_modifier] = <modifier_container>

### Add a modifier to a legend whose effects should be applied to the owner add_legend_province_modifier = name add_legend_province_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = legend
alias[effect:add_legend_owner_modifier] = {
    modifier = <modifier_container>
    enum[duration] = alias_keys_field[int_value]
    ## cardinality = 0..1
    desc = single_alias_right[complex_desc]
}

### Add a modifier to a legend whose effects should be applied to the provinces add_legend_province_modifier = name add_legend_province_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = legend
alias[effect:add_legend_province_modifier] = <modifier_container>

### Add a modifier to a legend whose effects should be applied to the provinces add_legend_province_modifier = name add_legend_province_modifier = { modifier = name days/weeks/months/years = int } You can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier
## scope = legend
alias[effect:add_legend_province_modifier] = {
    modifier = <modifier_container>
    enum[duration] = alias_keys_field[int_value]
    ## cardinality = 0..1
    desc = single_alias_right[complex_desc]
}

### Clears the localization key for the named chapter of the scoped legend. clear_legend_chapter = opening
## scope = legend
alias[effect:clear_legend_chapter] = localisation

### Remove all instances of a modifier from affecting the counties in a legend remove_all_legend_county_modifier_instances = name
## scope = legend
alias[effect:remove_all_legend_county_modifier_instances] = <modifier_container>

### Remove all instances of a modifier from affecting the counties in a legend remove_all_legend_county_modifier_instances = name
## scope = legend
alias[effect:remove_all_legend_owner_modifier_instances] = <modifier_container>

### Remove all instances of a modifier from affecting the provinces in a legend remove_all_legend_province_modifier_instances = name
## scope = legend
alias[effect:remove_all_legend_province_modifier_instances] = <modifier_container>

###  Remove a modifier from affecting the counties in a legend remove_legend_county_modifier = name
## scope = legend
alias[effect:remove_legend_county_modifier] = <modifier_container>

### Remove a modifier from affecting the owner of a legend remove_legend_owner_modifier = name
## scope = legend
alias[effect:remove_legend_owner_modifier] = <modifier_container>

### Remove a modifier from affecting the provinces in a legend remove_legend_province_modifier = name
## scope = legend
alias[effect:remove_legend_province_modifier] = <modifier_container>

### Sets the localization key for the named chapter of the scoped legend to the new value.
## scope = legend
alias[effect:set_legend_chapter] = {
    # TODO
    name = scalar
    localization_key = localisation
}

### Sets the object at the named property of the scoped legend to the new value. set_legend_property = { name = animal_type target = var:hunt_type }
## scope = legend
alias[effect:set_legend_property] = {
    name = value[legend_property]
    target = value_field
    target = scope_field
}

enums = {
    enum[legend_quality] = {
        famed
        illustrious
        mythical
    }
}

### Sets the legend quality to the new value. set_legend_quality = famed
## scope = legend
alias[effect:set_legend_quality] = enum[legend_quality]


###################################
# SCHEME SCOPE
###################################

### Add an agent slot of the specific type to the scoped scheme
## scope = scheme
alias[effect:add_agent_slot] = <agent_slot>

### Add an agent slot of the specific type to the scoped scheme
## scope = scheme
alias[effect:add_scheme_breach] = int_value_field

### adds the specified scheme modifier, add_scheme_modifier = { type = X days = Y } (days are optional, the modifier will expire in Y days if specified)
## scope = scheme
alias[effect:add_scheme_modifier] = {
    type = <modifier_container>
    ## cardinality = 0..1
    days = int
}

### Add progress to the scope scheme. (progress is in 0.0 - 100.0 range)
## scope = scheme
alias[effect:add_scheme_progress] = value_field

### Ends a specific scheme and removes it without any other effect
## scope = scheme
alias[effect:change_opportunities] = alias_keys_field[int_value]

### change_opportunities - Change schemes available opportunities with the given amount.
## scope = scheme
alias[effect:end_scheme] = yes

### Exposes the scheme to the defender
## scope = scheme
alias[effect:expose_scheme] = yes

### Exposes the target character as an agent of the current scheme
## scope = scheme
alias[effect:expose_scheme_agent] = scope[character]

### Ends a specific scheme and removes it. Also runs on_invalidate effects for the scheme and possible contract.
## scope = scheme
alias[effect:invalidate_scheme] = scope[scheme]

### remove_agent_slot - Remove the target agent slot from the scoped scheme
## scope = scheme
alias[effect:remove_agent_slot] = scope[agent_slot]

### removes the specified scheme modifier
## scope = scheme
alias[effect:remove_scheme_modifier] = <modifier_container>

### reset_scheme_progress - Resets the scheme's accumulated success chance growth, opportunities, and current phase progress.
## scope = scheme
alias[effect:reset_scheme_progress] = bool

### scheme_freeze_days = X freezes the scheme for X days (0 unfreezes the scheme)
## scope = scheme
alias[effect:scheme_freeze_days] = int_value_field

### scheme_unfreeze = yes Unfreezes the scheme if it's frozen.
## scope = scheme
alias[effect:scheme_unfreeze] = bool

###################################
# STORY SCOPE
###################################

### Ends a story and executes it's on_end effect, the story can no longer be accessed after this
## scope = story
alias[effect:end_story] = yes

### = character_target  makes the character the new owner of the story
## scope = story
alias[effect:make_story_owner] = scope[character]

###################################
# CHARACTER SCOPE
###################################

### accept_activity_invite = activity The scoped character accepts the invitation to the target activity, using their default travel plan.
## scope = character
alias[effect:accept_activity_invite] = scope[activity]

### accept_activity_invite_without_travel = activity. The scoped character accepts the invitation to the target activity, without adding a travel plan. The character will need to be at the location or they will be kicked out of the activity.
## scope = character
alias[effect:accept_activity_invite_without_travel] = scope[activity]

### accept_task_contract - accept_task_contract = TASK_CONTRACT_SCOPE 
## scope = character
alias[effect:accept_activity_invite] = scope[task_contract]

### add_amenity_level = { type = food value = 2 } Increases the amenity type by the given value for the scoped character
## scope = character
alias[effect:add_amenity_level] = {
    type = <court_amenity_category>
    value = int
}

### adds a character flag usage: add_character_flag = X add_character_flag = { flag = X days/weeks/years = Y } where X is the name of the flag and Y is a value or value interval "{ min max }"
## scope = character
alias[effect:add_character_flag] = {
    flag = value_set[character_flag]
    ## cardinality = 0..1
    enum[duration] = alias_keys_field[int_value]
}

### adds a character flag usage: add_character_flag = X add_character_flag = { flag = X days/weeks/years = Y } where X is the name of the flag and Y is a value or value interval "{ min max }"
## scope = character
alias[effect:add_character_flag] = value_set[character_flag]

### Add a modifier to a character add_character_modifier = name add_character_modifier = { modifier = name days/weeks/months/years = int }
## scope = character
alias[effect:add_character_modifier] = single_alias_right[added_modifier]

### Add a modifier to a character add_character_modifier = name add_character_modifier = { modifier = name days/weeks/months/years = int }
## scope = character
alias[effect:add_character_modifier] = <modifier_container>

### Add the target character to the scoped character's list of contacts add_contact = CHARACTER_SCOPE
## scope = character
alias[effect:add_contact] = scope[character]

### Add the target character to the scope character's court
## scope = character
alias[effect:add_courtier] = scope[character]

### add_dead_character_flag = {	flag = <name> - name of the flag	years/weeks/days = { <min_number> <max_number> } - years/weeks/days this flag is supposed to last } Adds a flag to a dead character. A duration is required.
## scope = character
alias[effect:add_dead_character_flag] = {
    flag = value_set[character_flag]
    enum[duration] = { int int }
    enum[duration] = alias_keys_field[int_value]
}

### Adds lifestyle per points to the given character
## scope = character
alias[effect:add_<lifestyle>_perk_points] = alias_keys_field[int_value]

### Adds lifestyle XP to the given character
## scope = character
alias[effect:add_<lifestyle>_xp] = alias_keys_field[int_value]

### adds (or removes) dread to a character
## scope = character
alias[effect:add_dread] = alias_keys_field[int_value]

### adds gold to a character
## scope = character
alias[effect:add_gold] = alias_keys_field[int_value]

### Adds a hook on a character add_hook = { type = X, target = Y, secret = Z, days/months/years = W  } (days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it)
## scope = character
alias[effect:add_hook] = {
    type = <hook_types>
    target = scope[character]
}

### Adds a hook on a character add_hook = { type = X, target = Y, secret = Z, days/months/years = W  } Note: days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it. Does NOT send a toast to the player.
## scope = character
alias[effect:add_hook_no_toast] = {
    type = <hook_types>
    target = scope[character]
    secret = <secret_type>
    enum[duration] = int
}

### add_joined_faction_discontent = X adds (or subtracts) discontent to the factions the scope character is in
## scope = character
alias[effect:add_joined_faction_discontent] = alias_keys_field[int_value] # TODO: Test out if variables/values work?

### Adds the right hand side character as knowing of the killer of the scoped object dead_person = { add_knows_of_killer = root }
## scope = character
alias[effect:add_knows_of_killer] = scope[character]

### Add or remove legitimacy to the scoped living playable character
## scope = character
alias[effect:add_legitimacy] = alias_keys_field[int_value]

### Add or remove legitimacy to the scoped living playable character
## scope = character
alias[effect:add_legitimacy] = single_alias_right[score_formula]

### Add gold to 'long term' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)
## scope = character
alias[effect:add_long_term_gold] = alias_keys_field[int_value]

### Adds a temporary opinion modifier, add_opinion = { modifier = X days/months/years = Y target = Z } X is a scripted modifier name. Y can be a value or a range "{ A B }" If no timeout are specified, the modifier's scripted default timeout will be used.
## scope = character
alias[effect:add_opinion] = {
    target = scope[character]
    modifier = <opinion_modifier>
    ## cardinality = 0..1
    opinion = alias_keys_field[int_value]
}

### Adds the perk for this character
## scope = character
alias[effect:add_perk] = <lifestyle_perk>

### Adds the perk for this character
## scope = character
alias[effect:add_personal_artifact_claim] = scope[artifact]

### gives (or takes) piety to a character
## scope = character
alias[effect:add_piety] = alias_keys_field[int_value]

### gives (or takes) piety experience to a character
## scope = character
alias[effect:add_piety_experience] = alias_keys_field[int_value]

### increases (or decreases) the piety level of a character
## scope = character
alias[effect:add_piety_level] = alias_keys_field[int_value]

### gives (or takes) piety without experience to a character
## scope = character
alias[effect:add_piety_no_experience] = alias_keys_field[int_value]

### gives a pressed claim to a character
## scope = character
alias[effect:add_pressed_claim] = scope[landed_title]

### gives a pressed claim to a character
## scope = character
alias[effect:add_pressed_claim] = <title> # TODO: Doesn't seem to work correctly atm, probably some bad typing with titles.

### gives (or takes) prestige to a character
## scope = character
alias[effect:add_prestige] = alias_keys_field[int_value]

### gives (or takes) prestige to a character
## scope = character
alias[effect:add_prestige] = single_alias_right[score_formula]

### gives (or takes) prestige experience to a character
## scope = character
alias[effect:add_prestige_experience] = alias_keys_field[int_value]

### increases (or decreases) the prestige level of a character
## scope = character
alias[effect:add_prestige_level] = alias_keys_field[int_value]

### gives (or takes) prestige without experience to a character
## scope = character
alias[effect:add_prestige_no_experience] = alias_keys_field[int_value]

### Adds the given law to the scoped character
## scope = character
alias[effect:add_realm_law] = <law>

### Adds the given law to the scoped character. Skips the cost and the pass effect, and the revoke effects of the current law
## scope = character
alias[effect:add_realm_law_skip_effects] = <law>

### Adds a flag to an existing relation flag = flag_name (declared in scripted_relation) target = other_character relation = scripted_relation  Flags must be defined in the scripted relation before they can be used.  There is a limited number of possible relation flags, set in code. They cannot have a timeout, because they are only possible due to being extremely undemanding of resources.
## scope = character
alias[effect:add_relation_flag] = single_alias_right[relation_flag_clause]

### Add gold to 'reserved' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_reserved_gold = X
## scope = character
alias[effect:add_reserved_gold] = alias_keys_field[int_value]

### Sets a scheme cooldown for the scope character towards = { target=target_character type=scheme_type days/weeks/months/years = duration }
## scope = character
alias[effect:add_scheme_cooldown] = {
    target = scope[character]
    type = <scheme>
    enum[duration] = int
}

### adds a secret add_secret = { type = X target = Y }  Note that if you create a Secret in the immediate effect, the tooltips for other effects run in that Secret's scope (such as reveal_to) are likely to be displayed incorrectly, or not to be displayed at all. This is due to the game generating the tooltip before it actually has a Secret that exists to work off of.  Test rigorously and use custom tooltips if necessary. Creating a Secret in the immediate and then running effects on it in an event option should produce perfectly normal tooltips.
## scope = character
alias[effect:add_secret] = {
    type = <secret_type>
    target = scope[character]
}


### Add gold to 'short term' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_short_term_gold = X
## scope = character
alias[effect:add_short_term_gold] = alias_keys_field[int_value]

### increases (or decreases) stress of a character
## scope = character
alias[effect:add_stress] = alias_keys_field[int_value]

### add_targeting_factions_discontent = X adds (or subtracts) discontent to all the factions that are targeting the scope character
## scope = character
alias[effect:add_targeting_factions_discontent] = alias_keys_field[int_value]

### add_to_activity = activity The scoped character is invited to and accepts an invitation to join the target activity, using their default travel plan
## scope = character
alias[effect:add_to_activity] = scope[activity]

### add_to_activity = activity The scoped character is invited to and accepts an invitation to join the target activity, without adding a travel plan. The character will need to be at the location or they will be kicked out of the activity.
## scope = character
alias[effect:add_to_activity_without_travel] = scope[activity]

### add_to_agent_slot - Adds a character to a specific agent slot
## scope = character
alias[effect:add_to_agent_slot] = scope[agent_slot]

### Adds a trait to a character (the trait will not be added and no tooltip will be shown if the character isn't eligible for the trait, i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range)
## scope = character
alias[effect:add_trait] = <trait>

### Adds a trait to a character (the trait will not be added and no tooltip will be shown if the character isn't eligible for the trait, i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range)
## scope = character
alias[effect:add_trait] = scope[trait]

### Adds a trait to a character (if the add_trait effect would not add the trait - i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range - a tooltip will be shown but the trait will not be added)
## scope = character
alias[effect:add_trait_force_tooltip] = <trait>

### Adds a trait to a character (if the add_trait effect would not add the trait - i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range - a tooltip will be shown but the trait will not be added)
## scope = character
alias[effect:add_trait] = scope[trait]

### Adds XP to the trait level track for the scoped character. Track name is required if the trait has multiple tracks, otherwise should not be provided. add_trait_xp = { trait = <trait_key> track = <track_key> value = <script_value> }
## scope = character
alias[effect:add_trait_xp] = {
    trait = <trait>
    ## cardinality = 0..1
    track = value[trait_track]
    value = alias_keys_field[int_value]
    value = single_alias_right[score_formula]
}

### Sets the both-way truce against the specified character 'character' specifies the target character 'override' says whether it should replace the previous truce even if shorter 'years / months / days' sets the duration of the truce 'result' specifies the result from the scope character's point of view ('white_peace' by default) 'casus_belli_type' sets the casus belli type the truce is for, mutually exclusive with 'war' 'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'casus_belli_type' 'war' sets the war that caused the truce, mutually exclusive with 'casus_belli' add_truce_both_ways = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }
## scope = character
alias[effect:add_truce_both_ways] = {
    character = scope[character]
    ## cardinality = 0..1
    override = bool
    enum[duration] = alias_keys_field[int_value]

    # All three are mutually exclusive, how to handle?
    ## cardinality = 0..1
    casus_belli = scope[casus_belli] # Probably, never used in vanilla files.
    ## cardinality = 0..1
    war = scope[war]
    ## cardinality = 0..1
    name = localisation

    ## cardinality = 0..1
    result = enum[war_result]
}

### Sets the truce against the specified character 'character' specifies the target character 'override' says whether it should replace the previous truce even if shorter 'years / months / days' sets the duration of the truce 'result' specifies the result from the scope character's point of view ('white_peace' by default) 'casus_belli_type' sets the casus belli type the truce is for, mutually exclusive with 'war' 'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'casus_belli_type' add_truce_one_way = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }
## scope = character
alias[effect:add_truce_one_way] = {
    character = scope[character]
    ## cardinality = 0..1
    override = bool
    enum[duration] = alias_keys_field[int_value]

    # All three are mutually exclusive, how to handle?
    ## cardinality = 0..1
    casus_belli = scope[casus_belli] # Probably, never used in vanilla files.
    ## cardinality = 0..1
    war = scope[war]
    ## cardinality = 0..1
    name = localisation

    ## cardinality = 0..1
    result = enum[war_result]
}

### adds (or removes) tyranny to (or from) a character
## scope = character
alias[effect:add_tyranny] = alias_keys_field[int_value]

### gives an unpressed claim to a character
## scope = character
alias[effect:add_unpressed_claim] = scope[landed_title]

### Add the target character as the scope character's guest
## scope = character
alias[effect:add_visiting_courtier] = scope[character]

### Add gold to 'war chest' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_war_chest_gold = X
## scope = character
alias[effect:add_war_chest_gold] = alias_keys_field[int_value]

### Set scoped character as parent ot the targetscope:new_parent = { adopt = scope:offspring }
## scope = character
alias[effect:adopt] = scope[character]

### ai_attempt_to_host_activity - Force the AI to re-evaluate the given activity type and see if they want to host it. This overrides the ai_check_interval and activity cooldown.
## scope = character
alias[effect:ai_attempt_to_host_activity] = <activity>

### ai_start_best_war  = {	# Optional list of CBs that the war must have	cb = { <valid_casus_belli_type1> <valid_casus_belli_type2> }   # If the cb target data from the AI should be recalculated. Otherwise uses current calculated data. (only use if needed!)   recalculate_cb_targets = no   # Filter possible wars, called with scopes:   # root - Current AI character   # scope:target_character - CB Target Character   # scope:target_title - CB (first) Target Title   # scope:target_titles - Target Titles list   # scope:claimant - Character that is Claimant for CB (if present)   # scope:casus_belli_type - CB type   # scope:has_hostage - Boolean if target_character has a hostage for current AI character   # scope:score - AI score for CB	is_valid = { ... }    # Effect called when war was successfully started (scopes are similar to is_valid)	on_success = { ... }     # Effect called when no war was found or successfully started	on_failure = { ... } }
## scope = character
alias[effect:ai_start_best_war] = {
    ##cardinality = 0..1
    cb = {
        ##cardinality = 1..inf
        <casus_belli>
    }
    recalculate_cb_targets = bool
    ##replace_scope = { root = character target_character = character target_title = landed_title target_titles = list claimant = character casus_belli_type = casus_belli has_hostage = bool score = int}
    is_valid = single_alias_right[trigger_clause]
    ##replace_scope = { root = character target_character = character target_title = landed_title target_titles = list claimant = character casus_belli_type = casus_belli has_hostage = bool score = int}
    on_success = single_alias_right[effect_clause]
}

### Allows (previously broken) alliance with the target character
## scope = character
alias[effect:allow_alliance] = scope[character]

### Allow the character to join the scheme as an agent
## scope = character
alias[effect:allow_in_scheme] = scope[scheme]

### Apply the new level for the most desired AI obligation level the liege in the contract wants
## scope = character
alias[effect:apply_ai_vassal_obligation_liege_most_desired] = <vassal_obligation_level>

### Apply the new level for the most desired AI obligation level the vassal in the contract wants
## scope = character
alias[effect:apply_ai_vassal_obligation_vassal_most_desired] = <vassal_obligation_level>

### Appoints the target character in target court position within scoped character's court recipient = character scope - target character to receive the title court_position = court position type - court position type to assign the receiver
## scope = character
alias[effect:appoint_court_position] = {
    recipient = scope[character]
    court_position = <court_position>
}

### Assigns the target character to the first available council position of the type available assign_council_task = {     council_task = council_task_scope     target = character_taking_the_position    fire_on_actions = [yes] }
## scope = character
alias[effect:assign_council_task] = {
    council_task = scope[council_task]
    target = scope[character]
    ## cardinality = 0..1
    fire_on_actions = bool
}

### Assigns the target character to the first available council position of the type available. { type = council_position_type_key target = character_taking_the_position fire_on_actions = [yes] }
## scope = character
alias[effect:assign_councillor_type] = {
    type = <council_position>
    target = scope[character]
    ## cardinality = 0..1
    fire_on_actions = scalar
}

### The character gets banished.
## scope = character
alias[effect:banish] = yes

### becomes and independent ruler. becomes_independent = { change = 'previously created title_and_vassal_change'
## scope = character
alias[effect:becomes_independent] = {
    change = scope[title_and_vassal_change]
}

### Breaks the alliance with the target character
## scope = character
alias[effect:break_alliance] = scope[character]

### Ends the truce against the specified character, and theirs against the scoped character. cancel_truce_both_ways = scope:character
## scope = character
alias[effect:cancel_truce_both_ways] = scope[character]

### Ends the truce against the specified character. cancel_truce_one_way = scope:character
## scope = character
alias[effect:cancel_truce_one_way] = scope[character]

### Changes the character's age by the given amount. Sets age to 0 if it'd end up below 0. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command
## scope = character
alias[effect:change_age] = alias_keys_field[int_value]

### Changes the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.
## scope = character
alias[effect:change_current_court_grandeur] = alias_keys_field[int_value]

### Change the current weight of the scoped character change_current_weight = 20
## scope = character
alias[effect:change_current_weight] = alias_keys_field[int_value]

### Change scales of power swing for the active diarchy change_diarchy_swing = -5
## scope = character
alias[effect:change_diarchy_swing] = alias_keys_field[int_value]

### Change the first name of a character change_first_name = <localization_key> change_first_name = scope:name/var:name # containing a flag with a localization key change_first_name = { template_character = scope:character } # copy name from the template character
## scope = character
alias[effect:change_first_name] = localisation

### Change the first name of a character change_first_name = <localization_key> change_first_name = scope:name/var:name # containing a flag with a localization key change_first_name = { template_character = scope:character } # copy name from the template character
## scope = character
alias[effect:change_first_name] = scope[flag] # TODO: ? Not sure.

### Change the first name of a character change_first_name = <localization_key> change_first_name = scope:name/var:name # containing a flag with a localization key change_first_name = { template_character = scope:character } # copy name from the template character
## scope = character
alias[effect:change_first_name] = {
    template_character = scope[character]
}

### changes the government of a character
## scope = character
alias[effect:change_government] = <government>

### changes influence of a character
## scope = character
alias[effect:change_influence] = alias_keys_field[int_value]

### changes influence experience of a character
## scope = character
alias[effect:change_influence_experience] = alias_keys_field[int_value]

### changes the influence level of a character
## scope = character
alias[effect:change_influence_level] = alias_keys_field[int_value]

### changes influence (without experience) of a character
## scope = character
alias[effect:change_influence_no_experience] = alias_keys_field[int_value]

### = { liege = 'Character that should become the new liege' change = 'previously created title_and_vassal_change', adds a liege change
## scope = character
alias[effect:change_liege] = {
    liege = scope:character
    change = scope:title_and_vassal_change
}

### Changes the charater's prison type. Scoped character is the prisoner. Accepts any static modifier (see also improson effect). change_prison_type = house_arrest
## scope = character
alias[effect:change_prison_type] = enum[prison_type]

### Change strife opinion caused by the scoped character
## scope = character
alias[effect:change_strife_opinion] = alias_keys_field[int_value]

### Change the target weight of the scoped character change_target_weight = 20
## scope = character
alias[effect:change_target_weight] = int_value_field

### Changes the trait rank = { trait = trait_group rank = change max = maximum new rank }
## scope = character
alias[effect:change_trait_rank] = {
    trait = value[trait_group]
    rank = int
    ## cardinality = 0..1
    max = int
}

### Remove any currently set designated heir of a character.
## scope = character
alias[effect:clear_designated_heir] = yes

### Clears forced voting clear_forced_vote = yes
## scope = character
alias[effect:clear_forced_vote] = yes

### complete_activity_intent = bool Complete the scoped character's current intent in their involved activity
## scope = character
alias[effect:complete_activity_intent] = bool

### 'Consume' all banish reasons that the scoped character has on the target character. Until they get a new reason, they cannot banish the target again.
## scope = character
alias[effect:consume_banish_reasons] = scope[character]

### 'Consume' all divorce reason that the scoped character has on the target character. Until they get a new reason, they cannot divorce the target again.
## scope = character
alias[effect:consume_divorce_reasons] = scope[character]

### 'Consume' all execute reasons that the scoped character has on the target character. Until they get a new reason, they cannot execute the target again.
## scope = character
alias[effect:consume_execute_reasons] = scope[character]

### 'Consume' all imprisonment reasons that the scoped character has on the target character. Until they get a new reason, they cannot imprison the target again.
## scope = character
alias[effect:consume_imprisonment_reasons] = scope[character]

### 'Consume' 1 revoke title reason that the scoped character has on the target character.
## scope = character
alias[effect:consume_revoke_title_reason] = scope[character]

### copies the inheritable appearance attributes (inheritable genes in the character's DNA string) from the target character to the scoped character
## scope = character
alias[effect:copy_inheritable_appearance_from] = scope[character]

### Copies a piece of localized text from the target character for the given key. copy_localized_text = { key = key target = character }
## scope = character
alias[effect:copy_localized_text] = {
    key = value[variable]
    target = scope[character]
}

### Create an alliance between the scoped character and the target. The allied through characters determine who gets checked against for if the alliance should persist or not. create_alliance = { 	target = scope 	allied_through_owner = scope 	allied_through_target = scope } OR as a short hand use just the target to use the owner and target as the allied through characters create_alliance = scope
## scope = character
alias[effect:create_alliance] = scope[character]

### Create an alliance between the scoped character and the target. The allied through characters determine who gets checked against for if the alliance should persist or not. create_alliance = { 	target = scope 	allied_through_owner = scope 	allied_through_target = scope } OR as a short hand use just the target to use the owner and target as the allied through characters create_alliance = scope
## scope = character
alias[effect:create_alliance] = {
	target = scope[character]
	allied_through_owner = scope[character]
	allied_through_target = scope[character]
}

### Creates a new artifact and adds it to the inventory of the given character. Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals. name = dynamic description - artifact name; description = dynamic description - artifact description; rarity = enum - artifact rarity, ex. legendary;type = flag - inventory slot type, ex. trinket; modifier = static modifier - applied to the character whom wields this artifact;durability = script value - new durability, will be max by default;max_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines; decaying = yes/no - Optional. Set if artifact decays with time. Yes by default; history = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner;   type = artifact history entry type - available types:    created_before_history    created    prize_created    discovered    creator_discovered    claimed_by_house    given    stolen    inherited    conquest    taken_in_siege    taken_in_battle    won_in_duel    purchased    prize_awarded    ransomed    reforgedtemplate = artifact scripted template - a scripted base template with triggers and modifiers; visuals = artifact visual type - how this artifact should appear visually; generate_history = bool - automatically generate a new history entry if none has been scripted?; quality = script value - new quality, used in AI scoring; wealth = script value - new wealth, used in AI scoring; creator = character scope - set a custom creator of the artifact ( default is the owner ); visuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact; (only few artifact models actually make use of it. Most notable - banners); save_scope_as = new artifact - an optional way to get a reference to the newly created artifact;title_history = title - history entries of the given title will be added to the artifact history; title_history_date = game date - from which date onwards to copy historical entries from given title;creator = character scope - set a custom creator of the artifact ( default is the owner )
## scope = character
alias[effect:create_artifact] = {
	name = single_alias_right[complex_desc]
    description = single_alias_right[complex_desc]
    rarity = enum[artifact_rarity]
    type = <inventory_slot>
    durability = int_value_field
    max_durability = int_value_field
    decaying = bool
    history = single_alias_right[artifact_history_block]
    template = <template>
    visuals = <artifact_visual>
    quality = int_value_field
    wealth = int_value_field
    creator = scope[character]
    ## cardinality = 0..1
    visuals_source = scope[landed_title]
    ## cardinality = 0..1
    visuals_source = scope[dynasty]
    ## cardinality = 0..1
    visuals_source = scope[dynasty_house]
    alias_name[modifier] = alias_match_left[modifier]
}

### The scope character creates a cadet branch of the house he is in [yes|no]
## scope = character
alias[effect:create_cadet_branch] = bool

### Creates a memory for the character of a given type and participants plus an optional duration. Saved as scope:new_memory. create_character_memory = { type = memory_type participants = { tag = scope } duration = { years = 3 } }
## scope = character
## replace_scope = { new_memory = character_memory }
alias[effect:create_character_memory] = {
    type = <memory>
    ## cardinality = 0..1
    participants = {
        ## cardinality = 1..inf
        scalar = scope_field
    }
    ## cardinality = 0..1
    duration = single_alias_right[duration_block]
}

## push_scope = character_memory
alias[effect:scope:new_memory] = single_alias_right[effect_clause]

## push_scope = character_memory
alias[trigger:scope:new_memory] = single_alias_right[trigger_clause]

### Creates a new divergent culture from the scope character's culture. The new culture will keep all pillars and traditions of the parent culture � it is up to the user to add or remove pillars and traditions as appropriate.The new divergent culture is saved as scope:new_culture. create_divergent_culture = yes
## scope = character
alias[effect:create_divergent_culture] = bool

### Creates a new divergent culture from the scope character's culture. This also incurs the cost, does conversion, and such, just as if you'd diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations. 
## scope = character
alias[effect:create_divergent_culture_with_side_effects] = bool

### Creates a new divergent culture from the scope character's culture. Ignores the cost, does conversion, and such, just as if you'd diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations.
## scope = character
alias[effect:create_divergent_culture_with_side_effects_excluding_cost] = bool

### the scoped character creates a faction of the specified type against the specified target, create_faction = { type = X target = Y }
## scope = character
alias[effect:create_faction] = {
    type = <faction>
    target = scope[character]
}

### Creates a new hybrid culture from the scope character's culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. The new hybrid culture is saved as scope:new_culture. 
## scope = character
alias[effect:create_hybrid_culture] = scope[culture]

### Creates a new hybrid culture from the scope character's culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. This also incurs the cost, does conversion, and such, just as if you'd hybridized via the UI. The new hybrid culture is NOT saved as a scope due to technical limitations.
## scope = character
alias[effect:create_hybrid_culture_with_side_effects] = scope[culture]

### create_inspiration = inspiration_type Creates an inspiration of a given type owned by scoped character, new inspiration is saved as scope:new_inspiration create_inspiration = { type = inspiration_type gold = script_value } As above but overrides the base cost compared to the one defined in the type
## scope = character
alias[effect:create_inspiration] = <inspiration>

### create_inspiration = inspiration_type Creates an inspiration of a given type owned by scoped character, new inspiration is saved as scope:new_inspiration create_inspiration = { type = inspiration_type gold = script_value } As above but overrides the base cost compared to the one defined in the type
## scope = character
alias[effect:create_inspiration] = {
    type = inspiration
    gold = alias_keys_field[int_value]
}

### Creates a new legend owned by the scoped character. create_legend = {	type = heroic	quality = famed	chronicle = chronicle_type	properties = {		<key> = scope		<key> = scope		(Where each <key> must match to the property of that chronicle type)		( and the resulting scope object must be of the type of that property	)	}	protagonist = character # optional, defaults to scoped character	save_scope_as = new_legend # optional}
## scope = character
alias[effect:create_legend] = {
    type = <legend_type>
    quality = enum[legend_quality]
    chronicle = <chronicle>
    properties = {
        ## cardinality = 0..inf
        scalar = scope_field
    }
    ## cardinality = 0..1
    protagonist = scope[character]
    ## cardinality = 0..1
    save_scope_as = value_set[event_target]
}

### Creates a new legend ssed owned by the scoped character. create_legend_seed = {	type = heroic	quality = famed	chronicle = chronicle_type	properties = {		<key> = scope		<key> = scope		(Where each <key> must match to the property of that chronicle type and the resulting scope object must be of the type of that property	)	} }
## scope = character
alias[effect:create_legend_seed] = {
    type = <legend_type>
    quality = enum[legend_quality]
    chronicle = <chronicle>
    properties = {
        ## cardinality = 0..inf
        scalar = scope_field
    }
}

### Create MaA regiment for a ruler. If title is set, MaA will be created as title troops. scope:ruler = {	create_maa_regiment = light_footmen	create_maa_regiment = {		type = light_footmen          # mutually exclusive with type_of		type_of = scope:maa_regiment  # mutually exclusive with type. Take MaA type from the scoped regiment		check_can_recruit = no		title = scope:title		size = 5	}}
## scope = character
alias[effect:create_maa_regiment] = <maa_type>

alias[effect:create_maa_regiment] = {
    ## cardinality = 0..1
    type = <maa_type>
    ## cardinality = 0..1
    type_of = scope[maa_regiment]
    check_can_recruit = bool
    title = scope[landed_title]
    size = int_value_field
}


### Either create = story_cycle or create_story = { type = story_type save_scope_as/save_temporary_scope_as = scope_name # optional way to get a reference to the new story }. Creates and initializes a story cycle with the current character as owner
## scope = character
alias[effect:create_story] = <story_cycle>

### Either create = story_cycle or create_story = { type = story_type save_scope_as/save_temporary_scope_as = scope_name # optional way to get a reference to the new story }. Creates and initializes a story cycle with the current character as owner
## scope = character
alias[effect:create_story] = {
    type = <story_cycle>

    ## cardinality = 0..1
    save_scope_as = value_set[event_target]
    ## cardinality = 0..1
    save_temporary_scope_as = value_set[temporary_scope]
}

### create_task_contract = {  #Mandatory parameters   task_contract_type = TYPE_NAME  task_task_contract_tier = VALUE  location = PROVINCE_SCOPE  #Optional parameters  task_contract_employer = CHARACTER_SCOPE  destination = PROVINCE_SCOPE  target = CHARACTER_SCOPE  save_scope_as = new_task_contract # optional } 
## scope = character
alias[effect:create_task_contract] = {
    task_contract_type = <contract>
    task_contract_tier = alias_keys_field[int_value]
    location = scope[province]
    ## cardinality = 0..1
    task_contract_employer = scope[character]
    ## cardinality = 0..1
    destination = scope[province]
    ## cardinality = 0..1
    target = scope[character]
    ## cardinality = 0..1
    save_scope_as = value_set[event_target]
}


### kills a character, death = { killer = X death_reason = Y artifact = Z }, where X is a character and Y is one of the death reason keys. Optionally artifact Z will be used as the killing artifact instead of the defaulted one from the killer's slot for that death reason's definition. Or death = natural which will pick a natural death reason to kill the character from.
## scope = character
alias[effect:death] = {
    death_reason = <death_reason>
    ## cardinality = 0..1
    killer = scope[character]
    ## cardinality = 0..1
    artifact = scope[artifact]
}

### kills a character, death = { killer = X death_reason = Y artifact = Z }, where X is a character and Y is one of the death reason keys. Optionally artifact Z will be used as the killing artifact instead of the defaulted one from the killer's slot for that death reason's definition. Or death = natural which will pick a natural death reason to kill the character from.
## scope = character
alias[effect:death] = natural

### The scoped character declines the invitation to the target activity
## scope = character
alias[effect:decline_activity_invite] = scope[character]

### The character in scope gets deposed.
## scope = character
alias[effect:depose] = yes

### Current scoped diarch is deposed and replaced with the next from the line of succession
## scope = character
alias[effect:depose_diarch] = yes

### Designated target character as a future diarch
## scope = character
alias[effect:designate_diarch] = yes

### Destroys a title
## scope = character
alias[effect:destroy_title] = scope[landed_title]

### End diarchy for the character end_diarchy = yes/no
## scope = character
alias[effect:end_diarchy] = yes

### end a pregnancy
## scope = character
alias[effect:end_pregnancy] = bool

### Execute the specified decision for the scoped character
## scope = character
alias[effect:execute_decision] = <decision>

### The councillor finish the current assigned task successfully.
## scope = character
alias[effect:finish_council_task] = yes

### The scope character fires the target character form teh council.
## scope = character
alias[effect:fire_councillor] = scope[character]

### The scoped character fires the target character.
## scope = character
alias[effect:fire_tax_collector] = scope[character]

### Forbid the scope character from joining the target scheme as an agent (and kick the character out if already in the scheme)
## scope = character
alias[effect:forbid_from_scheme] = scope[scheme]

### Adds a character as an agent to the scheme and forces them to stay{    scheme = target_Scheme    days/months/years = duration}
## scope = character
alias[effect:force_add_to_agent_slot] = {
    agent_slot = scope[agent_slot]
    enum[duration] = int
}

### Forces a character's skills to be recalculated immediately, bypassing the wait for the daily tick. NOTE: Only use this when *absolutely* necessary, as it will impact performance negatively if misused
## scope = character
alias[effect:force_character_skill_recalculation] = bool

### Forces the character to vote the same as the target force_vote_as = { target = someone days/months/years = x }
## scope = character
alias[effect:force_vote_as] = {
    target = scope[character]
    enum[duration] = int
}

### gives a title to a character
## scope = character
alias[effect:get_title] = scope[landed_title]

### gives a title to a character
## scope = character
alias[effect:get_title] = <title>

### Give a nickname to this character
## scope = character
alias[effect:give_nickname] = <nickname>

### Give a noble family title to the <root> character.
## scope = character
alias[effect:give_noble_family_title] = {
    name = single_alias_right[complex_desc]
    save_scope_as = value_set[event_target]
}

### Imprisons the target character as this character's prisoner, imprison = { target = X reason = Y type = Z }, where X is a character, Y is a flag, Z is a static modifier
## scope = character
alias[effect:imprison] = {
    target = scope[character]
    type = <modifier_container> # Accepts static modifiers that act as imprisonment types (dungeon/house_arrest)
    ## cardinality = 0..1
    reason = scalar # TODO: Can't find in vanilla files.
}

### Infect the scoped character with the target epidemic.
## scope = character
alias[effect:infect_with_epidemic] = scope[epidemic]

### Immediately check if diarch should be invalidated. If needed, current scoped diarch is removed and replaced with the next one from the line of succession
## scope = character
alias[effect:invalidate_diarch_if_needed] = bool

### The scoped character is invited to the target activity
## scope = character
alias[effect:invite_to_activity] = scope[activity]

### the character in the scope joins the assigned faction
## scope = character
alias[effect:join_faction] = scope[faction]

### the character in the scope is forced to join a faction by a character for a defined time, join_faction_forced = {     faction = X     forced_by = Y     days/months/years = duration }
## scope = character
alias[effect:join_faction_forced] = {
    faction = scope[faction]
    forced_by = scope[character]
    enum[duration] = int
}

### the character in the scope joins the assigned faction skiping the can_character_join trigger
## scope = character
alias[effect:join_faction_skip_check] = scope[faction]

### The character learns the court language of the target characterlearn_court_language_of = scope:target_character
## scope = character
alias[effect:learn_court_language_of] = scope[character]

### The character learns the languagelearn_language = language_norwegian
## scope = character
alias[effect:learn_language] = <culture.language>

### The character learns the language of the target culturelearn_language_of_culture = scope:target_culture
## scope = character
alias[effect:learn_language_of_culture] = scope[culture]

### the charcter in the scope leaves the assigned faction
## scope = character
alias[effect:leave_faction] = scope[faction]

### makes a claim strong (character adds the claim if not having it already)
## scope = character
alias[effect:make_claim_strong] = scope[landed_title]

### makes a claim weak (character adds the claim if not having it already)
## scope = character
alias[effect:make_claim_weak] = scope[landed_title]

### Makes the target character a concubine of the scope character, the target should not be imprisoned
## scope = character
alias[effect:make_concubine] = scope[character]

### makes a character pregnant   father= 'the real father'  number_of_children= X  known_bastard=yes/no
## scope = character
alias[effect:make_pregnant] = {
    father = scope[character]
    number_of_children = int_value_field
    ## cardinality = 0..1
    known_bastard = bool
}

### makes a character pregnant. Doesn't error on things like celibacy 
## scope = character
alias[effect:make_pregnant_no_checks] = {
    father = scope[character]
    number_of_children = int_value_field
    ## cardinality = 0..1
    known_bastard = bool
}

### Activates an inactive trait. Tooltip will not be shown if the character cannot have the trait.
## scope = character
alias[effect:make_trait_active] = <trait>

### Activates an inactive trait. Tooltip will be shown even if the character cannot have the trait.
## scope = character
alias[effect:make_trait_active_force_tooltip] = <trait>

### Makes a current trait of a character inactive. Tooltip will not be shown if the character doesn't have the trait.
## scope = character
alias[effect:make_trait_inactive] = <trait>

### Makes a current trait of a character inactive. Tooltip will be shown even if the character doesn't have the trait.
## scope = character
alias[effect:make_trait_inactive_force_tooltip] = <trait>

### The scope character will no longer be prunable after their death. Use with care, as this will make everyone related to them unprunable too. So you should only use this if someone absolutely *needs* to stick around several years after their death. Example: make_unprunable = yes
## scope = character
alias[effect:make_unprunable] = bool

### Marries the scoped character to the target character marry = target
## scope = character
alias[effect:marry] = scope[character]

### Marries the scoped character to the target character matrilineally marry_matrilineal = target
## scope = character
alias[effect:marry_matrilineal] = scope[character]

enums = {
    enum[ai_budget_category] = {
        budget_war_chest
        budget_reserved
        budget_short_term
        budget_long_term
    }
}

### Move gold from one AI budget category to the other, will not move more than is available in the source budget or what can fit in the target budget.character, move_budget_gold = { gold = X from = Z to = Y } ('budget_war_chest', 'budget_reserved', 'budget_short_term', 'budget_long_term')
## scope = character
alias[effect:move_budget_gold] = {
    gold = alias_keys_field[int_value]
    from = enum[ai_budget_category]
    to = enum[ai_budget_category]
}

### The scoped character (courtier or guest) leaves their current court and moves into the pool scope:guest = { move_to_pool = yes }
## scope = character
alias[effect:move_to_pool] = yes

### The scoped character (courtier/guest/pool character) leaves their current court (if any) and moves into the pool of the specified province scope:guest = { move_to_pool_at = scope:some_province }
## scope = character
alias[effect:move_to_pool_at] = scope[province]

### Opens the appointment window for the specified court position with scoped character as liege
## scope = character
alias[effect:open_appoint_court_position_window] = bool

### the scope character pays gold to the target character, pay_gold = { target = X gold = Y } (AI budget category long term)
## scope = character
alias[effect:pay_long_term_gold] = {
    target = scope[character]
    gold = alias_keys_field[int_value]
}

### the scope character immediately pays gold corresponding to their income to the target character, pay_income = { target = X days/months/years = Y } (AI budget long term)
## scope = character
alias[effect:pay_long_term_income] = {
    target = scope[character]
    enum[duration] = int
}

### the scope character pays gold to the target character, pay_gold = { target = X gold = Y } (AI budget category long term)
## scope = character
alias[effect:pay_reserved_gold] = {
    target = scope[character]
    gold = alias_keys_field[int_value]
}

### the scope character immediately pays gold corresponding to their income to the target character, pay_income = { target = X days/months/years = Y } (AI budget long term)
## scope = character
alias[effect:pay_reserved_income] = {
    target = scope[character]
    enum[duration] = int
}

### the scope character pays gold to the target character, pay_gold = { target = X gold = Y } (AI budget category short term)
## scope = character
alias[effect:pay_short_term_gold] = {
    target = scope[character]
    gold = alias_keys_field[int_value]
}

### the scope character immediately pays gold corresponding to their income to the target character, pay_income = { target = X days/months/years = Y } (AI budget short term)
## scope = character
alias[effect:pay_war_chest_gold] = {
    target = scope[character]
    enum[duration] = int
}

### the scope character immediately pays gold corresponding to their income to the target character, pay_income = { target = X days/months/years = Y } (AI budget short term)
## scope = character
alias[effect:pay_war_chest_income] = {
    target = scope[character]
    enum[duration] = int
}

### Plays the specified music cue.
## scope = character
alias[effect:play_music_cue] = scalar # TODO: Music folder.

### Plays the specified music cue.
## scope = character
alias[effect:play_sound_effect] = scalar # TODO: Music folder.

### Populate area around location with task contracts up to specified amount
## scope = character
alias[effect:populate_task_contracts_for_area] = {
    location = scope:province
    amount = alias_keys_field[int_value]
    group = { scalar } # TODO = replace with contract groups 
}


### Refunds all perks of the character. Example: refund_all_perks = yes
## scope = character
alias[effect:refund_all_perks] = yes

### Refunds all perks of the RHS lifestyle. Example: refund_perks = intrigue_lifestyle
## scope = character
alias[effect:refund_perks] = <lifestyle>

### releases the character from the prison, imprison = X, where X is a boolean value
## scope = character
alias[effect:release_from_prison] = bool

### Remove all instances of a modifier from a character remove_all_character_modifier_instances = name
## scope = character
alias[effect:remove_all_character_modifier_instances] = <modifier_container>

### removes a character flag
## scope = character
alias[effect:remove_character_flag] = value[character_flag]

### Remove a modifier from a character remove_character_modifier = name
## scope = character
alias[effect:remove_character_modifier] = <modifier_container>

### Removes the characters secret_faith
## scope = character
alias[effect:remove_character_secret_faith] = value[character_flag]

### removes an explicit (not from a living parent/grand parent) claim
## scope = character
alias[effect:remove_claim] = scope[landed_title]

### Removes the target character as a concubine of the scope character
## scope = character
alias[effect:remove_concubine] = scope[character]

### Removes the target character (guest or courtier) from the scope character's court scope:host = { remove_courtier_or_guest = scope:guest } # move to pool, staying in same province scope:host = { 	remove_courtier_or_guest = { 		character = scope:guest 		new_location = scope:some_province # optionally specify a new location 	} }
## scope = character
alias[effect:remove_courtier_or_guest] = scope[character]

### Remove the cooldown on taking a decision for the scoped character remove_decision_cooldown = decision_name
## scope = character
alias[effect:remove_decision_cooldown] = <decision>

### remove_from_activity = activity The scoped character is removed from the target activity
## scope = character
alias[effect:remove_from_activity] = scope[activity]

### Removes a hook on a character, remove_hook = { target = X, type = Y }, if type is specified, the hook will only be removed if it is of that type
## scope = character
alias[effect:remove_hook] = {
    target = scope[character]
    ## cardinality = 0..1
    type = <hook_types>
}

### Remove the cooldown on using an interaction for the scoped character remove_interaction_cooldown = interaction_name
## scope = character
alias[effect:remove_interaction_cooldown] = <character_interaction>

### Remove the cooldown on using an interaction against the target character for the scoped character remove_interaction_cooldown_against = { interaction = interaction_name target = character }
## scope = character
alias[effect:remove_interaction_cooldown_against] = {
    interaction = <character_interaction>
    target = scope[character]
}

### Removes a piece of localized text from being stored on the character with a given key, you should do this whenever you are done with the custom text so as to not bloat saves remove_localized_text = key
## scope = character
alias[effect:remove_localized_text] = value[variable]

### removes gold from a character (AI's long term budget)
## scope = character
alias[effect:remove_long_term_gold] = alias_keys_field[int_value]

### Removes any nickname from the current character [yes|no]
## scope = character
alias[effect:remove_nickname] = bool

### Removes a temporary opinion modifier, remove_opinion = { target = X modifier = Y single = Z (no by default) } where X is a character, Y is the opinion modifier, Z tells whether to remove all instances of the modifier or just one
## scope = character
alias[effect:remove_opinion] = {
    modifier = <opinion_modifier>
    target = scope[character]
}

### Remove the perk for this character
## scope = character
alias[effect:remove_perk] = <lifestyle_perk>

### Removes a personal claim on the target artifact from the scoped character
## scope = character
alias[effect:remove_personal_artifact_claim] = scope[artifact]

### Removes the given law from the scoped character. This will leave the law group empty, so only do this if you're getting rid of a law group
## scope = character
alias[effect:remove_realm_law] = <law>

### Removed a flag from an existing relation flag = flag_name (declared in scripted_relation) target = other_character relation = scripted_relation
## scope = character
alias[effect:remove_relation_flag] = single_alias_right[relation_flag_clause]

### Removes scripted relationship.
## scope = character
alias[effect:remove_relation_<scripted_relation>] = scope[character]

### removes gold from a character (AI's long term budget)
## scope = character
alias[effect:remove_reserved_gold] = alias_keys_field[int_value]

### Remove the cooldown on using a scheme against the target character for the scoped character remove_scheme_cooldown_against = { scheme = scheme_name target = character }
## scope = character
alias[effect:remove_scheme_cooldown_against] = {
    scheme = <scheme>
    target = scope[character]
}

### removes gold from a character (AI's short term budget)
## scope = character
alias[effect:remove_short_term_gold] = alias_keys_field[int_value]

### Removes a trait from a character. Tooltip will not been shown if the character doesn't has the trait.
## scope = character
alias[effect:remove_trait] = <trait>

### Removes a trait from a character. Tooltip will not been shown if the character doesn't has the trait.
## scope = character
alias[effect:remove_trait] = scope[trait]

### Removes a trait from a character. Tooltip will be shown even if the character doesn't has the trait.
## scope = character
alias[effect:remove_trait_force_tooltip] = <trait>

### Removes a trait from a character. Tooltip will be shown even if the character doesn't has the trait.
## scope = character
alias[effect:remove_trait_force_tooltip] = scope[trait]

### removes gold from a character (AI's short term budget)
## scope = character
alias[effect:remove_war_chest_gold] = alias_keys_field[int_value]

### Replaces the target character holding target court position within scoped character's court with target character recipient = character scope - target character to receive the title holder = character scope - target character to revoke the target court position of in favour of recipient court_position = court position type - court position type to assign the receiver
## scope = character
alias[effect:replace_court_position] = {
    recipient = scope[character]
    holder = scope[character]
    court_position = <court_position>
}

### The target character stops having a beneficiary. reset_beneficiary = yes
## scope = character
alias[effect:reset_beneficiary] = yes

### Release scoped character from hostage and return to home court
## scope = character
alias[effect:return_hostage] = yes

### Returns the scope character to the employers court.
## scope = character
alias[effect:return_to_court] = yes

### Adds a temporary reverse opinion modifier, reverse_add_opinion = { modifier = X days/months/years = Y target = Z } X is a scripted modifier name. Y can be a value or a range "{ A B }" If no timeout are specified, the modifier's scripted default timeout will be used.
## scope = character
alias[effect:reverse_add_opinion] = {
    target = scope[character]
    modifier = <opinion_modifier>
    ## cardinality = 0..1
    opinion = alias_keys_field[int_value]
}

### Revokes target position from scoped character. court_position = court position type - court position type to revoke from scoped character's court
## scope = character
alias[effect:revoke_court_position] = <court_position>

### court position type - court position type to revoke from scoped character's court recipient = character - optional - target current holder of position to revoke holder = character - optional - same as recipient
## scope = character
alias[effect:revoke_court_position] = {
    court_position = <court_position>
    ## cardinality = 0..1
    recipient = scope[character]
    ## cardinality = 0..1
    holder = scope[character]
}

### Recalculates the modifier of the scoped character
## scope = character
alias[effect:scriptedtests_recalculate_character_modifier] = yes

### Recalculates the line of succession of the scoped character
## scope = character
alias[effect:scriptedtests_recalculate_succession] = yes

## scope = character
alias[effect:send_interface_message] = {
    ## cardinality = 0..1
    ### Default `send_interface_toast`.
    type = <message>
    ## cardinality = 0..1
    title = localisation
    ## cardinality = 0..1
	desc = localisation
    ## cardinality = 0..1
    tooltip = localisation
    ## cardinality = 0..1
    left_icon = scope[character]
    ## cardinality = 0..1
    left_icon = scope[landed_title]
    ## cardinality = 0..1
    right_icon = scope[character]
    ## cardinality = 0..1
    right_icon = scope[landed_title]
    ## cardinality = 0..1
    goto = scope[character]
    ## cardinality = 0..1
    goto = scope[landed_title]

    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

## scope = character
alias[effect:send_interface_popup] = {
    ## cardinality = 0..1
    ### Default `send_interface_toast`.
    type = <message>
    ## cardinality = 0..1
    title = localisation
    ## cardinality = 0..1
	desc = localisation
    ## cardinality = 0..1
    tooltip = localisation
    ## cardinality = 0..1
    left_icon = scope[character]
    ## cardinality = 0..1
    left_icon = scope[landed_title]
    ## cardinality = 0..1
    right_icon = scope[character]
    ## cardinality = 0..1
    right_icon = scope[landed_title]

    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

###
## scope = character
alias[effect:send_interface_toast] = {
    ## cardinality = 0..1
    ### Default `send_interface_toast`.
    type = <message>
    ## cardinality = 0..1
    title = localisation
    ## cardinality = 0..1
	desc = localisation
    ## cardinality = 0..1
    tooltip = localisation
    ## cardinality = 0..1
    left_icon = scope[character]
    ## cardinality = 0..1
    left_icon = scope[landed_title]
    ## cardinality = 0..1
    right_icon = scope[character]
    ## cardinality = 0..1
    right_icon = scope[landed_title]
    ## cardinality = 0..1
    goto = scope[character]
    ## cardinality = 0..1
    goto = scope[landed_title]

    ## cardinality = 0..inf
    alias_name[effect] = alias_match_left[effect]
}

### Sets if this character has absolute country control, unlock_character_movement = yes/no/boolean event target
## scope = character
alias[effect:set_absolute_country_control] = bool

### Sets the character's age. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command  Usage: set_age = script value
## scope = character
alias[effect:set_age] = alias_keys_field[int_value]

### set_amenity_level = { type = food value = 2 } Sets the amenity type to the given value for the scoped character
## scope = character
alias[effect:set_amenity_level] = {
    type = <court_amenity_category>
    value = int
}

### The target character becomes the beneficiary of the scoped character. set_beneficiary = some character
## scope = character
alias[effect:set_beneficiary] = scope[character]

### Changes what faith a character has executing the effects for it
## scope = character
alias[effect:set_character_faith] = scope[faith]

### Changes what faith a character has NOT executing the effects for it. USE ONLY IN HISOTRY SETUP!
## scope = character
alias[effect:set_character_faith_history] = scope[faith]

### Changes what faith a character has, as if they used the faith-view interaction (minus the piety cost). So vassals who'd accept will get converted, as will capitals
## scope = character
alias[effect:set_character_faith_with_conversion] = scope[faith]

### Changes what faith a character has, as if they used the faith-view interaction (minus the piety cost). So vassals who'd accept will get converted, as will capitals
## scope = character
alias[effect:set_character_secret_faith] = scope[faith]

### Sets the child to be (or not be) a child of a concubine during pregnancy
## scope = character
alias[effect:set_child_of_concubine_on_pregnancy] = yes # TODO: Probably. Not used.

### Sets the task of the scope councillor { type = council_position_type_key target = for_targeted_tasks  }
## scope = character
alias[effect:set_council_task] = {
    type = <council_task>
    target = scalar # TODO: Verify. Probably depends on the type of the council task [court/county/general]
}

### Set the character's court language to the given languageset_court_language = language_norwegian
## scope = character
alias[effect:set_court_language] = <culture.language>

### Set the court type for this character's royal court
## scope = character
alias[effect:set_court_type] = <court_type>

### Set the culture for this character
## scope = character
alias[effect:set_culture] = scope[culture]

### sets the culture of the character to be the same as the culture of the target
## scope = character
alias[effect:set_culture_same_as] = scope[character]

### Sets the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.
## scope = character
alias[effect:set_current_court_grandeur] = alias_keys_field[int_value]

### set_dead_character_variable = {	name = <name> - name of the variable	value = <value> - any event target, bool, value, script value or flag	years/weeks/days = { <min_number> <max_number> } - years/weeks/days this flag is supposed to last} Adds a variable to a dead character. A duration is required.
## scope = character
alias[effect:set_dead_character_variable] = {
    name = value_set[variable]
    value = value_field
    enum[duration] = { int int }
}

### sets the death reason and the killer of a dead character, set_death_reason = { killer = X death_reason = Y }, both parameters are optional
## scope = character
alias[effect:set_death_reason] = {
    ## cardinality = 0..1
    killer = scope[character]
    ## cardinality = 0..1
    death_reason = <death_reason>
}

### Set the default education focus for this character
## scope = character
alias[effect:set_default_education] = yes

### Sets the given character as designated heir
## scope = character
alias[effect:set_designated_heir] = scope[character]

### Set target character as new diarch. Requires an active diarchy set_diarch = scope:new_diarch
## scope = character
alias[effect:set_diarch] = scope[character]

### Set mandate for the diarch. Takes mandate type as argument scope:diarch = { set_diarchy_mandate = live_long_and_prosper }
## scope = character
alias[effect:set_diarchy_mandate] = <mandate>

### Set scales of power swing for the active diarchy set_diarchy_swing = 55
## scope = character
alias[effect:set_diarchy_swing] = alias_keys_field[int_value]

### Set diarthy type for the character. Takes diarchy type as argument
## scope = character
alias[effect:set_diarchy_type] = <diarchy>

### Add the scope character to the target character's court
## scope = character
alias[effect:set_employer] = scope[character]

### Set the ethnicity for this character, if it is of a different portrait group and they have DNA it will be randomized
## scope = character
alias[effect:set_ethnicity] = <ethnicity>

### sets the father of a character
## scope = character
alias[effect:set_father] = scope[character]

### Set the focus for this character
## scope = character
alias[effect:set_focus] = <focus>

### Set the focus for this character
## scope = character
alias[effect:set_focus] = no

### Sets the dynasty house of the character
## scope = character
alias[effect:set_house] = scope[dynasty_house]

### Changes what age the character became immortal at. Only works if already immortal set_immortal_age = 20
## scope = character
alias[effect:set_immortal_age] = alias_keys_field[int_value]

### Sets the scoped character's killer as being publicly known set_killer_public = bool
## scope = character
alias[effect:set_killer_public] = bool

enums = {
    enum[knight_status] = {
        forced
        default
        disallowed
    }
}

### Sets the knight status of the character to Forced/Default/Disallowed
## scope = character
alias[effect:set_knight_status] = enum[knight_status]

### Sets the child to a known or unknown bastard during pregnancy
## scope = character
alias[effect:set_known_bastard_on_pregnancy] = yes

### Moves the character to a specific location. stick_to_location can be used to prevent the safety checks that sometimes return characters to their default location automatically.Usage:   set_location = province set_location = { location = province   stick_to_location = yes/no }
## scope = character
alias[effect:set_location] = {
    location = scope[province]
    stick_to_location = bool
}

### Moves the character to a specific location. stick_to_location can be used to prevent the safety checks that sometimes return characters to their default location automatically.Usage:   set_location = province set_location = { location = province   stick_to_location = yes/no }
## scope = character
alias[effect:set_location] = scope[province]

### Moves the character to its "default" location.This is usually the realm capital for landed characters, or court location for courtiers.   Usage: set_location_to_default = yes/no
## scope = character
alias[effect:set_location_to_default] = bool

### Sets the mother of a character
## scope = character
alias[effect:set_mother] = scope[character]

### Set the number of children
## scope = character
alias[effect:set_num_pregnancy_children] = int

### The scoped character will put their beneficiary on the throne if they're the #1 participant if this is called with 'yes'. Call with 'no' to turn it off again. set_override_designate_winner = yes/no
## scope = character
alias[effect:set_override_designated_winner] = bool

### Sets the owner of the target legend to the scoped character.set_owned_legend = legend
## scope = character
alias[effect:set_owned_legend] = scope[legend]

### The scope character's player will now play as the target character. Scope must be player-controlled. Target cannot be player-controlled. Example: make_unprunable = yes
## scope = character
alias[effect:set_player_character] = scope[character]

### Set the assumed father of the pregnancy
## scope = character
alias[effect:set_pregnancy_assumed_father] = scope[character]

### Set the primary spouse of a character set_primary_spouse = scope
## scope = character
alias[effect:set_primary_spouse] = scope[character]

### Sets the primary title for a character set_primary_title_to = <title>
## scope = character
alias[effect:set_primary_title_to] = scope[landed_title] # TODO: Doesn't seem to work with `title:something`.

### Adds the scoped character as a promoter of the target legend. set_promoted_legend = legend
## scope = character
alias[effect:set_promoted_legend] = scope[legend]

### Changes the real father of the character scope
## scope = character
alias[effect:set_real_father] = scope[character]

### Changes the real mother of the scoped character 
## scope = character
alias[effect:set_real_mother] = scope[character]

### Set a new realm capital character = { set_realm_capital = new_title }
## scope = character
alias[effect:set_realm_capital] = scope[landed_title]

##### Custom effects (dynamic ones) ######
### Sets scripted relationship.
## scope = character
alias[effect:set_relation_<scripted_relation>] = scope[character]

### Set the maximum (and also desired value) for the 'reserved' gold AI budget. This budget is saved up, even before the war chest budget. It will not correct the current gold in that budget to conform to the new maximum.character, set_reserved_gold_maximum = X
## scope = character
alias[effect:set_reserved_gold_maximum] = alias_keys_field[int_value]

### Sets the sexuality of the character
## scope = character
alias[effect:set_sexuality] = <game_concept.sexuality>

### Set the character to lowborn
## scope = character
alias[effect:set_to_lowborn] = yes

### Sets the trait rank = { trait = trait_group rank = new rank }
## scope = character
alias[effect:set_trait_rank] = {
    trait = value[trait_group]
    rank = int
}

### Blocks the vassal contract from being modified with regards to being checked by 'vassal_contract_is_blocked_from_modification'
## scope = character
alias[effect:set_vassal_contract_modification_blocked] = <vassal_obligation_level>

### Spawns an army for this character Usage: spawn_army = { levies = int/script value # optional, number of men men_at_arms = { # optional, multiple can be specified. Need either levies or MAA type = key men/stacks = int/script value } location = province origin = province # optional, location used if not set. This is used for where to base bonuses and the like on war = war # optional. If set, the stack will disband after the war ends inheritable = yes/no # Default: yes uses_supply = yes/no # Default: yes army = army # optional. If set, the stack will merge into this army save_scope_as/save_temporary_scope_as = new_army # optional way to get a reference to the new army. Note this might not be set if the army wasn't spawned (e.g. if the character is not at war) name = description # gives the troops a specific name that shows up in interfaces }
## scope = character
alias[effect:spawn_army] = {
    name = localisation

    ## cardinality = 0..1
    levies = alias_keys_field[int_value]
    ## cardinality = 0..1
    levies = single_alias_right[score_arithmetic]
    ## cardinality = 0..inf
    men_at_arms = {
        type = <maa_type>
        ## cardinality = 0..1
        stacks = alias_keys_field[int_value]
        ## cardinality = 0..1
        stacks = single_alias_right[score_arithmetic]
    }
    ## cardinality = 0..1
    location = <province>
    ## cardinality = 0..1
    location = scope[province]
    ## cardinality = 0..1
    origin = <province>
    ## cardinality = 0..1
    origin = scope[province]
    ## cardinality = 0..1
    war = scope[war]
    ## cardinality = 0..1
    inheritable = bool
    ## cardinality = 0..1
    uses_supply = bool
    ## cardinality = 0..1
    army = scope[army]

    ## cardinality = 0..1
    ### Cannot be set if army cannot be spawned (eg. char not at war).
    save_scope_as = value_set[event_target]
    ## cardinality = 0..1
    ### Cannot be set if army cannot be spawned (eg. char not at war).
    save_temporary_scope_as = value_set[temporary_scope]
}

### sponsor_inspiration = inspiration Sets the sponsor of the target inspiration to the scoped character
## scope = character
alias[effect:sponsor_inspiration] = scope[inspiration]

### Force the Councillor to revert to the default task. Any relevant percentage progress will be lost (even if the councillor was performing the default task already).
## scope = character
alias[effect:start_default_task] = yes

### Start diarchy for the character. Takes diarchy type as argument start_diarchy = regency
## scope = character
alias[effect:start_diarchy] = <diarchy>

### starts a scheme  = { type = X target = Y }
## scope = character
alias[effect:start_scheme] = {
    type = <scheme>
    ## cardinality = 0..1
    contract = <contract>
    ## cardinality = 0..1
    target_character = scope[character]
    ## cardinality = 0..1
    target_title = scope[landed_title]
    ## cardinality = 0..1
    target_culture = scope[culture]
    ## cardinality = 0..1
    target_faith = scope[faith]
    ## cardinality = 0..1
    targets_nothing = bool
}

enums = {
    enum[on_arrival_destinations] = {
        all
        first
        last
        all_but_last
    }
}

### Start a travel plan. Saving this as a scope will not work for player characters if they have to use the planner. start_travel_plan = {     destination = PROVINCE (repeatable)    travel_leader = CHARACTER (optional)    companion = CHARACTER (optional & repeatable) travel_with_domicile = YES/NO (default no)    players_use_planner = YES/NO (default yes)    return_trip = YES/NO (default yes, adds a destination at the end of the travel plan to return to the starting location)    on_arrival_event = EVENT (triggered on non-home destinations determined by on_arrival_destinations. Root is travel plan owner.)    on_arrival_on_action = ON_ACTION (triggered on non-home destinations determined by on_arrival_destinations. Root is travel plan owner.)    on_start_event = EVENT (triggered when the travel starts. Root is travel plan owner.)    on_start_on_action = ON_ACTION (triggered when the travel starts. Root is travel plan owner.)    on_travel_planner_cancel_event = EVENT (triggered if a player exits the travel planner instead of starting a travel. Root is travel plan owner.)    on_travel_planner_cancel_on_action = ON_ACTION (triggered if a player exits the travel planner instead of starting a travel. Root is travel plan owner.)    on_arrival_destinations = all/first/last/all_but_last (which destinations the on_arrival should trigger on, defaults to all_but_last) }
## scope = character
alias[effect:start_travel_plan] = {
    destination = scope[province]
    travel_leader = scope[character]
    companion = scope[character]
    ##cardinality = 0..1
    travel_with_domicile = bool
    players_use_planner = bool
    return_trip = bool
    on_arrival_event = <event>
    on_arrival_on_action = <on_action>
    on_start_event = <event>
    on_start_on_action = <on_action>
    on_travel_planner_cancel_event = <event>
    on_travel_planner_on_action = <on_action>
    on_arrival_destinations = enum[on_arrival_destinations]

}

### starts a war  = { casus_belli/cb = X target = Y claimant = Z target_title = W1 target_title = W2 ... } where X is a casus belli type, Y is the target character, Z i the (optional) claimant, W1, W2.... are targeted titles. If there are no title targets, the effect will pick one of possible title targets.
## scope = character
alias[effect:start_war] = {
    enum[cb] = <casus_belli_type>
    target = scope[character]
    ## cardinality = 0..1
    claimant = scope[character]
    ## cardinality = 0..inf
    target_title = scope[landed_title]
}

### Remove the scoped character as the owner/promoter of their current promoted legend if they have one. stop_promoting_legend = yes
## scope = character
alias[effect:stop_promoting_legend] = bool

# TODO - check
### Makes a piece of localized text with the given key be stored on the character even after death, you should use this sparingly to avoid save bloat and use 'remove_localized_text' if you no longer need itsaves. store_localized_text_in_death = key
## scope = character
alias[effect:store_localized_text_in_death] = scalar

### Stress impact according to specified traits (trait = value), use base = value for a base value that's always added
## scope = character
alias[effect:stress_impact] = {
    ## cardinality = 0..1
    base = alias_keys_field[int_value]
    ## cardinality = 0..inf
    <trait> = alias_keys_field[int_value]
}

### Take target character as a hostagescope:warden = { take_hostage = scope:hostage }
## scope = character
alias[effect:take_hostage] = scope[character]

### The character unlearns the court language of the target character. Cannot unlearn the language of your cultureunlearn_court_language_of = scope:target_character
## scope = character
alias[effect:unlearn_court_language_of] = scope[character]

### The character unlearns the language. Cannot unlearn the language of your cultureunlearn_language = language_norwegian
## scope = character
alias[effect:unlearn_language] = <culture.language>

### The character unlearns the language of the target culture. Cannot unlearn the language of your cultureunlearn_language_of_culture = scope:target_culture
## scope = character
alias[effect:unlearn_language_of_culture] = scope[culture]

### Uses a hook a character has (removes if weak, puts on cooldown if strong), use_hook = some_character
## scope = character
alias[effect:use_hook] = scope[character]

### decrease the obligation level of the scoped character's vassal contract
## scope = character
alias[effect:vassal_contract_decrease_obligation_level] = replace_me # TODO: Define vassal contracts.

### increase the obligation level of the scoped character's vassal contract
## scope = character
alias[effect:vassal_contract_increase_obligation_level] = replace_me # TODO: Define obligations.

### change the obligation level of the scoped character's vassal contract vassal_contract_set_obligation_level = 1 # index to obligation level vassal_contract_set_obligation_level = feudal_obligation_low
## scope = character
alias[effect:vassal_contract_set_obligation_level] = replace_me # TODO: Implemented type for vassal contracts.

### Add the scope character as the target character's guest
## scope = character
alias[effect:visit_court_of] = scope[character]

###################################
# REGIMENT SCOPE
###################################

###Change size of MaA regiment by the specified value. Extra troops are deleted, by default new troops will have to reinforce, unless reinforce = yes is used
## scope = regiment
alias[effect:change_maa_regiment_size] = {
    size = int_value_field
    ## cardinality = 0..1
    reinforce = yes
}

###Change size of MaA regiment by the specified value. Extra troops are deleted, by default new troops will have to reinforce, unless reinforce = yes is used
## scope = regiment
alias[effect:change_maa_regiment_size] = int_value_field


###Change current troops count of MaA regiment. It can't exceed max troops count
## scope = regiment
alias[effect:change_maa_troops_count] = alias_keys_field[int_value]

### Destroy MaA regiment. Doesn't work on regiments that belong to mercenary companies and holy orders
## scope = regiment
alias[effect:destroy_maa_regiment] = yes

### Transfet title MaA regiment to another title
## scope = regiment
alias[effect:transfer_title_maa] = scope[landed_title]

###################################
# LANDED_TITLE SCOPE
###################################

### Add a modifier to a county add_county_modifier = name add_county_modifier = { modifier = name days/weeks/months/years = int }
## scope = landed_title
alias[effect:add_county_modifier] = single_alias_right[added_modifier]

###  Increase appointment score of a character for a title change_appointment_investment = {	target = scope:target_character	investor = scope:investor_character # Optional, the character who made this investment	value = <script_value>}
## scope = landed_title
alias[effect:change_appointment_investment] = {
    target = scope[character]
    ## cardinality = 0..1
    investor = scope[character]
    value = alias_keys_field[int_value]
}

### Changes the county control of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.
## scope = landed_title
alias[effect:change_county_control] = alias_keys_field[int_value]

### Change the progress of de jure drift of a title<drifting_title> = { change_de_jure_drift_progress = {    target = <drift_target_title>    values = <progress_change_value> } }
## scope = landed_title
alias[effect:change_de_jure_drift_progress] = {
    target = scope[landed_title]
    value = alias_keys_field[int_value]
}

### Changes the development level of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.
## scope = landed_title
alias[effect:change_development_level] = alias_keys_field[int_value]

### Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.
## scope = landed_title
alias[effect:change_development_progress] = alias_keys_field[int_value]

### Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it. Will overflow, so adding +100 to a county with 50 progress left will increase the level by 1 and result in 50 progress towards the next level
## scope = landed_title
alias[effect:change_development_progress_with_overflow] = alias_keys_field[int_value]

### remove all title laws from the scoped title clear_title_laws = yes
## scope = landed_title
alias[effect:clear_title_laws] = yes

### remove all title laws from the scoped title. DOES apply law removal costs and effects. clear_title_laws_effects = yes
## scope = landed_title
alias[effect:clear_title_laws_effects] = yes

### Copy title history from another title copy_title_history = source_title
## scope = landed_title
alias[effect:copy_title_history] = scope[landed_title]

### Lease out the scoped title lease_out_to = scope:a_holy_order
## scope = landed_title
alias[effect:lease_out_to] = scope[holy_order]



### Remove all instances of a modifier from a county remove_all_county_modifier_instances = name
## scope = landed_title
alias[effect:remove_all_county_modifier_instances] = <modifier_container>

### Remove a modifier from a county remove_county_modifier = name
## scope = landed_title
alias[effect:remove_county_modifier] = <modifier_container>

### Scoped county is no longer important for anyone
## scope = landed_title
alias[effect:remove_important_location] = yes

### Scoped county is no longer important for the target title
## scope = landed_title
alias[effect:remove_title_from_important_location] = scope[landed_title]

### Sets the name and adjective of the scoped title back to being based on its key. Won't cause the prefix to change reset_title_name = yes
## scope = landed_title
alias[effect:reset_title_name] = yes

### Sets the prefix of the scoped title back to being based on its key. Won't cause its adjective or name to change reset_title_prefix = yes
## scope = landed_title
alias[effect:reset_title_prefix] = yes

### Revoke the lease of the scoped title revoke_lease = yes
## scope = landed_title
alias[effect:revoke_lease] = yes

### Sets if the title should always go to the primary heir in partition succession set_always_follows_primary_heir = yes
## scope = landed_title
alias[effect:set_always_follows_primary_heir] = yes

### Sets if the title can be named after it's holder's dynasty. set_can_be_named_after_dynasty_effect = no
## scope = landed_title
alias[effect:set_can_be_named_after_dynasty] = bool

### Sets scoped barony to be the county capital set_capital_barony = yes
## scope = landed_title
alias[effect:set_capital_barony] = scope[landed_title] # Probably no way to restrict to county title?

### Sets the capital county of the title to the target county set_capital_county = <some county title>
## scope = landed_title
alias[effect:set_capital_county] = scope[landed_title] # Probably no way to restrict to county title?

### Sets the color of the title to the same as the target title (shifted very slightly to not be identical) set_color_from_title = <some title>
## scope = landed_title
alias[effect:set_color_from_title] = scope[landed_title]

### sets the culture of a county usage: set_county_culture = english/root.character_culture
## scope = landed_title
alias[effect:set_county_culture] = scope[culture]

### Changes what faith a county has
## scope = landed_title
alias[effect:set_county_faith] = scope[faith]

### Set a new DeJure liege title set_de_jure_liege_title = new_de_jure_liege
## scope = landed_title
alias[effect:set_de_jure_liege_title] = scope[landed_title]

### Sets if the title should use a definitive form name (no 'Kingdom of') set_definitive_form = yes
## scope = landed_title
alias[effect:set_definitive_form] = yes

### Sets if the title should be deleted from the gamestate completely when it is destroyed. set_delete_on_destroy = yes
## scope = landed_title
alias[effect:set_delete_on_destroy] = yes

### Sets if the title should be destroyed on succession if there's no heir matching its restrictions. set_destroy_if_invalid_heir = yes
## scope = landed_title
alias[effect:set_destroy_if_invalid_heir] = yes

### Sets if the title should be destroyed on succession. set_destroy_on_succession = yes
## scope = landed_title
alias[effect:set_destroy_on_succession] = yes

### Scoped county is set as important for the target title scope:county = 	set_important_location = {		title = scope:higher_tier_title		enter_realm_event = event_name		enter_realm_on_action = onaction_name		leave_realm_event = event_name		leave_realm_on_action = onaction_name	}} Events and onactions are fired with this scope:root - title top liege scope:county - important location scope:title - higher tier title that is interested in the county In enter realm: scope:changed_top_liege - former top liege of the important location In leave realm: scope:changed_top_liege - new top liege of the important location
## scope = landed_title
alias[effect:set_important_location] = {
    title = scope[landed_title]
    ## replace_scope = { root = landed_title county = province title = landed_title changed_top_liege = character }
    ## cardinality = 0..1
    enter_realm_event = <scripted_effect>
    ## replace_scope = { root = landed_title county = province title = landed_title changed_top_liege = character }
    ## cardinality = 0..1
    enter_realm_on_action = <on_action>
    ## replace_scope = { root = landed_title county = province title = landed_title changed_top_liege = character }
    ## cardinality = 0..1
    leave_realm_event = <scripted_effect>
    ## replace_scope = { root = landed_title county = province title = landed_title changed_top_liege = character }
    ## cardinality = 0..1
    leave_realm_on_action = <on_action>
}

### Sets if the title is landless (can be held by rulers with no land) set_landless_title = yes
## scope = landed_title
alias[effect:set_landless_title] = yes

### Sets if the title should disallow automatic claims (meaning claims will only be added by script, and by pressed claims being inherited). set_no_automatic_claims = yes
## scope = landed_title
alias[effect:set_no_automatic_claims] = yes

### Change if the scoped title is for a noble family, allowing landless playable. Title must be at least a duchy set_no_automatic_claims = yes
## scope = landed_title
alias[effect:set_noble_family_title] = <dynasty_house>

### Set the State Faith of a Title whose holder has the state_faith government rule
## scope = landed_title
alias[effect:set_state_faith] = scope[faith]

### sets the name (localization key) of the scoped title. The adjective will be constructed by adding '_adj' to the localisation key. Won't cause the prefix to change set_title_name = TEST_NAME_PLEASE_IGNORE
## scope = landed_title
alias[effect:set_title_name] = localisation

### sets the prefix of the scoped title. Won't cause its name or adjective to change set_title_prefix = PREFIX_THE
## scope = landed_title
alias[effect:set_title_prefix] = localisation

### the scoped landed title creates a faction of the specified type against the specified target, title_create_faction = { type = X target = Y }
## scope = landed_title
alias[effect:title_create_faction] = {
    type = <faction>
    target = scope[character]
}

### the landed title in the scope joins the assigned faction
## scope = landed_title
alias[effect:title_join_faction] = replace_me # TODO: Define factions.

### the title in the scope leaves the assigned faction
## scope = landed_title
alias[effect:title_leave_faction] = scope[faction]

### Transfers control of the scoped title's owned MaA to the target title
## scope = landed_title
alias[effect:transfer_owned_maa_control] = scope[landed_title]

### update_dynamic_coa = yes Updates the dynamic coat of arms definition of a given title picking a new one and overwriting the existing set coat of arms with it if picked
## scope = landed_title
alias[effect:update_dynamic_coa] = bool

###################################
# FACTION SCOPE
###################################

### add_faction_discontent = X adds (or subtracts) discontent to the scope faction
## scope = faction
alias[effect:add_faction_discontent] = alias_keys_field[int_value]

### the scope faction is destoryed [yes|no]
## scope = faction
alias[effect:destroy_faction] = bool

### Removes the war currently associated with the faction faction_remove_war = yes
## scope = faction
alias[effect:faction_remove_war] = yes

### The scope faction starts the war agains their target. faction_start_war = {     title = [optional] }
## scope = faction
alias[effect:faction_start_war] = {
    ## cardinality = 0..1
    title = localisation
}

### Removes the special character for the scope faction
## scope = faction
alias[effect:remove_special_character] = scope[character] # TODO: Not used in vanilla.

### Removes the special character for the scope faction
## scope = faction
alias[effect:remove_special_title] = scope[landed_title] # TODO: Never used in vanilla.

### Sets the special character for the scope faction
## scope = faction
alias[effect:set_special_character] = scope[character]

### Sets the special title for the scope faction
## scope = faction
alias[effect:set_special_title] = scope[landed_title]

###################################
# COMBAT_SIDE SCOPE
###################################

### Makes a battle event show up in combat, and the combat result summary. The key is used for loc, with '_friendly' or '_enemy' appended. If this side is not the player's side, the two portraits get flipped. battle_event = { left_portrait = someone right_portrait = someone key = string }
## scope = combat_side
alias[effect:battle_event] = {
    key = localisation
    left_portrait = scope[character]
    ## cardinality = 0..1
    right_portrait = scope[character]
    ## cardinality = 0..1
    target_right = yes
    type = enum[battle_event_type]
}

###################################
# INSPIRATION SCOPE
###################################

### Changes the progress of the scoped inspiration
## scope = inspiration
alias[effect:change_inspiration_progress] = int_value_field

### Invests gold into the scoped inspiration from its sponsor, it handles the removal of the gold from the sponsor, must be a positive value
## scope = inspiration
alias[effect:invest_gold] = alias_keys_field[int_value]

### Sets the special title for the scope faction
## scope = inspiration
alias[effect:set_special_title] = scope[landed_title]

###################################
# DOMICILE SCOPE
###################################

### Add building to scoped domicile, ignores cost and construction time
## scope = domicile
# TODO Domicile buildings
alias[effect:add_domicile_building] = scalar

### Adds (or removes) provisions to a scoped domicile
## scope = domicile
alias[effect:change_provisions] = alias_keys_field[int_value]

### Construct building to scoped domicile, ignores cost but uses construction time
## scope = domicile
alias[effect:construct_domicile_building] = scalar

### Moves domicile to target location
## scope = domicile
alias[effect:move_domicile] = scope[province]

### Remove building from scoped domicile
## scope = domicile
alias[effect:remove_domicile_building] = scalar

### Changes domicile owner to target character
## scope = domicile
alias[effect:set_domicile_owner] = scope[character]

### scheme_freeze = { reason = LOC_KEY days/months/years = X } freezes the scheme for duration X. 0 duration for indefinite freeze, until scheme_unfreeze is called.
## scope = scheme
alias[effect:scheme_freeze] = {
    ## cardinality = 0..1
    reason = localisation
    enum[duration] = int
}



# -UNSORTED

# accept a characters invitation to the activity
#alias[effect:accept_invitation_for_character] = scope[character]

# Recalculates the effect of a scripted relation recalculate_scripted_relation= friend
#alias[effect:recalculate_scripted_relation] = <scripted_relation>

# ends the combat as the losing side (doesn't end the combat if evaluated to false)
#alias[effect:lose_combat] = replace_me # Never used in vanilla files.

# Recruits the target to become a courtier. Example scope:liege = { recruit_courtier = scope:new_courtier }
#alias[effect:recruit_courtier] = scope[character]

# ends the combat as the winning side (doesn't end the combat if evaluated to false)
#alias[effect:win_combat] = replace_me # Never used in vanilla files.

# spawns an activity, spawn_activity = { owner = X type = Y days/months/years = Z }, Z is expiration time can be a value or an inclusive "{A B}" interval from which the value will be picked
#alias[effect:spawn_activity] = replace_me # TODO

# invite a character to the activity
#alias[effect:invite_character_to_activity] = scope[character]

# completes the activity, complete_activity = yes ends the activity and runs the on_complete effect, complete_activity = no ends the activity without running the effect
#alias[effect:complete_activity] = bool

# Add building slot to the province
#alias[effect:add_building_slot] = int






