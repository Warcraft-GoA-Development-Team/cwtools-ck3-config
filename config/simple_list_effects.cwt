# Autogenerated file, do not edit manually
### Iterate through all dynasty members
### every_dynasty_member = { limit = { <triggers> } <effects> }
## scope = dynasty
## push_scope = character
alias[effect:every_dynasty_member] = single_alias_right[every_effect]

### Iterate through all dynasty members
### ordered_dynasty_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = dynasty
## push_scope = character
alias[effect:ordered_dynasty_member] = single_alias_right[ordered_effect]

### Iterate through all dynasty members
### random_dynasty_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = dynasty
## push_scope = character
alias[effect:random_dynasty_member] = single_alias_right[random_effect]

### Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.
### every_invited_character = { limit = { <triggers> } <effects> }
## scope = activity
## push_scope = character
alias[effect:every_invited_character] = single_alias_right[every_effect]

### Iterate through all special guests of an activity.
### any_special_guest = { ... }
### every_special_guest = { limit = { <triggers> } <effects> }
## scope = activity
## push_scope = character
alias[effect:every_special_guest] = single_alias_right[every_effect]

### Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.
### ordered_invited_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = activity
## push_scope = character
alias[effect:ordered_invited_character] = single_alias_right[ordered_effect]

### Iterate through all special guests of an activity.
### any_special_guest = { ... }
### ordered_special_guest = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = activity
## push_scope = character
alias[effect:ordered_special_guest] = single_alias_right[ordered_effect]

### Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.
### random_invited_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = activity
## push_scope = character
alias[effect:random_invited_character] = single_alias_right[random_effect]

### Iterate through all special guests of an activity.
### any_special_guest = { ... }
### random_special_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = activity
## push_scope = character
alias[effect:random_special_guest] = single_alias_right[random_effect]

### Iterate through all counties of the culture
### every_culture_county = { limit = { <triggers> } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:every_culture_county] = single_alias_right[every_effect]

### Iterate through all duchies of the culture (duchies with at least one county of the culture
### every_culture_duchy = { limit = { <triggers> } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:every_culture_duchy] = single_alias_right[every_effect]

### Iterate through all empires of the culture (empires with at least one county of the culture
### every_culture_empire = { limit = { <triggers> } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:every_culture_empire] = single_alias_right[every_effect]

### Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture
### every_culture_kingdom = { limit = { <triggers> } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:every_culture_kingdom] = single_alias_right[every_effect]

### Iterate through all parent cultures
### every_parent_culture = { limit = { <triggers> } <effects> }
## scope = culture
## push_scope = culture
alias[effect:every_parent_culture] = single_alias_right[every_effect]

### Iterate through all parent cultures or above
### every_parent_culture_or_above = { limit = { <triggers> } <effects> }
## scope = culture
## push_scope = culture
alias[effect:every_parent_culture_or_above] = single_alias_right[every_effect]

### Iterate through all traditions of the given culture
### every_tradition = { limit = { <triggers> } <effects> }
## scope = culture
## push_scope = culture_tradition
alias[effect:every_tradition] = single_alias_right[every_effect]

### Iterate through all counties of the culture
### ordered_culture_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:ordered_culture_county] = single_alias_right[ordered_effect]

### Iterate through all duchies of the culture (duchies with at least one county of the culture
### ordered_culture_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:ordered_culture_duchy] = single_alias_right[ordered_effect]

### Iterate through all empires of the culture (empires with at least one county of the culture
### ordered_culture_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:ordered_culture_empire] = single_alias_right[ordered_effect]

### Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture
### ordered_culture_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:ordered_culture_kingdom] = single_alias_right[ordered_effect]

### Iterate through all parent cultures
### ordered_parent_culture = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = culture
## push_scope = culture
alias[effect:ordered_parent_culture] = single_alias_right[ordered_effect]

### Iterate through all parent cultures or above
### ordered_parent_culture_or_above = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = culture
## push_scope = culture
alias[effect:ordered_parent_culture_or_above] = single_alias_right[ordered_effect]

### Iterate through all traditions of the given culture
### ordered_tradition = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = culture
## push_scope = culture_tradition
alias[effect:ordered_tradition] = single_alias_right[ordered_effect]

### Iterate through all counties of the culture
### random_culture_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:random_culture_county] = single_alias_right[random_effect]

### Iterate through all duchies of the culture (duchies with at least one county of the culture
### random_culture_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:random_culture_duchy] = single_alias_right[random_effect]

### Iterate through all empires of the culture (empires with at least one county of the culture
### random_culture_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:random_culture_empire] = single_alias_right[random_effect]

### Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture
### random_culture_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = culture
## push_scope = landed_title
alias[effect:random_culture_kingdom] = single_alias_right[random_effect]

### Iterate through all parent cultures
### random_parent_culture = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = culture
## push_scope = culture
alias[effect:random_parent_culture] = single_alias_right[random_effect]

### Iterate through all parent cultures or above
### random_parent_culture_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = culture
## push_scope = culture
alias[effect:random_parent_culture_or_above] = single_alias_right[random_effect]

### Iterate through all traditions of the given culture
### random_tradition = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = culture
## push_scope = culture_tradition
alias[effect:random_tradition] = single_alias_right[random_effect]

### Iterate through all participating character of a memory
### every_memory_participant = { limit = { <triggers> } <effects> }
## scope = character_memory
## push_scope = character
alias[effect:every_memory_participant] = single_alias_right[every_effect]

### Iterate through all participating character of a memory
### ordered_memory_participant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character_memory
## push_scope = character
alias[effect:ordered_memory_participant] = single_alias_right[ordered_effect]

### Iterate through all participating character of a memory
### random_memory_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character_memory
## push_scope = character
alias[effect:random_memory_participant] = single_alias_right[random_effect]

### Iterates through all members of the scoped confederation
### every_confederation_member = { limit = { <triggers> } <effects> }
## scope = confederation
## push_scope = character
alias[effect:every_confederation_member] = single_alias_right[every_effect]

### Iterates through all members of the scoped confederation
### ordered_confederation_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = confederation
## push_scope = character
alias[effect:ordered_confederation_member] = single_alias_right[ordered_effect]

### Iterates through all members of the scoped confederation
### random_confederation_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = confederation
## push_scope = character
alias[effect:random_confederation_member] = single_alias_right[random_effect]

### Iterate through all opposite traits of the scoped trait
### every_opposite_trait = { limit = { <triggers> } <effects> }
## scope = trait
## push_scope = trait
alias[effect:every_opposite_trait] = single_alias_right[every_effect]

### Iterate through all opposite traits of the scoped trait
### ordered_opposite_trait = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = trait
## push_scope = trait
alias[effect:ordered_opposite_trait] = single_alias_right[ordered_effect]

### Iterate through all opposite traits of the scoped trait
### random_opposite_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = trait
## push_scope = trait
alias[effect:random_opposite_trait] = single_alias_right[random_effect]

### Iterate through all claimed artifacts of the scoped house
### every_house_claimed_artifact = { limit = { <triggers> } <effects> }
## scope = dynasty_house
## push_scope = artifact
alias[effect:every_house_claimed_artifact] = single_alias_right[every_effect]

### Iterate through all house members
### every_house_member = { limit = { <triggers> } <effects> }
## scope = dynasty_house
## push_scope = character
alias[effect:every_house_member] = single_alias_right[every_effect]

### Iterate through all valid house unity members
### every_house_unity_member = { limit = { <triggers> } <effects> }
## scope = dynasty_house
## push_scope = character
alias[effect:every_house_unity_member] = single_alias_right[every_effect]

### Iterate through all claimed artifacts of the scoped house
### ordered_house_claimed_artifact = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = dynasty_house
## push_scope = artifact
alias[effect:ordered_house_claimed_artifact] = single_alias_right[ordered_effect]

### Iterate through all house members
### ordered_house_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = dynasty_house
## push_scope = character
alias[effect:ordered_house_member] = single_alias_right[ordered_effect]

### Iterate through all valid house unity members
### ordered_house_unity_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = dynasty_house
## push_scope = character
alias[effect:ordered_house_unity_member] = single_alias_right[ordered_effect]

### Iterate through all claimed artifacts of the scoped house
### random_house_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = dynasty_house
## push_scope = artifact
alias[effect:random_house_claimed_artifact] = single_alias_right[random_effect]

### Iterate through all house members
### random_house_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = dynasty_house
## push_scope = character
alias[effect:random_house_member] = single_alias_right[random_effect]

### Iterate through all valid house unity members
### random_house_unity_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = dynasty_house
## push_scope = character
alias[effect:random_house_unity_member] = single_alias_right[random_effect]

### Iterate through all characters who know the secret
### every_secret_knower = { limit = { <triggers> } <effects> }
## scope = secret
## push_scope = character
alias[effect:every_secret_knower] = single_alias_right[every_effect]

### Iterate through participants in a secret
### every_secret_participant = { limit = { <triggers> } <effects> }
## scope = secret
## push_scope = character
alias[effect:every_secret_participant] = single_alias_right[every_effect]

### Iterate through all characters who know the secret
### ordered_secret_knower = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = secret
## push_scope = character
alias[effect:ordered_secret_knower] = single_alias_right[ordered_effect]

### Iterate through participants in a secret
### ordered_secret_participant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = secret
## push_scope = character
alias[effect:ordered_secret_participant] = single_alias_right[ordered_effect]

### Iterate through all characters who know the secret
### random_secret_knower = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = secret
## push_scope = character
alias[effect:random_secret_knower] = single_alias_right[random_effect]

### Iterate through participants in a secret
### random_secret_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = secret
## push_scope = character
alias[effect:random_secret_participant] = single_alias_right[random_effect]

### Iterate through all faiths within a religion
### every_faith = { limit = { <triggers> } <effects> }
## scope = religion
## push_scope = faith
alias[effect:every_faith] = single_alias_right[every_effect]

### Iterate through all faiths within a religion
### ordered_faith = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = religion
## push_scope = faith
alias[effect:ordered_faith] = single_alias_right[ordered_effect]

### Iterate through all faiths within a religion
### random_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = religion
## push_scope = faith
alias[effect:random_faith] = single_alias_right[random_effect]

### Iterate through all MaA regiments in the army
### scope:army = {
### 
### any_army_maa_regiment = {
### 
### 
### include_hired = yes # should it include merc and holy order regiments (yes by default)
### 
### }
### }
### every_army_maa_regiment = { limit = { <triggers> } <effects> }
## scope = army
## push_scope = regiment
alias[effect:every_army_maa_regiment] = single_alias_right[every_effect]

### Iterate through all MaA regiments in the army
### scope:army = {
### 
### any_army_maa_regiment = {
### 
### 
### include_hired = yes # should it include merc and holy order regiments (yes by default)
### 
### }
### }
### ordered_army_maa_regiment = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = army
## push_scope = regiment
alias[effect:ordered_army_maa_regiment] = single_alias_right[ordered_effect]

### Iterate through all MaA regiments in the army
### scope:army = {
### 
### any_army_maa_regiment = {
### 
### 
### include_hired = yes # should it include merc and holy order regiments (yes by default)
### 
### }
### }
### random_army_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = army
## push_scope = regiment
alias[effect:random_army_maa_regiment] = single_alias_right[random_effect]

### Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.
### every_entourage_character = { limit = { <triggers> } <effects> }
## scope = travel_plan
## push_scope = character
alias[effect:every_entourage_character] = single_alias_right[every_effect]

### Iterate through all provinces this travel plan has in its route.
### every_future_path_location = { limit = { <triggers> } <effects> }
## scope = travel_plan
## push_scope = province
alias[effect:every_future_path_location] = single_alias_right[every_effect]

### Iterate through all provinces this travel plan has arrived at so far.
### every_visited_location = { limit = { <triggers> } <effects> }
## scope = travel_plan
## push_scope = province
alias[effect:every_visited_location] = single_alias_right[every_effect]

### Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.
### ordered_entourage_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = travel_plan
## push_scope = character
alias[effect:ordered_entourage_character] = single_alias_right[ordered_effect]

### Iterate through all provinces this travel plan has in its route.
### ordered_future_path_location = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = travel_plan
## push_scope = province
alias[effect:ordered_future_path_location] = single_alias_right[ordered_effect]

### Iterate through all provinces this travel plan has arrived at so far.
### ordered_visited_location = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = travel_plan
## push_scope = province
alias[effect:ordered_visited_location] = single_alias_right[ordered_effect]

### Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.
### random_entourage_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = travel_plan
## push_scope = character
alias[effect:random_entourage_character] = single_alias_right[random_effect]

### Iterate through all provinces this travel plan has in its route.
### random_future_path_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = travel_plan
## push_scope = province
alias[effect:random_future_path_location] = single_alias_right[random_effect]

### Iterate through all provinces this travel plan has arrived at so far.
### random_visited_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = travel_plan
## push_scope = province
alias[effect:random_visited_location] = single_alias_right[random_effect]

### Iterate through all great holy wars this faith is defending against
### every_defensive_great_holy_wars = { limit = { <triggers> } <effects> }
## scope = faith
## push_scope = ghw
alias[effect:every_defensive_great_holy_wars] = single_alias_right[every_effect]

### Iterate through characters of the scoped faith
### every_faith_character = { limit = { <triggers> } <effects> }
## scope = faith
## push_scope = character
alias[effect:every_faith_character] = single_alias_right[every_effect]

### Iterate through all holy orders of the faith
### every_faith_holy_order = { limit = { <triggers> } <effects> }
## scope = faith
## push_scope = holy_order
alias[effect:every_faith_holy_order] = single_alias_right[every_effect]

### Iterate through playable rulers of the scoped faith
### every_faith_playable_ruler = { limit = { <triggers> } <effects> }
## scope = faith
## push_scope = character
alias[effect:every_faith_playable_ruler] = single_alias_right[every_effect]

### Iterate through rulers of the scoped faith
### every_faith_ruler = { limit = { <triggers> } <effects> }
## scope = faith
## push_scope = character
alias[effect:every_faith_ruler] = single_alias_right[every_effect]

### Iterate through all holy site baronies of a faith
### every_holy_site = { limit = { <triggers> } <effects> }
## scope = faith
## push_scope = landed_title
alias[effect:every_holy_site] = single_alias_right[every_effect]

### Iterate through all great holy wars this faith is defending against
### ordered_defensive_great_holy_wars = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faith
## push_scope = ghw
alias[effect:ordered_defensive_great_holy_wars] = single_alias_right[ordered_effect]

### Iterate through characters of the scoped faith
### ordered_faith_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faith
## push_scope = character
alias[effect:ordered_faith_character] = single_alias_right[ordered_effect]

### Iterate through all holy orders of the faith
### ordered_faith_holy_order = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faith
## push_scope = holy_order
alias[effect:ordered_faith_holy_order] = single_alias_right[ordered_effect]

### Iterate through playable rulers of the scoped faith
### ordered_faith_playable_ruler = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faith
## push_scope = character
alias[effect:ordered_faith_playable_ruler] = single_alias_right[ordered_effect]

### Iterate through rulers of the scoped faith
### ordered_faith_ruler = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faith
## push_scope = character
alias[effect:ordered_faith_ruler] = single_alias_right[ordered_effect]

### Iterate through all holy site baronies of a faith
### ordered_holy_site = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faith
## push_scope = landed_title
alias[effect:ordered_holy_site] = single_alias_right[ordered_effect]

### Iterate through all great holy wars this faith is defending against
### random_defensive_great_holy_wars = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faith
## push_scope = ghw
alias[effect:random_defensive_great_holy_wars] = single_alias_right[random_effect]

### Iterate through characters of the scoped faith
### random_faith_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faith
## push_scope = character
alias[effect:random_faith_character] = single_alias_right[random_effect]

### Iterate through all holy orders of the faith
### random_faith_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faith
## push_scope = holy_order
alias[effect:random_faith_holy_order] = single_alias_right[random_effect]

### Iterate through playable rulers of the scoped faith
### random_faith_playable_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faith
## push_scope = character
alias[effect:random_faith_playable_ruler] = single_alias_right[random_effect]

### Iterate through rulers of the scoped faith
### random_faith_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faith
## push_scope = character
alias[effect:random_faith_ruler] = single_alias_right[random_effect]

### Iterate through all holy site baronies of a faith
### random_holy_site = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faith
## push_scope = landed_title
alias[effect:random_holy_site] = single_alias_right[random_effect]

### Iterate through all characters that are interloper in a struggle.
### every_interloper_ruler = { limit = { <triggers> } <effects> }
## scope = struggle
## push_scope = character
alias[effect:every_interloper_ruler] = single_alias_right[every_effect]

### Iterate through all counties that are involved in a struggle
### every_involved_county = { limit = { <triggers> } <effects> }
## scope = struggle
## push_scope = landed_title
alias[effect:every_involved_county] = single_alias_right[every_effect]

### Iterate through all characters that are involved in a struggle.
### every_involved_ruler = { limit = { <triggers> } <effects> }
## scope = struggle
## push_scope = character
alias[effect:every_involved_ruler] = single_alias_right[every_effect]

### Iterate through all characters that are interloper in a struggle.
### ordered_interloper_ruler = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = struggle
## push_scope = character
alias[effect:ordered_interloper_ruler] = single_alias_right[ordered_effect]

### Iterate through all counties that are involved in a struggle
### ordered_involved_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = struggle
## push_scope = landed_title
alias[effect:ordered_involved_county] = single_alias_right[ordered_effect]

### Iterate through all characters that are involved in a struggle.
### ordered_involved_ruler = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = struggle
## push_scope = character
alias[effect:ordered_involved_ruler] = single_alias_right[ordered_effect]

### Iterate through all characters that are interloper in a struggle.
### random_interloper_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = struggle
## push_scope = character
alias[effect:random_interloper_ruler] = single_alias_right[random_effect]

### Iterate through all counties that are involved in a struggle
### random_involved_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = struggle
## push_scope = landed_title
alias[effect:random_involved_county] = single_alias_right[random_effect]

### Iterate through all characters that are involved in a struggle.
### random_involved_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = struggle
## push_scope = character
alias[effect:random_involved_ruler] = single_alias_right[random_effect]

### Iterate through all counties of a situation sub-region (warning: not fast)
### every_situation_sub_region_county = { limit = { <triggers> } <effects> }
## scope = situation_sub_region
## push_scope = landed_title
alias[effect:every_situation_sub_region_county] = single_alias_right[every_effect]

### Iterate through all geographical regions of a situation sub-region
### every_situation_sub_region_geographical_region = { limit = { <triggers> } <effects> }
## scope = situation_sub_region
## push_scope = geographical_region
alias[effect:every_situation_sub_region_geographical_region] = single_alias_right[every_effect]

### Iterate through all characters that are participating in a situation, in a specific subregion
### every_situation_sub_region_participant = { limit = { <triggers> } <effects> }
## scope = situation_sub_region
## push_scope = character
alias[effect:every_situation_sub_region_participant] = single_alias_right[every_effect]

### Iterate through all participant groups of the situation sub-region
### every_situation_sub_region_participant_group = { limit = { <triggers> } <effects> }
## scope = situation_sub_region
## push_scope = situation_participant_group
alias[effect:every_situation_sub_region_participant_group] = single_alias_right[every_effect]

### Iterate through all counties of a situation sub-region (warning: not fast)
### ordered_situation_sub_region_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation_sub_region
## push_scope = landed_title
alias[effect:ordered_situation_sub_region_county] = single_alias_right[ordered_effect]

### Iterate through all geographical regions of a situation sub-region
### ordered_situation_sub_region_geographical_region = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation_sub_region
## push_scope = geographical_region
alias[effect:ordered_situation_sub_region_geographical_region] = single_alias_right[ordered_effect]

### Iterate through all characters that are participating in a situation, in a specific subregion
### ordered_situation_sub_region_participant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation_sub_region
## push_scope = character
alias[effect:ordered_situation_sub_region_participant] = single_alias_right[ordered_effect]

### Iterate through all participant groups of the situation sub-region
### ordered_situation_sub_region_participant_group = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation_sub_region
## push_scope = situation_participant_group
alias[effect:ordered_situation_sub_region_participant_group] = single_alias_right[ordered_effect]

### Iterate through all counties of a situation sub-region (warning: not fast)
### random_situation_sub_region_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation_sub_region
## push_scope = landed_title
alias[effect:random_situation_sub_region_county] = single_alias_right[random_effect]

### Iterate through all geographical regions of a situation sub-region
### random_situation_sub_region_geographical_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation_sub_region
## push_scope = geographical_region
alias[effect:random_situation_sub_region_geographical_region] = single_alias_right[random_effect]

### Iterate through all characters that are participating in a situation, in a specific subregion
### random_situation_sub_region_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation_sub_region
## push_scope = character
alias[effect:random_situation_sub_region_participant] = single_alias_right[random_effect]

### Iterate through all participant groups of the situation sub-region
### random_situation_sub_region_participant_group = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation_sub_region
## push_scope = situation_participant_group
alias[effect:random_situation_sub_region_participant_group] = single_alias_right[random_effect]

### Iterate through all pledged attackers within a great holy war
### every_pledged_attacker = { limit = { <triggers> } <effects> }
## scope = ghw
## push_scope = character
alias[effect:every_pledged_attacker] = single_alias_right[every_effect]

### Iterate through all pledged defenders within a great holy war
### every_pledged_defender = { limit = { <triggers> } <effects> }
## scope = ghw
## push_scope = character
alias[effect:every_pledged_defender] = single_alias_right[every_effect]

### Iterate through all pledged attackers within a great holy war
### ordered_pledged_attacker = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = ghw
## push_scope = character
alias[effect:ordered_pledged_attacker] = single_alias_right[ordered_effect]

### Iterate through all pledged defenders within a great holy war
### ordered_pledged_defender = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = ghw
## push_scope = character
alias[effect:ordered_pledged_defender] = single_alias_right[ordered_effect]

### Iterate through all pledged attackers within a great holy war
### random_pledged_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = ghw
## push_scope = character
alias[effect:random_pledged_attacker] = single_alias_right[random_effect]

### Iterate through all pledged defenders within a great holy war
### random_pledged_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = ghw
## push_scope = character
alias[effect:random_pledged_defender] = single_alias_right[random_effect]

### Gets all provinces infected by the scoped epidemic
### every_infected_province = { limit = { <triggers> } <effects> }
## scope = epidemic
## push_scope = province
alias[effect:every_infected_province] = single_alias_right[every_effect]

### Gets all provinces infected by the scoped epidemic
### ordered_infected_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = epidemic
## push_scope = province
alias[effect:ordered_infected_province] = single_alias_right[ordered_effect]

### Gets all provinces infected by the scoped epidemic
### random_infected_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = epidemic
## push_scope = province
alias[effect:random_infected_province] = single_alias_right[random_effect]

### Iterates through all Vassals assigned to the scoped Tax Slot
### every_tax_slot_vassal = { limit = { <triggers> } <effects> }
## scope = tax_slot
## push_scope = character
alias[effect:every_tax_slot_vassal] = single_alias_right[every_effect]

### Iterates through all Vassals assigned to the scoped Tax Slot
### ordered_tax_slot_vassal = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = tax_slot
## push_scope = character
alias[effect:ordered_tax_slot_vassal] = single_alias_right[ordered_effect]

### Iterates through all Vassals assigned to the scoped Tax Slot
### random_tax_slot_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = tax_slot
## push_scope = character
alias[effect:random_tax_slot_vassal] = single_alias_right[random_effect]

### Iterate through all characters that are part of a participation group in a situation.
### every_situation_group_participant = { limit = { <triggers> } <effects> }
## scope = situation_participant_group
## push_scope = character
alias[effect:every_situation_group_participant] = single_alias_right[every_effect]

### Iterate through all characters that are part of a participation group in a situation.
### ordered_situation_group_participant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation_participant_group
## push_scope = character
alias[effect:ordered_situation_group_participant] = single_alias_right[ordered_effect]

### Iterate through all characters that are part of a participation group in a situation.
### random_situation_group_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation_participant_group
## push_scope = character
alias[effect:random_situation_group_participant] = single_alias_right[random_effect]

### Iterate through all casus belli's target titles
### every_target_title = { limit = { <triggers> } <effects> }
## scope = casus_belli
## push_scope = landed_title
alias[effect:every_target_title] = single_alias_right[every_effect]

### Iterate through all casus belli's target titles
### ordered_target_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = casus_belli
## push_scope = landed_title
alias[effect:ordered_target_title] = single_alias_right[ordered_effect]

### Iterate through all casus belli's target titles
### random_target_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = casus_belli
## push_scope = landed_title
alias[effect:random_target_title] = single_alias_right[random_effect]

### Iterate through all characters with a claim on the scoped artifact
### every_artifact_claimant = { limit = { <triggers> } <effects> }
## scope = artifact
## push_scope = character
alias[effect:every_artifact_claimant] = single_alias_right[every_effect]

### Iterate through all dynasty houses with a claim on the scoped artifact
### every_artifact_house_claimant = { limit = { <triggers> } <effects> }
## scope = artifact
## push_scope = dynasty_house
alias[effect:every_artifact_house_claimant] = single_alias_right[every_effect]

### Iterate through all characters with a claim on the scoped artifact
### ordered_artifact_claimant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = artifact
## push_scope = character
alias[effect:ordered_artifact_claimant] = single_alias_right[ordered_effect]

### Iterate through all dynasty houses with a claim on the scoped artifact
### ordered_artifact_house_claimant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = artifact
## push_scope = dynasty_house
alias[effect:ordered_artifact_house_claimant] = single_alias_right[ordered_effect]

### Iterate through all characters with a claim on the scoped artifact
### random_artifact_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = artifact
## push_scope = character
alias[effect:random_artifact_claimant] = single_alias_right[random_effect]

### Iterate through all dynasty houses with a claim on the scoped artifact
### random_artifact_house_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = artifact
## push_scope = dynasty_house
alias[effect:random_artifact_house_claimant] = single_alias_right[random_effect]

### Iterate through all kills of a character
### every_killed_character = { limit = { <triggers> } <effects> }
## scope = { character artifact }
## push_scope = character
alias[effect:every_killed_character] = single_alias_right[every_effect]

### Iterate through all kills of a character
### ordered_killed_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = { character artifact }
## push_scope = character
alias[effect:ordered_killed_character] = single_alias_right[ordered_effect]

### Iterate through all kills of a character
### random_killed_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = { character artifact }
## push_scope = character
alias[effect:random_killed_character] = single_alias_right[random_effect]

### Iterate through every accolade_type in the database
### every_accolade_type = { limit = { <triggers> } <effects> }
## push_scope = accolade_type
alias[effect:every_accolade_type] = single_alias_right[every_effect]

### Iterate through all activities in the world
### every_activity = { limit = { <triggers> } <effects> }
## push_scope = activity
alias[effect:every_activity] = single_alias_right[every_effect]

### Iterate through every activity_type in the database
### every_activity_type = { limit = { <triggers> } <effects> }
## push_scope = activity_type
alias[effect:every_activity_type] = single_alias_right[every_effect]

### Iterate through all existing artifacts
### every_artifact = { limit = { <triggers> } <effects> }
## push_scope = artifact
alias[effect:every_artifact] = single_alias_right[every_effect]

### Iterate through all baronies in the game
### every_barony = { limit = { <triggers> } <effects> }
## push_scope = landed_title
alias[effect:every_barony] = single_alias_right[every_effect]

### Iterate through every casus_belli_type in the database
### every_casus_belli_type = { limit = { <triggers> } <effects> }
## push_scope = casus_belli_type
alias[effect:every_casus_belli_type] = single_alias_right[every_effect]

### Iterate through all characters with a royal court
### every_character_with_royal_court = { limit = { <triggers> } <effects> }
## push_scope = character
alias[effect:every_character_with_royal_court] = single_alias_right[every_effect]

### Gets all legends in the world that have been completed
### every_completed_legend = { limit = { <triggers> } <effects> }
## push_scope = legend
alias[effect:every_completed_legend] = single_alias_right[every_effect]

### Iterate through all counties in the game
### every_county = { limit = { <triggers> } <effects> }
## push_scope = landed_title
alias[effect:every_county] = single_alias_right[every_effect]

### Iterate through every court_position_type in the database
### every_court_position_type = { limit = { <triggers> } <effects> }
## push_scope = court_position_type
alias[effect:every_court_position_type] = single_alias_right[every_effect]

### Iterate through all cultures in the game
### every_culture_global = { limit = { <triggers> } <effects> }
## push_scope = culture
alias[effect:every_culture_global] = single_alias_right[every_effect]

### Iterate through every culture_pillar in the database
### every_culture_pillar = { limit = { <triggers> } <effects> }
## push_scope = culture_pillar
alias[effect:every_culture_pillar] = single_alias_right[every_effect]

### Iterate through every culture_tradition in the database
### every_culture_tradition = { limit = { <triggers> } <effects> }
## push_scope = culture_tradition
alias[effect:every_culture_tradition] = single_alias_right[every_effect]

### Iterate through every decision in the database
### every_decision = { limit = { <triggers> } <effects> }
## push_scope = decision
alias[effect:every_decision] = single_alias_right[every_effect]

### Iterate through every doctrine in the database
### every_doctrine = { limit = { <triggers> } <effects> }
## push_scope = doctrine
alias[effect:every_doctrine] = single_alias_right[every_effect]

### Iterate through all domiciles
### every_domicile = { limit = { <triggers> } <effects> }
## push_scope = domicile
alias[effect:every_domicile] = single_alias_right[every_effect]

### Iterate through all duchies in the game
### every_duchy = { limit = { <triggers> } <effects> }
## push_scope = landed_title
alias[effect:every_duchy] = single_alias_right[every_effect]

### Iterate through all empires in the game
### every_empire = { limit = { <triggers> } <effects> }
## push_scope = landed_title
alias[effect:every_empire] = single_alias_right[every_effect]

### Gets all epidemics in the world
### every_epidemic = { limit = { <triggers> } <effects> }
## push_scope = epidemic
alias[effect:every_epidemic] = single_alias_right[every_effect]

### Iterate through every epidemic_type in the database
### every_epidemic_type = { limit = { <triggers> } <effects> }
## push_scope = epidemic_type
alias[effect:every_epidemic_type] = single_alias_right[every_effect]

### Iterate through every geographical_region in the database
### every_geographical_region = { limit = { <triggers> } <effects> }
## push_scope = geographical_region
alias[effect:every_geographical_region] = single_alias_right[every_effect]

### Iterate through every government_type in the database
### every_government_type = { limit = { <triggers> } <effects> }
## push_scope = government_type
alias[effect:every_government_type] = single_alias_right[every_effect]

### Iterate through every holding_type in the database
### every_holding_type = { limit = { <triggers> } <effects> }
## push_scope = holding_type
alias[effect:every_holding_type] = single_alias_right[every_effect]

### Iterate through all counties that are important for at least some title
### every_important_location = { limit = { <triggers> } <effects> }
## push_scope = landed_title
alias[effect:every_important_location] = single_alias_right[every_effect]

### Independent rulers list with a COUNT tier or above who hold land
### every_independent_ruler = { limit = { <triggers> } <effects> }
## push_scope = character
alias[effect:every_independent_ruler] = single_alias_right[every_effect]

### Iterate through all inspirations in the world
### every_inspiration = { limit = { <triggers> } <effects> }
## push_scope = inspiration
alias[effect:every_inspiration] = single_alias_right[every_effect]

### Iterate through all characters with an inspirations in the world
### every_inspired_character = { limit = { <triggers> } <effects> }
## push_scope = character
alias[effect:every_inspired_character] = single_alias_right[every_effect]

### Iterate through all titles that are interested in any county
### every_interested_title = { limit = { <triggers> } <effects> }
## push_scope = landed_title
alias[effect:every_interested_title] = single_alias_right[every_effect]

### Iterate through all kingdoms in the game
### every_kingdom = { limit = { <triggers> } <effects> }
## push_scope = landed_title
alias[effect:every_kingdom] = single_alias_right[every_effect]

### Gets all legends in the world that have not been completed
### every_legend = { limit = { <triggers> } <effects> }
## push_scope = legend
alias[effect:every_legend] = single_alias_right[every_effect]

### Iterate through every legend_type in the database
### every_legend_type = { limit = { <triggers> } <effects> }
## push_scope = legend_type
alias[effect:every_legend_type] = single_alias_right[every_effect]

### Iterate through all living characters
### every_living_character = { limit = { <triggers> } <effects> }
## push_scope = character
alias[effect:every_living_character] = single_alias_right[every_effect]

### Iterate through all mercenary companies
### every_mercenary_company = { limit = { <triggers> } <effects> }
## push_scope = mercenary_company
alias[effect:every_mercenary_company] = single_alias_right[every_effect]

### Iterate through all open invite activities in the world
### every_open_invite_activity = { limit = { <triggers> } <effects> }
## push_scope = activity
alias[effect:every_open_invite_activity] = single_alias_right[every_effect]

### Iterate through all player characters
### every_player = { limit = { <triggers> } <effects> }
## push_scope = character
alias[effect:every_player] = single_alias_right[every_effect]

### Iterate through all provinces (skips non-land and impassable provinces)
### every_province = { limit = { <triggers> } <effects> }
## push_scope = province
alias[effect:every_province] = single_alias_right[every_effect]

### Iterate through all religions in the game
### every_religion_global = { limit = { <triggers> } <effects> }
## push_scope = religion
alias[effect:every_religion_global] = single_alias_right[every_effect]

### Rulers list with a COUNT tier o above
### every_ruler = { limit = { <triggers> } <effects> }
## push_scope = character
alias[effect:every_ruler] = single_alias_right[every_effect]

### Iterate through all provinces with a special building slot (built or un-built)
### every_special_building_province = { limit = { <triggers> } <effects> }
## push_scope = province
alias[effect:every_special_building_province] = single_alias_right[every_effect]

### Gets all available and accepted task contracts.
### every_task_contract = { limit = { <triggers> } <effects> }
## push_scope = task_contract
alias[effect:every_task_contract] = single_alias_right[every_effect]

### Iterate through every task_contract_type in the database
### every_task_contract_type = { limit = { <triggers> } <effects> }
## push_scope = task_contract_type
alias[effect:every_task_contract_type] = single_alias_right[every_effect]

### Iterate through every trait in the database
### every_trait = { limit = { <triggers> } <effects> }
## push_scope = trait
alias[effect:every_trait] = single_alias_right[every_effect]

### Iterate through every vassal_contract in the database
### every_vassal_contract = { limit = { <triggers> } <effects> }
## push_scope = vassal_contract
alias[effect:every_vassal_contract] = single_alias_right[every_effect]

### Iterate through every accolade_type in the database
### ordered_accolade_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = accolade_type
alias[effect:ordered_accolade_type] = single_alias_right[ordered_effect]

### Iterate through all activities in the world
### ordered_activity = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = activity
alias[effect:ordered_activity] = single_alias_right[ordered_effect]

### Iterate through every activity_type in the database
### ordered_activity_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = activity_type
alias[effect:ordered_activity_type] = single_alias_right[ordered_effect]

### Iterate through all existing artifacts
### ordered_artifact = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = artifact
alias[effect:ordered_artifact] = single_alias_right[ordered_effect]

### Iterate through all baronies in the game
### ordered_barony = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = landed_title
alias[effect:ordered_barony] = single_alias_right[ordered_effect]

### Iterate through every casus_belli_type in the database
### ordered_casus_belli_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = casus_belli_type
alias[effect:ordered_casus_belli_type] = single_alias_right[ordered_effect]

### Iterate through all characters with a royal court
### ordered_character_with_royal_court = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = character
alias[effect:ordered_character_with_royal_court] = single_alias_right[ordered_effect]

### Gets all legends in the world that have been completed
### ordered_completed_legend = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = legend
alias[effect:ordered_completed_legend] = single_alias_right[ordered_effect]

### Iterate through all counties in the game
### ordered_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = landed_title
alias[effect:ordered_county] = single_alias_right[ordered_effect]

### Iterate through every court_position_type in the database
### ordered_court_position_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = court_position_type
alias[effect:ordered_court_position_type] = single_alias_right[ordered_effect]

### Iterate through all cultures in the game
### ordered_culture_global = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = culture
alias[effect:ordered_culture_global] = single_alias_right[ordered_effect]

### Iterate through every culture_pillar in the database
### ordered_culture_pillar = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = culture_pillar
alias[effect:ordered_culture_pillar] = single_alias_right[ordered_effect]

### Iterate through every culture_tradition in the database
### ordered_culture_tradition = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = culture_tradition
alias[effect:ordered_culture_tradition] = single_alias_right[ordered_effect]

### Iterate through every decision in the database
### ordered_decision = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = decision
alias[effect:ordered_decision] = single_alias_right[ordered_effect]

### Iterate through every doctrine in the database
### ordered_doctrine = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = doctrine
alias[effect:ordered_doctrine] = single_alias_right[ordered_effect]

### Iterate through all domiciles
### ordered_domicile = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = domicile
alias[effect:ordered_domicile] = single_alias_right[ordered_effect]

### Iterate through all duchies in the game
### ordered_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = landed_title
alias[effect:ordered_duchy] = single_alias_right[ordered_effect]

### Iterate through all empires in the game
### ordered_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = landed_title
alias[effect:ordered_empire] = single_alias_right[ordered_effect]

### Gets all epidemics in the world
### ordered_epidemic = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = epidemic
alias[effect:ordered_epidemic] = single_alias_right[ordered_effect]

### Iterate through every epidemic_type in the database
### ordered_epidemic_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = epidemic_type
alias[effect:ordered_epidemic_type] = single_alias_right[ordered_effect]

### Iterate through every geographical_region in the database
### ordered_geographical_region = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = geographical_region
alias[effect:ordered_geographical_region] = single_alias_right[ordered_effect]

### Iterate through every government_type in the database
### ordered_government_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = government_type
alias[effect:ordered_government_type] = single_alias_right[ordered_effect]

### Iterate through every holding_type in the database
### ordered_holding_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = holding_type
alias[effect:ordered_holding_type] = single_alias_right[ordered_effect]

### Iterate through all counties that are important for at least some title
### ordered_important_location = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = landed_title
alias[effect:ordered_important_location] = single_alias_right[ordered_effect]

### Independent rulers list with a COUNT tier or above who hold land
### ordered_independent_ruler = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = character
alias[effect:ordered_independent_ruler] = single_alias_right[ordered_effect]

### Iterate through all inspirations in the world
### ordered_inspiration = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = inspiration
alias[effect:ordered_inspiration] = single_alias_right[ordered_effect]

### Iterate through all characters with an inspirations in the world
### ordered_inspired_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = character
alias[effect:ordered_inspired_character] = single_alias_right[ordered_effect]

### Iterate through all titles that are interested in any county
### ordered_interested_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = landed_title
alias[effect:ordered_interested_title] = single_alias_right[ordered_effect]

### Iterate through all kingdoms in the game
### ordered_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = landed_title
alias[effect:ordered_kingdom] = single_alias_right[ordered_effect]

### Gets all legends in the world that have not been completed
### ordered_legend = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = legend
alias[effect:ordered_legend] = single_alias_right[ordered_effect]

### Iterate through every legend_type in the database
### ordered_legend_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = legend_type
alias[effect:ordered_legend_type] = single_alias_right[ordered_effect]

### Iterate through all living characters
### ordered_living_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = character
alias[effect:ordered_living_character] = single_alias_right[ordered_effect]

### Iterate through all mercenary companies
### ordered_mercenary_company = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = mercenary_company
alias[effect:ordered_mercenary_company] = single_alias_right[ordered_effect]

### Iterate through all open invite activities in the world
### ordered_open_invite_activity = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = activity
alias[effect:ordered_open_invite_activity] = single_alias_right[ordered_effect]

### Iterate through all player characters
### ordered_player = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = character
alias[effect:ordered_player] = single_alias_right[ordered_effect]

### Iterate through all provinces (skips non-land and impassable provinces)
### ordered_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = province
alias[effect:ordered_province] = single_alias_right[ordered_effect]

### Iterate through all religions in the game
### ordered_religion_global = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = religion
alias[effect:ordered_religion_global] = single_alias_right[ordered_effect]

### Rulers list with a COUNT tier o above
### ordered_ruler = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = character
alias[effect:ordered_ruler] = single_alias_right[ordered_effect]

### Iterate through all provinces with a special building slot (built or un-built)
### ordered_special_building_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = province
alias[effect:ordered_special_building_province] = single_alias_right[ordered_effect]

### Gets all available and accepted task contracts.
### ordered_task_contract = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = task_contract
alias[effect:ordered_task_contract] = single_alias_right[ordered_effect]

### Iterate through every task_contract_type in the database
### ordered_task_contract_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = task_contract_type
alias[effect:ordered_task_contract_type] = single_alias_right[ordered_effect]

### Iterate through every trait in the database
### ordered_trait = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = trait
alias[effect:ordered_trait] = single_alias_right[ordered_effect]

### Iterate through every vassal_contract in the database
### ordered_vassal_contract = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## push_scope = vassal_contract
alias[effect:ordered_vassal_contract] = single_alias_right[ordered_effect]

### Iterate through every accolade_type in the database
### random_accolade_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = accolade_type
alias[effect:random_accolade_type] = single_alias_right[random_effect]

### Iterate through all activities in the world
### random_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = activity
alias[effect:random_activity] = single_alias_right[random_effect]

### Iterate through every activity_type in the database
### random_activity_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = activity_type
alias[effect:random_activity_type] = single_alias_right[random_effect]

### Iterate through all existing artifacts
### random_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = artifact
alias[effect:random_artifact] = single_alias_right[random_effect]

### Iterate through all baronies in the game
### random_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = landed_title
alias[effect:random_barony] = single_alias_right[random_effect]

### Iterate through every casus_belli_type in the database
### random_casus_belli_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = casus_belli_type
alias[effect:random_casus_belli_type] = single_alias_right[random_effect]

### Iterate through all characters with a royal court
### random_character_with_royal_court = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = character
alias[effect:random_character_with_royal_court] = single_alias_right[random_effect]

### Gets all legends in the world that have been completed
### random_completed_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = legend
alias[effect:random_completed_legend] = single_alias_right[random_effect]

### Iterate through all counties in the game
### random_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = landed_title
alias[effect:random_county] = single_alias_right[random_effect]

### Iterate through every court_position_type in the database
### random_court_position_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = court_position_type
alias[effect:random_court_position_type] = single_alias_right[random_effect]

### Iterate through all cultures in the game
### random_culture_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = culture
alias[effect:random_culture_global] = single_alias_right[random_effect]

### Iterate through every culture_pillar in the database
### random_culture_pillar = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = culture_pillar
alias[effect:random_culture_pillar] = single_alias_right[random_effect]

### Iterate through every culture_tradition in the database
### random_culture_tradition = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = culture_tradition
alias[effect:random_culture_tradition] = single_alias_right[random_effect]

### Iterate through every decision in the database
### random_decision = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = decision
alias[effect:random_decision] = single_alias_right[random_effect]

### Iterate through every doctrine in the database
### random_doctrine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = doctrine
alias[effect:random_doctrine] = single_alias_right[random_effect]

### Iterate through all domiciles
### random_domicile = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = domicile
alias[effect:random_domicile] = single_alias_right[random_effect]

### Iterate through all duchies in the game
### random_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = landed_title
alias[effect:random_duchy] = single_alias_right[random_effect]

### Iterate through all empires in the game
### random_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = landed_title
alias[effect:random_empire] = single_alias_right[random_effect]

### Gets all epidemics in the world
### random_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = epidemic
alias[effect:random_epidemic] = single_alias_right[random_effect]

### Iterate through every epidemic_type in the database
### random_epidemic_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = epidemic_type
alias[effect:random_epidemic_type] = single_alias_right[random_effect]

### Iterate through every geographical_region in the database
### random_geographical_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = geographical_region
alias[effect:random_geographical_region] = single_alias_right[random_effect]

### Iterate through every government_type in the database
### random_government_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = government_type
alias[effect:random_government_type] = single_alias_right[random_effect]

### Iterate through every holding_type in the database
### random_holding_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = holding_type
alias[effect:random_holding_type] = single_alias_right[random_effect]

### Iterate through all counties that are important for at least some title
### random_important_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = landed_title
alias[effect:random_important_location] = single_alias_right[random_effect]

### Independent rulers list with a COUNT tier or above who hold land
### random_independent_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = character
alias[effect:random_independent_ruler] = single_alias_right[random_effect]

### Iterate through all inspirations in the world
### random_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = inspiration
alias[effect:random_inspiration] = single_alias_right[random_effect]

### Iterate through all characters with an inspirations in the world
### random_inspired_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = character
alias[effect:random_inspired_character] = single_alias_right[random_effect]

### Iterate through all titles that are interested in any county
### random_interested_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = landed_title
alias[effect:random_interested_title] = single_alias_right[random_effect]

### Iterate through all kingdoms in the game
### random_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = landed_title
alias[effect:random_kingdom] = single_alias_right[random_effect]

### Gets all legends in the world that have not been completed
### random_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = legend
alias[effect:random_legend] = single_alias_right[random_effect]

### Iterate through every legend_type in the database
### random_legend_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = legend_type
alias[effect:random_legend_type] = single_alias_right[random_effect]

### Iterate through all living characters
### random_living_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = character
alias[effect:random_living_character] = single_alias_right[random_effect]

### Log the current scope to the random log when this effect executes. Only use temprorarily for debugging purposes as it can introduce localized strings into the Scopes._Random log. yes = full scope info, no=only current scope
alias[effect:random_log_scopes] = single_alias_right[random_effect]

### Iterate through all mercenary companies
### random_mercenary_company = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = mercenary_company
alias[effect:random_mercenary_company] = single_alias_right[random_effect]

### Iterate through all open invite activities in the world
### random_open_invite_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = activity
alias[effect:random_open_invite_activity] = single_alias_right[random_effect]

### Iterate through all player characters
### random_player = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = character
alias[effect:random_player] = single_alias_right[random_effect]

### Iterate through all provinces (skips non-land and impassable provinces)
### random_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = province
alias[effect:random_province] = single_alias_right[random_effect]

### Iterate through all religions in the game
### random_religion_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = religion
alias[effect:random_religion_global] = single_alias_right[random_effect]

### Rulers list with a COUNT tier o above
### random_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = character
alias[effect:random_ruler] = single_alias_right[random_effect]

### Iterate through all provinces with a special building slot (built or un-built)
### random_special_building_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = province
alias[effect:random_special_building_province] = single_alias_right[random_effect]

### Gets all available and accepted task contracts.
### random_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = task_contract
alias[effect:random_task_contract] = single_alias_right[random_effect]

### Iterate through every task_contract_type in the database
### random_task_contract_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = task_contract_type
alias[effect:random_task_contract_type] = single_alias_right[random_effect]

### Iterate through every trait in the database
### random_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = trait
alias[effect:random_trait] = single_alias_right[random_effect]

### Iterate through every vassal_contract in the database
### random_vassal_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## push_scope = vassal_contract
alias[effect:random_vassal_contract] = single_alias_right[random_effect]

### Iterate through all armies currently located in the scoped province
### every_army_in_location = { limit = { <triggers> } <effects> }
## scope = province
## push_scope = army
alias[effect:every_army_in_location] = single_alias_right[every_effect]

### Iterate through all characters currently located in the scoped province
### every_character_in_location = { limit = { <triggers> } <effects> }
## scope = province
## push_scope = character
alias[effect:every_character_in_location] = single_alias_right[every_effect]

### Iterate through all neighboring provinces of a province
### every_neighboring_province = { limit = { <triggers> } <effects> }
## scope = province
## push_scope = province
alias[effect:every_neighboring_province] = single_alias_right[every_effect]

### Iterate through all domiciles of scoped province
### every_province_domicile = { limit = { <triggers> } <effects> }
## scope = province
## push_scope = domicile
alias[effect:every_province_domicile] = single_alias_right[every_effect]

### Gets epidemics affecting the scoped province
### every_province_epidemic = { limit = { <triggers> } <effects> }
## scope = province
## push_scope = epidemic
alias[effect:every_province_epidemic] = single_alias_right[every_effect]

### Gets legends affecting the scoped province
### every_province_legend = { limit = { <triggers> } <effects> }
## scope = province
## push_scope = legend
alias[effect:every_province_legend] = single_alias_right[every_effect]

### Iterate through all armies currently located in the scoped province
### ordered_army_in_location = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = province
## push_scope = army
alias[effect:ordered_army_in_location] = single_alias_right[ordered_effect]

### Iterate through all characters currently located in the scoped province
### ordered_character_in_location = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = province
## push_scope = character
alias[effect:ordered_character_in_location] = single_alias_right[ordered_effect]

### Iterate through all neighboring provinces of a province
### ordered_neighboring_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = province
## push_scope = province
alias[effect:ordered_neighboring_province] = single_alias_right[ordered_effect]

### Iterate through all domiciles of scoped province
### ordered_province_domicile = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = province
## push_scope = domicile
alias[effect:ordered_province_domicile] = single_alias_right[ordered_effect]

### Gets epidemics affecting the scoped province
### ordered_province_epidemic = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = province
## push_scope = epidemic
alias[effect:ordered_province_epidemic] = single_alias_right[ordered_effect]

### Gets legends affecting the scoped province
### ordered_province_legend = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = province
## push_scope = legend
alias[effect:ordered_province_legend] = single_alias_right[ordered_effect]

### Iterate through all armies currently located in the scoped province
### random_army_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = province
## push_scope = army
alias[effect:random_army_in_location] = single_alias_right[random_effect]

### Iterate through all characters currently located in the scoped province
### random_character_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = province
## push_scope = character
alias[effect:random_character_in_location] = single_alias_right[random_effect]

### Iterate through all neighboring provinces of a province
### random_neighboring_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = province
## push_scope = province
alias[effect:random_neighboring_province] = single_alias_right[random_effect]

### Iterate through all domiciles of scoped province
### random_province_domicile = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = province
## push_scope = domicile
alias[effect:random_province_domicile] = single_alias_right[random_effect]

### Gets epidemics affecting the scoped province
### random_province_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = province
## push_scope = epidemic
alias[effect:random_province_epidemic] = single_alias_right[random_effect]

### Gets legends affecting the scoped province
### random_province_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = province
## push_scope = legend
alias[effect:random_province_legend] = single_alias_right[random_effect]

### Iterate through all attackers in the war
### every_war_attacker = { limit = { <triggers> } <effects> }
## scope = war
## push_scope = character
alias[effect:every_war_attacker] = single_alias_right[every_effect]

### Iterate through all defenders in the war
### every_war_defender = { limit = { <triggers> } <effects> }
## scope = war
## push_scope = character
alias[effect:every_war_defender] = single_alias_right[every_effect]

### Iterate through all participants in the war
### every_war_participant = { limit = { <triggers> } <effects> }
## scope = war
## push_scope = character
alias[effect:every_war_participant] = single_alias_right[every_effect]

### Iterate through all attackers in the war
### ordered_war_attacker = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = war
## push_scope = character
alias[effect:ordered_war_attacker] = single_alias_right[ordered_effect]

### Iterate through all defenders in the war
### ordered_war_defender = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = war
## push_scope = character
alias[effect:ordered_war_defender] = single_alias_right[ordered_effect]

### Iterate through all participants in the war
### ordered_war_participant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = war
## push_scope = character
alias[effect:ordered_war_participant] = single_alias_right[ordered_effect]

### Iterate through all attackers in the war
### random_war_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = war
## push_scope = character
alias[effect:random_war_attacker] = single_alias_right[random_effect]

### Iterate through all defenders in the war
### random_war_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = war
## push_scope = character
alias[effect:random_war_defender] = single_alias_right[random_effect]

### Iterate through all participants in the war
### random_war_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = war
## push_scope = character
alias[effect:random_war_participant] = single_alias_right[random_effect]

### Iterate through all titles leased to a holy order
### every_leased_title = { limit = { <triggers> } <effects> }
## scope = holy_order
## push_scope = landed_title
alias[effect:every_leased_title] = single_alias_right[every_effect]

### Iterate through all titles leased to a holy order
### ordered_leased_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = holy_order
## push_scope = landed_title
alias[effect:ordered_leased_title] = single_alias_right[ordered_effect]

### Iterate through all titles leased to a holy order
### random_leased_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = holy_order
## push_scope = landed_title
alias[effect:random_leased_title] = single_alias_right[random_effect]

### Iterate through all defined required government types for a holding type
### every_required_heir_government_type = { limit = { <triggers> } <effects> }
## scope = holding_type
## push_scope = government_type
alias[effect:every_required_heir_government_type] = single_alias_right[every_effect]

### Iterate through all defined required government types for a holding type
### ordered_required_heir_government_type = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = holding_type
## push_scope = government_type
alias[effect:ordered_required_heir_government_type] = single_alias_right[ordered_effect]

### Iterate through all defined required government types for a holding type
### random_required_heir_government_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = holding_type
## push_scope = government_type
alias[effect:random_required_heir_government_type] = single_alias_right[random_effect]

### Gets all promoters of the scoped legend
### every_legend_promoter = { limit = { <triggers> } <effects> }
## scope = legend
## push_scope = character
alias[effect:every_legend_promoter] = single_alias_right[every_effect]

### Gets all provinces the scoped legend has spread into
### every_spread_province = { limit = { <triggers> } <effects> }
## scope = legend
## push_scope = province
alias[effect:every_spread_province] = single_alias_right[every_effect]

### Gets all promoters of the scoped legend
### ordered_legend_promoter = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = legend
## push_scope = character
alias[effect:ordered_legend_promoter] = single_alias_right[ordered_effect]

### Gets all provinces the scoped legend has spread into
### ordered_spread_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = legend
## push_scope = province
alias[effect:ordered_spread_province] = single_alias_right[ordered_effect]

### Gets all promoters of the scoped legend
### random_legend_promoter = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = legend
## push_scope = character
alias[effect:random_legend_promoter] = single_alias_right[random_effect]

### Gets all provinces the scoped legend has spread into
### random_spread_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = legend
## push_scope = province
alias[effect:random_spread_province] = single_alias_right[random_effect]

### Iterate through all participant groups of the situation (in all sub-regions)
### every_participant_group = { limit = { <triggers> } <effects> }
## scope = situation
## push_scope = situation_participant_group
alias[effect:every_participant_group] = single_alias_right[every_effect]

### Iterate through all counties that are involved in a situation
### every_situation_county = { limit = { <triggers> } <effects> }
## scope = situation
## push_scope = landed_title
alias[effect:every_situation_county] = single_alias_right[every_effect]

### Iterate through all characters that are participating in a situation.
### every_situation_participant = { limit = { <triggers> } <effects> }
## scope = situation
## push_scope = character
alias[effect:every_situation_participant] = single_alias_right[every_effect]

### Iterate through all sub-regions of a situation
### every_situation_sub_region = { limit = { <triggers> } <effects> }
## scope = situation
## push_scope = situation_sub_region
alias[effect:every_situation_sub_region] = single_alias_right[every_effect]

### Iterate through all participant groups of the situation (in all sub-regions)
### ordered_participant_group = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation
## push_scope = situation_participant_group
alias[effect:ordered_participant_group] = single_alias_right[ordered_effect]

### Iterate through all counties that are involved in a situation
### ordered_situation_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation
## push_scope = landed_title
alias[effect:ordered_situation_county] = single_alias_right[ordered_effect]

### Iterate through all characters that are participating in a situation.
### ordered_situation_participant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation
## push_scope = character
alias[effect:ordered_situation_participant] = single_alias_right[ordered_effect]

### Iterate through all sub-regions of a situation
### ordered_situation_sub_region = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = situation
## push_scope = situation_sub_region
alias[effect:ordered_situation_sub_region] = single_alias_right[ordered_effect]

### Iterate through all participant groups of the situation (in all sub-regions)
### random_participant_group = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation
## push_scope = situation_participant_group
alias[effect:random_participant_group] = single_alias_right[random_effect]

### Iterate through all counties that are involved in a situation
### random_situation_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation
## push_scope = landed_title
alias[effect:random_situation_county] = single_alias_right[random_effect]

### Iterate through all characters that are participating in a situation.
### random_situation_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation
## push_scope = character
alias[effect:random_situation_participant] = single_alias_right[random_effect]

### Iterate through all sub-regions of a situation
### random_situation_sub_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = situation
## push_scope = situation_sub_region
alias[effect:random_situation_sub_region] = single_alias_right[random_effect]

### Iterate through all characters in agent slots in the scheme
### every_scheme_agent_character = { limit = { <triggers> } <effects> }
## scope = scheme
## push_scope = character
alias[effect:every_scheme_agent_character] = single_alias_right[every_effect]

### Iterate through all agent slots in the scheme
### every_scheme_agent_slot = { limit = { <triggers> } <effects> }
## scope = scheme
## push_scope = agent_slot
alias[effect:every_scheme_agent_slot] = single_alias_right[every_effect]

### Iterate through all characters in agent slots in the scheme
### ordered_scheme_agent_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = scheme
## push_scope = character
alias[effect:ordered_scheme_agent_character] = single_alias_right[ordered_effect]

### Iterate through all agent slots in the scheme
### ordered_scheme_agent_slot = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = scheme
## push_scope = agent_slot
alias[effect:ordered_scheme_agent_slot] = single_alias_right[ordered_effect]

### Iterate through all characters in agent slots in the scheme
### random_scheme_agent_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = scheme
## push_scope = character
alias[effect:random_scheme_agent_character] = single_alias_right[random_effect]

### Iterate through all agent slots in the scheme
### random_scheme_agent_slot = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = scheme
## push_scope = agent_slot
alias[effect:random_scheme_agent_slot] = single_alias_right[random_effect]

### Iterate through all acclaimed knights employed by a given character
### every_acclaimed_knight = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_acclaimed_knight] = single_alias_right[every_effect]

### Iterate through all ( active and inactive ) Accolades of a given liege character's Acclaimed Knights
### every_accolade = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = accolade
alias[effect:every_accolade] = single_alias_right[every_effect]

### Iterate through all active Accolades of a given liege character's Acclaimed Knights
### every_active_accolade = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = accolade
alias[effect:every_active_accolade] = single_alias_right[every_effect]

### Iterate through all titles that can be created by the character. (only for alerts)
### every_alert_creatable_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_alert_creatable_title] = single_alias_right[every_effect]

### Iterate through all titles that can be usurped by the character. (only for alerts)
### every_alert_usurpable_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_alert_usurpable_title] = single_alias_right[every_effect]

### Iterate through all allies
### every_ally = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_ally] = single_alias_right[every_effect]

### Iterate through all armies
### every_army = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = army
alias[effect:every_army] = single_alias_right[every_effect]

### Iterate through all task contracts of location of root province
### every_available_task_contract = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = task_contract
alias[effect:every_available_task_contract] = single_alias_right[every_effect]

### Gets all accepted task contracts of the root character
### every_character_active_contract = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = task_contract
alias[effect:every_character_active_contract] = single_alias_right[every_effect]

### Iterate through all artifacts in a given characters inventory
### every_character_artifact = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = artifact
alias[effect:every_character_artifact] = single_alias_right[every_effect]

### Gets epidemics affecting the scoped character
### every_character_epidemic = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = epidemic
alias[effect:every_character_epidemic] = single_alias_right[every_effect]

### Iterate through all situations that a character is participating in
### every_character_situation = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = situation
alias[effect:every_character_situation] = single_alias_right[every_effect]

### Gets all task contracts of the scoped character
### every_character_task_contract = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = task_contract
alias[effect:every_character_task_contract] = single_alias_right[every_effect]

### Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)
### every_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_and_across_water_county] = single_alias_right[every_effect]

### Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
### every_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_and_across_water_duchy] = single_alias_right[every_effect]

### Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)
### every_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_and_across_water_empire] = single_alias_right[every_effect]

### Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
### every_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_and_across_water_kingdom] = single_alias_right[every_effect]

### Scopes from a character to a neighboring county (looking trough the de Jure lieges)
### every_character_to_title_neighboring_county = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_county] = single_alias_right[every_effect]

### Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)
### every_character_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_duchy] = single_alias_right[every_effect]

### Scopes from a character to a neighboring empire (looking trough the de Jure lieges)
### every_character_to_title_neighboring_empire = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_empire] = single_alias_right[every_effect]

### Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)
### every_character_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_character_to_title_neighboring_kingdom] = single_alias_right[every_effect]

### Iterate through all traits a character has
### every_character_trait = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = trait
alias[effect:every_character_trait] = single_alias_right[every_effect]

### Wars of the scoped character
### every_character_war = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = war
alias[effect:every_character_war] = single_alias_right[every_effect]

### Iterate through all claimed artifacts of the scoped character
### every_claimed_artifact = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = artifact
alias[effect:every_claimed_artifact] = single_alias_right[every_effect]

### Iterate through all concubines
### every_concubine = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_concubine] = single_alias_right[every_effect]

### Iterate through all consorts (concubines and spouses)
### every_consort = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_consort] = single_alias_right[every_effect]

### Iterate through all contact characters of the root character
### every_contact = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_contact] = single_alias_right[every_effect]

### Iterate through all councillors
### every_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_councillor] = single_alias_right[every_effect]

### Iterate through all valid candidates for a court position type.
### *_court_position_candidate = {
###    court_position = bodyguard_court_position
### 
### OR
###    court_position = scope:my_scoped_court_position_type
###    ...
### }
### every_court_position_candidate = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_court_position_candidate] = single_alias_right[every_effect]

### Iterates through all characters that employ the scoped character in any court position.
### every_court_position_employer = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_court_position_employer] = single_alias_right[every_effect]

### Iterate through all courtiers
### every_courtier = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_courtier] = single_alias_right[every_effect]

### Iterate through all courtiers that are away
### every_courtier_away = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_courtier_away] = single_alias_right[every_effect]

### Iterate through all courtiers and guests (pool and foreign court guests)
### every_courtier_or_guest = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_courtier_or_guest] = single_alias_right[every_effect]

### Iterate through all de jure claims for a character
### every_de_jure_claim = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_de_jure_claim] = single_alias_right[every_effect]

### Iterate through all character in the diarchy line of succession.If there's no active diarchy or active one doesn't have succession,it iterates over regency candidates
### every_diarchy_succession_character = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_diarchy_succession_character] = single_alias_right[every_effect]

### Iterate through all diplomacy-based councillors
### every_diplomacy_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_diplomacy_councillor] = single_alias_right[every_effect]

### Iterate through all directly owned provinces
### every_directly_owned_province = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = province
alias[effect:every_directly_owned_province] = single_alias_right[every_effect]

### Iterate through all titles the scoped character can vote on
### every_election_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_election_title] = single_alias_right[every_effect]

### Iterate through all equipped artifacts in a given characters inventory
### every_equipped_character_artifact = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = artifact
alias[effect:every_equipped_character_artifact] = single_alias_right[every_effect]

### Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]
### every_extended_family_member = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_extended_family_member] = single_alias_right[every_effect]

### Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)
### every_foreign_court_guest = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_foreign_court_guest] = single_alias_right[every_effect]

### Iterate through all former concubines. Not persisted past death
### every_former_concubine = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_former_concubine] = single_alias_right[every_effect]

### Iterate through all former concubinists. Not persisted past death
### every_former_concubinist = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_former_concubinist] = single_alias_right[every_effect]

### Iterate through all councillors that are not related to a skill
### every_general_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_general_councillor] = single_alias_right[every_effect]

### Heirs of the scoped character
### every_heir = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_heir] = single_alias_right[every_effect]

### Iterate through all titles the scoped character is heir to
### every_heir_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_heir_title] = single_alias_right[every_effect]

### Iterate through all held landed titles
### every_held_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_held_title] = single_alias_right[every_effect]

### Iterate through all hired mercenary companies
### every_hired_mercenary = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = mercenary_company
alias[effect:every_hired_mercenary] = single_alias_right[every_effect]

### Iterate through all hostages currently abroad
### every_home_court_hostage = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_home_court_hostage] = single_alias_right[every_effect]

### Iterate through all characters this character has a hook on
### every_hooked_character = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_hooked_character] = single_alias_right[every_effect]

### Iterate through anyone the character is hostile to due to their top-liege's realm having been raided
### every_hostile_raider = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_hostile_raider] = single_alias_right[every_effect]

### Iterate through all intrigue-based councillors
### every_intrigue_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_intrigue_councillor] = single_alias_right[every_effect]

### Iterate through all activities a character has been invited to
### every_invited_activity = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = activity
alias[effect:every_invited_activity] = single_alias_right[every_effect]

### Iterate through all knights
### every_knight = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_knight] = single_alias_right[every_effect]

### Iterate through all secrets known by the character
### every_known_secret = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = secret
alias[effect:every_known_secret] = single_alias_right[every_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.
### every_land_neighboring_realm_with_tributaries = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_land_neighboring_realm_with_tributaries] = single_alias_right[every_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.
### every_land_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_land_neighboring_realm_with_tributaries_owner] = single_alias_right[every_effect]

### Iterate through all learning-based councillors
### every_learning_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_learning_councillor] = single_alias_right[every_effect]

### Iterate through all lieges above a character (skipping the character themselves)
### every_liege_or_above = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_liege_or_above] = single_alias_right[every_effect]

### Iterate through all MaA regiments
### every_maa_regiment = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = regiment
alias[effect:every_maa_regiment] = single_alias_right[every_effect]

### Iterate through all martial-based councillors
### every_martial_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_martial_councillor] = single_alias_right[every_effect]

### Iterate through all memories of a character
### every_memory = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character_memory
alias[effect:every_memory] = single_alias_right[every_effect]

### A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
### every_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_neighboring_and_across_water_realm_same_rank_owner] = single_alias_right[every_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
### every_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_neighboring_and_across_water_top_liege_realm] = single_alias_right[every_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
### every_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_neighboring_and_across_water_top_liege_realm_owner] = single_alias_right[every_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
### every_neighboring_and_across_water_top_suzerain_realm = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_neighboring_and_across_water_top_suzerain_realm] = single_alias_right[every_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
### every_neighboring_and_across_water_top_suzerain_realm_owner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_neighboring_and_across_water_top_suzerain_realm_owner] = single_alias_right[every_effect]

### A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
### every_neighboring_realm_same_rank_owner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_neighboring_realm_same_rank_owner] = single_alias_right[every_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date
### every_neighboring_top_liege_realm = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_neighboring_top_liege_realm] = single_alias_right[every_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date
### every_neighboring_top_liege_realm_owner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_neighboring_top_liege_realm_owner] = single_alias_right[every_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the realm's top title. Can be based on borders a day or two out of date
### every_neighboring_top_suzerain_realm = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_neighboring_top_suzerain_realm] = single_alias_right[every_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date
### every_neighboring_top_suzerain_realm_owner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_neighboring_top_suzerain_realm_owner] = single_alias_right[every_effect]

### Iterate through all noble family titles in the realm of scoped character
### every_noble_family = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_noble_family] = single_alias_right[every_effect]

### Iterate through all the spouse candidates of the opposite sex of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### every_opposite_sex_spouse_candidate = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_opposite_sex_spouse_candidate] = single_alias_right[every_effect]

### Iterate through all owned stories for a character
### every_owned_story = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = story
alias[effect:every_owned_story] = single_alias_right[every_effect]

### Iterate through all holy orders that the scoped character is a patron of
### every_patroned_holy_order = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = holy_order
alias[effect:every_patroned_holy_order] = single_alias_right[every_effect]

### Iterate through all personally claimed artifacts of the scoped character
### every_personal_claimed_artifact = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = artifact
alias[effect:every_personal_claimed_artifact] = single_alias_right[every_effect]

### Iterate through characters this player has pinned
### every_pinned_character = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_pinned_character] = single_alias_right[every_effect]

### Iterate through characters whose player has this character pinned
### every_pinning_character = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_pinning_character] = single_alias_right[every_effect]

### Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character
### every_played_character = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_played_character] = single_alias_right[every_effect]

### Iterate through player heirs, capped at the first 10
### every_player_heir = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_player_heir] = single_alias_right[every_effect]

### Get all legends in a player character library.
### every_player_legend_library = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = legend
alias[effect:every_player_legend_library] = single_alias_right[every_effect]

### Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)
### every_pool_guest = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_pool_guest] = single_alias_right[every_effect]

### Iterate through all potential selectable marriage or betrohed options
### every_potential_marriage_option = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_potential_marriage_option] = single_alias_right[every_effect]

### Iterate through all directly owned provinces
### every_powerful_family = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = dynasty_house
alias[effect:every_powerful_family] = single_alias_right[every_effect]

### Iterate through the all powerful vassals of a character
### every_powerful_vassal = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_powerful_vassal] = single_alias_right[every_effect]

### Iterate through all landed titles character is pretender to
### every_pretender_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_pretender_title] = single_alias_right[every_effect]

### Iterate through all primary war enemies
### every_primary_war_enemy = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_primary_war_enemy] = single_alias_right[every_effect]

### Iterate through all prisoners
### every_prisoner = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_prisoner] = single_alias_right[every_effect]

### Iterate through all prowess-based councillors
### every_prowess_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_prowess_councillor] = single_alias_right[every_effect]

### Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges
### every_raid_target = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_raid_target] = single_alias_right[every_effect]

### Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.
### every_realm_border_county = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_realm_border_county] = single_alias_right[every_effect]

### Iterate through all counties in the realm. Based on top liege
### every_realm_county = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_realm_county] = single_alias_right[every_effect]

### Iterate through all de jure duchies that have at least one county in the realm. Based on top liege
### every_realm_de_jure_duchy = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_realm_de_jure_duchy] = single_alias_right[every_effect]

### Iterate through all de jure empire that have at least one county in the realm. Based on top liege
### every_realm_de_jure_empire = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_realm_de_jure_empire] = single_alias_right[every_effect]

### Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege
### every_realm_de_jure_kingdom = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_realm_de_jure_kingdom] = single_alias_right[every_effect]

### Iterate through all realm provinces of a character
### every_realm_province = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = province
alias[effect:every_realm_province] = single_alias_right[every_effect]

### Iterate through all the spouse candidates of the same sex of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### every_same_sex_spouse_candidate = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_same_sex_spouse_candidate] = single_alias_right[every_effect]

### Iterate through all schemes owned by the character
### every_scheme = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = scheme
alias[effect:every_scheme] = single_alias_right[every_effect]

### Iterate through all secrets of the character
### every_secret = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = secret
alias[effect:every_secret] = single_alias_right[every_effect]

### Iterate through all siblings
### every_sibling = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_sibling] = single_alias_right[every_effect]

### Iterate through all sponsored inspirations
### every_sponsored_inspiration = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = inspiration
alias[effect:every_sponsored_inspiration] = single_alias_right[every_effect]

### Iterate through all the spouse candidates of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### every_spouse_candidate = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_spouse_candidate] = single_alias_right[every_effect]

### Iterate through all stewardship-based councillors
### every_stewardship_councillor = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_stewardship_councillor] = single_alias_right[every_effect]

### Iterate through all baronies in sub-realm
### every_sub_realm_barony = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_sub_realm_barony] = single_alias_right[every_effect]

### Iterate through all counties in sub-realm
### every_sub_realm_county = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_sub_realm_county] = single_alias_right[every_effect]

### Iterate through all duchies in sub-realm
### every_sub_realm_duchy = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_sub_realm_duchy] = single_alias_right[every_effect]

### Iterate through all empires in sub-realm
### every_sub_realm_empire = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_sub_realm_empire] = single_alias_right[every_effect]

### Iterate through all kingdoms in sub-realm
### every_sub_realm_kingdom = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_sub_realm_kingdom] = single_alias_right[every_effect]

### Iterate through all titles in sub-realm
### every_sub_realm_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_sub_realm_title] = single_alias_right[every_effect]

### Iterate through all candidates supported by the scoped investor character for any title
### It may contain people outside of investor's top realm or no longer valid for appointment
### every_succession_appointment_invested_candidate = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_succession_appointment_invested_candidate] = single_alias_right[every_effect]

### Iterate through all titles that has candidates supported by the scoped investor
### It may contain titles outside of investor's top realm, and so invalid for appointment,
### and candidates may be already dead
### every_succession_appointment_invested_title = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_succession_appointment_invested_title] = single_alias_right[every_effect]

### Iterate through all factions targeting the scope character
### every_targeting_faction = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = faction
alias[effect:every_targeting_faction] = single_alias_right[every_effect]

### Iterate through all schemes targeting the character
### every_targeting_scheme = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = scheme
alias[effect:every_targeting_scheme] = single_alias_right[every_effect]

### Iterate through all secrets that target the specified scope
### every_targeting_secret = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = secret
alias[effect:every_targeting_secret] = single_alias_right[every_effect]

### Iterates through all Tax Collectors employed by the scoped character
### every_tax_collector = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_tax_collector] = single_alias_right[every_effect]

### Iterates through all Vassals the scoped Character is the Tax Collector for
### every_tax_collector_vassal = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_tax_collector_vassal] = single_alias_right[every_effect]

### Iterates through all Tax Slots the scoped character has
### every_tax_slot = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = tax_slot
alias[effect:every_tax_slot] = single_alias_right[every_effect]

### Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.
### every_top_realm_border_county = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:every_top_realm_border_county] = single_alias_right[every_effect]

### Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character
### every_traveling_family_member = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_traveling_family_member] = single_alias_right[every_effect]

### Iterate through all tributaries
### every_tributary = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_tributary] = single_alias_right[every_effect]

### Iterate through all characters that have a truce on this character
### every_truce_holder = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_truce_holder] = single_alias_right[every_effect]

### Iterate through all characters this character has a truce on
### every_truce_target = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_truce_target] = single_alias_right[every_effect]

### Iterates through all unassigned taxpayers for scoped Character
### every_unassigned_taxpayers = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_unassigned_taxpayers] = single_alias_right[every_effect]

### Iterate through all unspent secrets known by the character
### every_unspent_known_secret = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = secret
alias[effect:every_unspent_known_secret] = single_alias_right[every_effect]

### Iterate through all DIRECT vassals
### every_vassal = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_vassal] = single_alias_right[every_effect]

### Iterate through ALL vassals, not just direct vassals
### every_vassal_or_below = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_vassal_or_below] = single_alias_right[every_effect]

### Iterate through all direct war allies
### every_war_ally = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_war_ally] = single_alias_right[every_effect]

### Iterate through all direct war enemies
### every_war_enemy = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_war_enemy] = single_alias_right[every_effect]

### Iterate through all hostages having this warden
### every_warden_hostage = { limit = { <triggers> } <effects> }
## scope = character
## push_scope = character
alias[effect:every_warden_hostage] = single_alias_right[every_effect]

### Iterate through all acclaimed knights employed by a given character
### ordered_acclaimed_knight = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_acclaimed_knight] = single_alias_right[ordered_effect]

### Iterate through all ( active and inactive ) Accolades of a given liege character's Acclaimed Knights
### ordered_accolade = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = accolade
alias[effect:ordered_accolade] = single_alias_right[ordered_effect]

### Iterate through all active Accolades of a given liege character's Acclaimed Knights
### ordered_active_accolade = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = accolade
alias[effect:ordered_active_accolade] = single_alias_right[ordered_effect]

### Iterate through all titles that can be created by the character. (only for alerts)
### ordered_alert_creatable_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_alert_creatable_title] = single_alias_right[ordered_effect]

### Iterate through all titles that can be usurped by the character. (only for alerts)
### ordered_alert_usurpable_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_alert_usurpable_title] = single_alias_right[ordered_effect]

### Iterate through all allies
### ordered_ally = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_ally] = single_alias_right[ordered_effect]

### Iterate through all armies
### ordered_army = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = army
alias[effect:ordered_army] = single_alias_right[ordered_effect]

### Iterate through all task contracts of location of root province
### ordered_available_task_contract = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = task_contract
alias[effect:ordered_available_task_contract] = single_alias_right[ordered_effect]

### Gets all accepted task contracts of the root character
### ordered_character_active_contract = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = task_contract
alias[effect:ordered_character_active_contract] = single_alias_right[ordered_effect]

### Iterate through all artifacts in a given characters inventory
### ordered_character_artifact = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = artifact
alias[effect:ordered_character_artifact] = single_alias_right[ordered_effect]

### Gets epidemics affecting the scoped character
### ordered_character_epidemic = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = epidemic
alias[effect:ordered_character_epidemic] = single_alias_right[ordered_effect]

### Iterate through all situations that a character is participating in
### ordered_character_situation = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = situation
alias[effect:ordered_character_situation] = single_alias_right[ordered_effect]

### Gets all task contracts of the scoped character
### ordered_character_task_contract = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = task_contract
alias[effect:ordered_character_task_contract] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_and_across_water_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_and_across_water_county] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_and_across_water_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_and_across_water_duchy] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_and_across_water_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_and_across_water_empire] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_and_across_water_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_and_across_water_kingdom] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring county (looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_county] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_duchy] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring empire (looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_empire] = single_alias_right[ordered_effect]

### Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)
### ordered_character_to_title_neighboring_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_character_to_title_neighboring_kingdom] = single_alias_right[ordered_effect]

### Iterate through all traits a character has
### ordered_character_trait = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = trait
alias[effect:ordered_character_trait] = single_alias_right[ordered_effect]

### Wars of the scoped character
### ordered_character_war = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = war
alias[effect:ordered_character_war] = single_alias_right[ordered_effect]

### Iterate through all claimed artifacts of the scoped character
### ordered_claimed_artifact = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = artifact
alias[effect:ordered_claimed_artifact] = single_alias_right[ordered_effect]

### Iterate through all concubines
### ordered_concubine = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_concubine] = single_alias_right[ordered_effect]

### Iterate through all consorts (concubines and spouses)
### ordered_consort = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_consort] = single_alias_right[ordered_effect]

### Iterate through all contact characters of the root character
### ordered_contact = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_contact] = single_alias_right[ordered_effect]

### Iterate through all councillors
### ordered_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_councillor] = single_alias_right[ordered_effect]

### Iterate through all valid candidates for a court position type.
### *_court_position_candidate = {
###    court_position = bodyguard_court_position
### 
### OR
###    court_position = scope:my_scoped_court_position_type
###    ...
### }
### ordered_court_position_candidate = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_court_position_candidate] = single_alias_right[ordered_effect]

### Iterates through all characters that employ the scoped character in any court position.
### ordered_court_position_employer = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_court_position_employer] = single_alias_right[ordered_effect]

### Iterate through all courtiers
### ordered_courtier = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_courtier] = single_alias_right[ordered_effect]

### Iterate through all courtiers that are away
### ordered_courtier_away = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_courtier_away] = single_alias_right[ordered_effect]

### Iterate through all courtiers and guests (pool and foreign court guests)
### ordered_courtier_or_guest = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_courtier_or_guest] = single_alias_right[ordered_effect]

### Iterate through all de jure claims for a character
### ordered_de_jure_claim = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_de_jure_claim] = single_alias_right[ordered_effect]

### Iterate through all character in the diarchy line of succession.If there's no active diarchy or active one doesn't have succession,it iterates over regency candidates
### ordered_diarchy_succession_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_diarchy_succession_character] = single_alias_right[ordered_effect]

### Iterate through all diplomacy-based councillors
### ordered_diplomacy_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_diplomacy_councillor] = single_alias_right[ordered_effect]

### Iterate through all directly owned provinces
### ordered_directly_owned_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = province
alias[effect:ordered_directly_owned_province] = single_alias_right[ordered_effect]

### Iterate through all titles the scoped character can vote on
### ordered_election_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_election_title] = single_alias_right[ordered_effect]

### Iterate through all equipped artifacts in a given characters inventory
### ordered_equipped_character_artifact = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = artifact
alias[effect:ordered_equipped_character_artifact] = single_alias_right[ordered_effect]

### Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]
### ordered_extended_family_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_extended_family_member] = single_alias_right[ordered_effect]

### Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)
### ordered_foreign_court_guest = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_foreign_court_guest] = single_alias_right[ordered_effect]

### Iterate through all former concubines. Not persisted past death
### ordered_former_concubine = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_former_concubine] = single_alias_right[ordered_effect]

### Iterate through all former concubinists. Not persisted past death
### ordered_former_concubinist = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_former_concubinist] = single_alias_right[ordered_effect]

### Iterate through all councillors that are not related to a skill
### ordered_general_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_general_councillor] = single_alias_right[ordered_effect]

### Heirs of the scoped character
### ordered_heir = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_heir] = single_alias_right[ordered_effect]

### Iterate through all titles the scoped character is heir to
### ordered_heir_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_heir_title] = single_alias_right[ordered_effect]

### Iterate through all held landed titles
### ordered_held_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_held_title] = single_alias_right[ordered_effect]

### Iterate through all hired mercenary companies
### ordered_hired_mercenary = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = mercenary_company
alias[effect:ordered_hired_mercenary] = single_alias_right[ordered_effect]

### Iterate through all hostages currently abroad
### ordered_home_court_hostage = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_home_court_hostage] = single_alias_right[ordered_effect]

### Iterate through all characters this character has a hook on
### ordered_hooked_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_hooked_character] = single_alias_right[ordered_effect]

### Iterate through anyone the character is hostile to due to their top-liege's realm having been raided
### ordered_hostile_raider = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_hostile_raider] = single_alias_right[ordered_effect]

### Iterate through all intrigue-based councillors
### ordered_intrigue_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_intrigue_councillor] = single_alias_right[ordered_effect]

### Iterate through all activities a character has been invited to
### ordered_invited_activity = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = activity
alias[effect:ordered_invited_activity] = single_alias_right[ordered_effect]

### Iterate through all knights
### ordered_knight = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_knight] = single_alias_right[ordered_effect]

### Iterate through all secrets known by the character
### ordered_known_secret = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = secret
alias[effect:ordered_known_secret] = single_alias_right[ordered_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.
### ordered_land_neighboring_realm_with_tributaries = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_land_neighboring_realm_with_tributaries] = single_alias_right[ordered_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.
### ordered_land_neighboring_realm_with_tributaries_owner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_land_neighboring_realm_with_tributaries_owner] = single_alias_right[ordered_effect]

### Iterate through all learning-based councillors
### ordered_learning_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_learning_councillor] = single_alias_right[ordered_effect]

### Iterate through all lieges above a character (skipping the character themselves)
### ordered_liege_or_above = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_liege_or_above] = single_alias_right[ordered_effect]

### Iterate through all MaA regiments
### ordered_maa_regiment = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = regiment
alias[effect:ordered_maa_regiment] = single_alias_right[ordered_effect]

### Iterate through all martial-based councillors
### ordered_martial_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_martial_councillor] = single_alias_right[ordered_effect]

### Iterate through all memories of a character
### ordered_memory = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character_memory
alias[effect:ordered_memory] = single_alias_right[ordered_effect]

### A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
### ordered_neighboring_and_across_water_realm_same_rank_owner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_neighboring_and_across_water_realm_same_rank_owner] = single_alias_right[ordered_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
### ordered_neighboring_and_across_water_top_liege_realm = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_neighboring_and_across_water_top_liege_realm] = single_alias_right[ordered_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
### ordered_neighboring_and_across_water_top_liege_realm_owner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_neighboring_and_across_water_top_liege_realm_owner] = single_alias_right[ordered_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
### ordered_neighboring_and_across_water_top_suzerain_realm = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_neighboring_and_across_water_top_suzerain_realm] = single_alias_right[ordered_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
### ordered_neighboring_and_across_water_top_suzerain_realm_owner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_neighboring_and_across_water_top_suzerain_realm_owner] = single_alias_right[ordered_effect]

### A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
### ordered_neighboring_realm_same_rank_owner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_neighboring_realm_same_rank_owner] = single_alias_right[ordered_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date
### ordered_neighboring_top_liege_realm = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_neighboring_top_liege_realm] = single_alias_right[ordered_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date
### ordered_neighboring_top_liege_realm_owner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_neighboring_top_liege_realm_owner] = single_alias_right[ordered_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the realm's top title. Can be based on borders a day or two out of date
### ordered_neighboring_top_suzerain_realm = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_neighboring_top_suzerain_realm] = single_alias_right[ordered_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date
### ordered_neighboring_top_suzerain_realm_owner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_neighboring_top_suzerain_realm_owner] = single_alias_right[ordered_effect]

### Iterate through all noble family titles in the realm of scoped character
### ordered_noble_family = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_noble_family] = single_alias_right[ordered_effect]

### Iterate through all the spouse candidates of the opposite sex of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### ordered_opposite_sex_spouse_candidate = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_opposite_sex_spouse_candidate] = single_alias_right[ordered_effect]

### Iterate through all owned stories for a character
### ordered_owned_story = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = story
alias[effect:ordered_owned_story] = single_alias_right[ordered_effect]

### Iterate through all holy orders that the scoped character is a patron of
### ordered_patroned_holy_order = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = holy_order
alias[effect:ordered_patroned_holy_order] = single_alias_right[ordered_effect]

### Iterate through all personally claimed artifacts of the scoped character
### ordered_personal_claimed_artifact = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = artifact
alias[effect:ordered_personal_claimed_artifact] = single_alias_right[ordered_effect]

### Iterate through characters this player has pinned
### ordered_pinned_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_pinned_character] = single_alias_right[ordered_effect]

### Iterate through characters whose player has this character pinned
### ordered_pinning_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_pinning_character] = single_alias_right[ordered_effect]

### Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character
### ordered_played_character = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_played_character] = single_alias_right[ordered_effect]

### Iterate through player heirs, capped at the first 10
### ordered_player_heir = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_player_heir] = single_alias_right[ordered_effect]

### Get all legends in a player character library.
### ordered_player_legend_library = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = legend
alias[effect:ordered_player_legend_library] = single_alias_right[ordered_effect]

### Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)
### ordered_pool_guest = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_pool_guest] = single_alias_right[ordered_effect]

### Iterate through all potential selectable marriage or betrohed options
### ordered_potential_marriage_option = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_potential_marriage_option] = single_alias_right[ordered_effect]

### Iterate through all directly owned provinces
### ordered_powerful_family = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = dynasty_house
alias[effect:ordered_powerful_family] = single_alias_right[ordered_effect]

### Iterate through the all powerful vassals of a character
### ordered_powerful_vassal = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_powerful_vassal] = single_alias_right[ordered_effect]

### Iterate through all landed titles character is pretender to
### ordered_pretender_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_pretender_title] = single_alias_right[ordered_effect]

### Iterate through all primary war enemies
### ordered_primary_war_enemy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_primary_war_enemy] = single_alias_right[ordered_effect]

### Iterate through all prisoners
### ordered_prisoner = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_prisoner] = single_alias_right[ordered_effect]

### Iterate through all prowess-based councillors
### ordered_prowess_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_prowess_councillor] = single_alias_right[ordered_effect]

### Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges
### ordered_raid_target = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_raid_target] = single_alias_right[ordered_effect]

### Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.
### ordered_realm_border_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_realm_border_county] = single_alias_right[ordered_effect]

### Iterate through all counties in the realm. Based on top liege
### ordered_realm_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_realm_county] = single_alias_right[ordered_effect]

### Iterate through all de jure duchies that have at least one county in the realm. Based on top liege
### ordered_realm_de_jure_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_realm_de_jure_duchy] = single_alias_right[ordered_effect]

### Iterate through all de jure empire that have at least one county in the realm. Based on top liege
### ordered_realm_de_jure_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_realm_de_jure_empire] = single_alias_right[ordered_effect]

### Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege
### ordered_realm_de_jure_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_realm_de_jure_kingdom] = single_alias_right[ordered_effect]

### Iterate through all realm provinces of a character
### ordered_realm_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = province
alias[effect:ordered_realm_province] = single_alias_right[ordered_effect]

### Iterate through all the spouse candidates of the same sex of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### ordered_same_sex_spouse_candidate = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_same_sex_spouse_candidate] = single_alias_right[ordered_effect]

### Iterate through all schemes owned by the character
### ordered_scheme = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = scheme
alias[effect:ordered_scheme] = single_alias_right[ordered_effect]

### Iterate through all secrets of the character
### ordered_secret = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = secret
alias[effect:ordered_secret] = single_alias_right[ordered_effect]

### Iterate through all siblings
### ordered_sibling = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_sibling] = single_alias_right[ordered_effect]

### Iterate through all sponsored inspirations
### ordered_sponsored_inspiration = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = inspiration
alias[effect:ordered_sponsored_inspiration] = single_alias_right[ordered_effect]

### Iterate through all the spouse candidates of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### ordered_spouse_candidate = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_spouse_candidate] = single_alias_right[ordered_effect]

### Iterate through all stewardship-based councillors
### ordered_stewardship_councillor = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_stewardship_councillor] = single_alias_right[ordered_effect]

### Iterate through all baronies in sub-realm
### ordered_sub_realm_barony = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_sub_realm_barony] = single_alias_right[ordered_effect]

### Iterate through all counties in sub-realm
### ordered_sub_realm_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_sub_realm_county] = single_alias_right[ordered_effect]

### Iterate through all duchies in sub-realm
### ordered_sub_realm_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_sub_realm_duchy] = single_alias_right[ordered_effect]

### Iterate through all empires in sub-realm
### ordered_sub_realm_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_sub_realm_empire] = single_alias_right[ordered_effect]

### Iterate through all kingdoms in sub-realm
### ordered_sub_realm_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_sub_realm_kingdom] = single_alias_right[ordered_effect]

### Iterate through all titles in sub-realm
### ordered_sub_realm_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_sub_realm_title] = single_alias_right[ordered_effect]

### Iterate through all candidates supported by the scoped investor character for any title
### It may contain people outside of investor's top realm or no longer valid for appointment
### ordered_succession_appointment_invested_candidate = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_succession_appointment_invested_candidate] = single_alias_right[ordered_effect]

### Iterate through all titles that has candidates supported by the scoped investor
### It may contain titles outside of investor's top realm, and so invalid for appointment,
### and candidates may be already dead
### ordered_succession_appointment_invested_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_succession_appointment_invested_title] = single_alias_right[ordered_effect]

### Iterate through all factions targeting the scope character
### ordered_targeting_faction = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = faction
alias[effect:ordered_targeting_faction] = single_alias_right[ordered_effect]

### Iterate through all schemes targeting the character
### ordered_targeting_scheme = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = scheme
alias[effect:ordered_targeting_scheme] = single_alias_right[ordered_effect]

### Iterate through all secrets that target the specified scope
### ordered_targeting_secret = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = secret
alias[effect:ordered_targeting_secret] = single_alias_right[ordered_effect]

### Iterates through all Tax Collectors employed by the scoped character
### ordered_tax_collector = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_tax_collector] = single_alias_right[ordered_effect]

### Iterates through all Vassals the scoped Character is the Tax Collector for
### ordered_tax_collector_vassal = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_tax_collector_vassal] = single_alias_right[ordered_effect]

### Iterates through all Tax Slots the scoped character has
### ordered_tax_slot = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = tax_slot
alias[effect:ordered_tax_slot] = single_alias_right[ordered_effect]

### Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.
### ordered_top_realm_border_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = landed_title
alias[effect:ordered_top_realm_border_county] = single_alias_right[ordered_effect]

### Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character
### ordered_traveling_family_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_traveling_family_member] = single_alias_right[ordered_effect]

### Iterate through all tributaries
### ordered_tributary = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_tributary] = single_alias_right[ordered_effect]

### Iterate through all characters that have a truce on this character
### ordered_truce_holder = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_truce_holder] = single_alias_right[ordered_effect]

### Iterate through all characters this character has a truce on
### ordered_truce_target = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_truce_target] = single_alias_right[ordered_effect]

### Iterates through all unassigned taxpayers for scoped Character
### ordered_unassigned_taxpayers = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_unassigned_taxpayers] = single_alias_right[ordered_effect]

### Iterate through all unspent secrets known by the character
### ordered_unspent_known_secret = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = secret
alias[effect:ordered_unspent_known_secret] = single_alias_right[ordered_effect]

### Iterate through all DIRECT vassals
### ordered_vassal = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_vassal] = single_alias_right[ordered_effect]

### Iterate through ALL vassals, not just direct vassals
### ordered_vassal_or_below = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_vassal_or_below] = single_alias_right[ordered_effect]

### Iterate through all direct war allies
### ordered_war_ally = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_war_ally] = single_alias_right[ordered_effect]

### Iterate through all direct war enemies
### ordered_war_enemy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_war_enemy] = single_alias_right[ordered_effect]

### Iterate through all hostages having this warden
### ordered_warden_hostage = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = character
## push_scope = character
alias[effect:ordered_warden_hostage] = single_alias_right[ordered_effect]

### Iterate through all acclaimed knights employed by a given character
### random_acclaimed_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_acclaimed_knight] = single_alias_right[random_effect]

### Iterate through all ( active and inactive ) Accolades of a given liege character's Acclaimed Knights
### random_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = accolade
alias[effect:random_accolade] = single_alias_right[random_effect]

### Iterate through all active Accolades of a given liege character's Acclaimed Knights
### random_active_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = accolade
alias[effect:random_active_accolade] = single_alias_right[random_effect]

### Iterate through all titles that can be created by the character. (only for alerts)
### random_alert_creatable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_alert_creatable_title] = single_alias_right[random_effect]

### Iterate through all titles that can be usurped by the character. (only for alerts)
### random_alert_usurpable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_alert_usurpable_title] = single_alias_right[random_effect]

### Iterate through all allies
### random_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_ally] = single_alias_right[random_effect]

### Iterate through all armies
### random_army = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = army
alias[effect:random_army] = single_alias_right[random_effect]

### Iterate through all task contracts of location of root province
### random_available_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = task_contract
alias[effect:random_available_task_contract] = single_alias_right[random_effect]

### Gets all accepted task contracts of the root character
### random_character_active_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = task_contract
alias[effect:random_character_active_contract] = single_alias_right[random_effect]

### Iterate through all artifacts in a given characters inventory
### random_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = artifact
alias[effect:random_character_artifact] = single_alias_right[random_effect]

### Gets epidemics affecting the scoped character
### random_character_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = epidemic
alias[effect:random_character_epidemic] = single_alias_right[random_effect]

### Iterate through all situations that a character is participating in
### random_character_situation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = situation
alias[effect:random_character_situation] = single_alias_right[random_effect]

### Gets all task contracts of the scoped character
### random_character_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = task_contract
alias[effect:random_character_task_contract] = single_alias_right[random_effect]

### Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)
### random_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_and_across_water_county] = single_alias_right[random_effect]

### Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
### random_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_and_across_water_duchy] = single_alias_right[random_effect]

### Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)
### random_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_and_across_water_empire] = single_alias_right[random_effect]

### Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
### random_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_and_across_water_kingdom] = single_alias_right[random_effect]

### Scopes from a character to a neighboring county (looking trough the de Jure lieges)
### random_character_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_county] = single_alias_right[random_effect]

### Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)
### random_character_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_duchy] = single_alias_right[random_effect]

### Scopes from a character to a neighboring empire (looking trough the de Jure lieges)
### random_character_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_empire] = single_alias_right[random_effect]

### Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)
### random_character_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_character_to_title_neighboring_kingdom] = single_alias_right[random_effect]

### Iterate through all traits a character has
### random_character_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = trait
alias[effect:random_character_trait] = single_alias_right[random_effect]

### Wars of the scoped character
### random_character_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = war
alias[effect:random_character_war] = single_alias_right[random_effect]

### Iterate through all claimed artifacts of the scoped character
### random_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = artifact
alias[effect:random_claimed_artifact] = single_alias_right[random_effect]

### Iterate through all concubines
### random_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_concubine] = single_alias_right[random_effect]

### Iterate through all consorts (concubines and spouses)
### random_consort = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_consort] = single_alias_right[random_effect]

### Iterate through all contact characters of the root character
### random_contact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_contact] = single_alias_right[random_effect]

### Iterate through all councillors
### random_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_councillor] = single_alias_right[random_effect]

### Iterate through all valid candidates for a court position type.
### *_court_position_candidate = {
###    court_position = bodyguard_court_position
### 
### OR
###    court_position = scope:my_scoped_court_position_type
###    ...
### }
### random_court_position_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_court_position_candidate] = single_alias_right[random_effect]

### Iterates through all characters that employ the scoped character in any court position.
### random_court_position_employer = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_court_position_employer] = single_alias_right[random_effect]

### Iterate through all courtiers
### random_courtier = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_courtier] = single_alias_right[random_effect]

### Iterate through all courtiers that are away
### random_courtier_away = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_courtier_away] = single_alias_right[random_effect]

### Iterate through all courtiers and guests (pool and foreign court guests)
### random_courtier_or_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_courtier_or_guest] = single_alias_right[random_effect]

### Iterate through all de jure claims for a character
### random_de_jure_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_de_jure_claim] = single_alias_right[random_effect]

### Iterate through all character in the diarchy line of succession.If there's no active diarchy or active one doesn't have succession,it iterates over regency candidates
### random_diarchy_succession_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_diarchy_succession_character] = single_alias_right[random_effect]

### Iterate through all diplomacy-based councillors
### random_diplomacy_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_diplomacy_councillor] = single_alias_right[random_effect]

### Iterate through all directly owned provinces
### random_directly_owned_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = province
alias[effect:random_directly_owned_province] = single_alias_right[random_effect]

### Iterate through all titles the scoped character can vote on
### random_election_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_election_title] = single_alias_right[random_effect]

### Iterate through all equipped artifacts in a given characters inventory
### random_equipped_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = artifact
alias[effect:random_equipped_character_artifact] = single_alias_right[random_effect]

### Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]
### random_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_extended_family_member] = single_alias_right[random_effect]

### Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)
### random_foreign_court_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_foreign_court_guest] = single_alias_right[random_effect]

### Iterate through all former concubines. Not persisted past death
### random_former_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_former_concubine] = single_alias_right[random_effect]

### Iterate through all former concubinists. Not persisted past death
### random_former_concubinist = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_former_concubinist] = single_alias_right[random_effect]

### Iterate through all councillors that are not related to a skill
### random_general_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_general_councillor] = single_alias_right[random_effect]

### Heirs of the scoped character
### random_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_heir] = single_alias_right[random_effect]

### Iterate through all titles the scoped character is heir to
### random_heir_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_heir_title] = single_alias_right[random_effect]

### Iterate through all held landed titles
### random_held_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_held_title] = single_alias_right[random_effect]

### Iterate through all hired mercenary companies
### random_hired_mercenary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = mercenary_company
alias[effect:random_hired_mercenary] = single_alias_right[random_effect]

### Iterate through all hostages currently abroad
### random_home_court_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_home_court_hostage] = single_alias_right[random_effect]

### Iterate through all characters this character has a hook on
### random_hooked_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_hooked_character] = single_alias_right[random_effect]

### Iterate through anyone the character is hostile to due to their top-liege's realm having been raided
### random_hostile_raider = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_hostile_raider] = single_alias_right[random_effect]

### Iterate through all intrigue-based councillors
### random_intrigue_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_intrigue_councillor] = single_alias_right[random_effect]

### Iterate through all activities a character has been invited to
### random_invited_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = activity
alias[effect:random_invited_activity] = single_alias_right[random_effect]

### Iterate through all knights
### random_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_knight] = single_alias_right[random_effect]

### Iterate through all secrets known by the character
### random_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = secret
alias[effect:random_known_secret] = single_alias_right[random_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.
### random_land_neighboring_realm_with_tributaries = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_land_neighboring_realm_with_tributaries] = single_alias_right[random_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.
### random_land_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_land_neighboring_realm_with_tributaries_owner] = single_alias_right[random_effect]

### Iterate through all learning-based councillors
### random_learning_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_learning_councillor] = single_alias_right[random_effect]

### Iterate through all lieges above a character (skipping the character themselves)
### random_liege_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_liege_or_above] = single_alias_right[random_effect]

### Iterate through all MaA regiments
### random_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = regiment
alias[effect:random_maa_regiment] = single_alias_right[random_effect]

### Iterate through all martial-based councillors
### random_martial_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_martial_councillor] = single_alias_right[random_effect]

### Iterate through all memories of a character
### random_memory = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character_memory
alias[effect:random_memory] = single_alias_right[random_effect]

### A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
### random_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_neighboring_and_across_water_realm_same_rank_owner] = single_alias_right[random_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
### random_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_neighboring_and_across_water_top_liege_realm] = single_alias_right[random_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
### random_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_neighboring_and_across_water_top_liege_realm_owner] = single_alias_right[random_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the realm's top title. Can be based on borders a day or two out of date
### random_neighboring_and_across_water_top_suzerain_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_neighboring_and_across_water_top_suzerain_realm] = single_alias_right[random_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date
### random_neighboring_and_across_water_top_suzerain_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_neighboring_and_across_water_top_suzerain_realm_owner] = single_alias_right[random_effect]

### A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)
### random_neighboring_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_neighboring_realm_same_rank_owner] = single_alias_right[random_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date
### random_neighboring_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_neighboring_top_liege_realm] = single_alias_right[random_effect]

### A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date
### random_neighboring_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_neighboring_top_liege_realm_owner] = single_alias_right[random_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the realm's top title. Can be based on borders a day or two out of date
### random_neighboring_top_suzerain_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_neighboring_top_suzerain_realm] = single_alias_right[random_effect]

### A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date
### random_neighboring_top_suzerain_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_neighboring_top_suzerain_realm_owner] = single_alias_right[random_effect]

### Iterate through all noble family titles in the realm of scoped character
### random_noble_family = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_noble_family] = single_alias_right[random_effect]

### Iterate through all the spouse candidates of the opposite sex of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### random_opposite_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_opposite_sex_spouse_candidate] = single_alias_right[random_effect]

### Iterate through all owned stories for a character
### random_owned_story = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = story
alias[effect:random_owned_story] = single_alias_right[random_effect]

### Iterate through all holy orders that the scoped character is a patron of
### random_patroned_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = holy_order
alias[effect:random_patroned_holy_order] = single_alias_right[random_effect]

### Iterate through all personally claimed artifacts of the scoped character
### random_personal_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = artifact
alias[effect:random_personal_claimed_artifact] = single_alias_right[random_effect]

### Iterate through characters this player has pinned
### random_pinned_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_pinned_character] = single_alias_right[random_effect]

### Iterate through characters whose player has this character pinned
### random_pinning_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_pinning_character] = single_alias_right[random_effect]

### Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character
### random_played_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_played_character] = single_alias_right[random_effect]

### Iterate through player heirs, capped at the first 10
### random_player_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_player_heir] = single_alias_right[random_effect]

### Get all legends in a player character library.
### random_player_legend_library = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = legend
alias[effect:random_player_legend_library] = single_alias_right[random_effect]

### Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)
### random_pool_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_pool_guest] = single_alias_right[random_effect]

### Iterate through all potential selectable marriage or betrohed options
### random_potential_marriage_option = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_potential_marriage_option] = single_alias_right[random_effect]

### Iterate through all directly owned provinces
### random_powerful_family = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = dynasty_house
alias[effect:random_powerful_family] = single_alias_right[random_effect]

### Iterate through the all powerful vassals of a character
### random_powerful_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_powerful_vassal] = single_alias_right[random_effect]

### Iterate through all landed titles character is pretender to
### random_pretender_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_pretender_title] = single_alias_right[random_effect]

### Iterate through all primary war enemies
### random_primary_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_primary_war_enemy] = single_alias_right[random_effect]

### Iterate through all prisoners
### random_prisoner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_prisoner] = single_alias_right[random_effect]

### Iterate through all prowess-based councillors
### random_prowess_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_prowess_councillor] = single_alias_right[random_effect]

### Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges
### random_raid_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_raid_target] = single_alias_right[random_effect]

### Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.
### random_realm_border_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_realm_border_county] = single_alias_right[random_effect]

### Iterate through all counties in the realm. Based on top liege
### random_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_realm_county] = single_alias_right[random_effect]

### Iterate through all de jure duchies that have at least one county in the realm. Based on top liege
### random_realm_de_jure_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_realm_de_jure_duchy] = single_alias_right[random_effect]

### Iterate through all de jure empire that have at least one county in the realm. Based on top liege
### random_realm_de_jure_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_realm_de_jure_empire] = single_alias_right[random_effect]

### Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege
### random_realm_de_jure_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_realm_de_jure_kingdom] = single_alias_right[random_effect]

### Iterate through all realm provinces of a character
### random_realm_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = province
alias[effect:random_realm_province] = single_alias_right[random_effect]

### Iterate through all the spouse candidates of the same sex of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### random_same_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_same_sex_spouse_candidate] = single_alias_right[random_effect]

### Iterate through all schemes owned by the character
### random_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = scheme
alias[effect:random_scheme] = single_alias_right[random_effect]

### Iterate through all secrets of the character
### random_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = secret
alias[effect:random_secret] = single_alias_right[random_effect]

### Iterate through all siblings
### random_sibling = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_sibling] = single_alias_right[random_effect]

### Iterate through all sponsored inspirations
### random_sponsored_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = inspiration
alias[effect:random_sponsored_inspiration] = single_alias_right[random_effect]

### Iterate through all the spouse candidates of a character.
### WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.
### random_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_spouse_candidate] = single_alias_right[random_effect]

### Iterate through all stewardship-based councillors
### random_stewardship_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_stewardship_councillor] = single_alias_right[random_effect]

### Iterate through all baronies in sub-realm
### random_sub_realm_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_sub_realm_barony] = single_alias_right[random_effect]

### Iterate through all counties in sub-realm
### random_sub_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_sub_realm_county] = single_alias_right[random_effect]

### Iterate through all duchies in sub-realm
### random_sub_realm_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_sub_realm_duchy] = single_alias_right[random_effect]

### Iterate through all empires in sub-realm
### random_sub_realm_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_sub_realm_empire] = single_alias_right[random_effect]

### Iterate through all kingdoms in sub-realm
### random_sub_realm_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_sub_realm_kingdom] = single_alias_right[random_effect]

### Iterate through all titles in sub-realm
### random_sub_realm_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_sub_realm_title] = single_alias_right[random_effect]

### Iterate through all candidates supported by the scoped investor character for any title
### It may contain people outside of investor's top realm or no longer valid for appointment
### random_succession_appointment_invested_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_succession_appointment_invested_candidate] = single_alias_right[random_effect]

### Iterate through all titles that has candidates supported by the scoped investor
### It may contain titles outside of investor's top realm, and so invalid for appointment,
### and candidates may be already dead
### random_succession_appointment_invested_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_succession_appointment_invested_title] = single_alias_right[random_effect]

### Iterate through all factions targeting the scope character
### random_targeting_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = faction
alias[effect:random_targeting_faction] = single_alias_right[random_effect]

### Iterate through all schemes targeting the character
### random_targeting_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = scheme
alias[effect:random_targeting_scheme] = single_alias_right[random_effect]

### Iterate through all secrets that target the specified scope
### random_targeting_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = secret
alias[effect:random_targeting_secret] = single_alias_right[random_effect]

### Iterates through all Tax Collectors employed by the scoped character
### random_tax_collector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_tax_collector] = single_alias_right[random_effect]

### Iterates through all Vassals the scoped Character is the Tax Collector for
### random_tax_collector_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_tax_collector_vassal] = single_alias_right[random_effect]

### Iterates through all Tax Slots the scoped character has
### random_tax_slot = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = tax_slot
alias[effect:random_tax_slot] = single_alias_right[random_effect]

### Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.
### random_top_realm_border_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = landed_title
alias[effect:random_top_realm_border_county] = single_alias_right[random_effect]

### Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character
### random_traveling_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_traveling_family_member] = single_alias_right[random_effect]

### Iterate through all tributaries
### random_tributary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_tributary] = single_alias_right[random_effect]

### Iterate through all characters that have a truce on this character
### random_truce_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_truce_holder] = single_alias_right[random_effect]

### Iterate through all characters this character has a truce on
### random_truce_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_truce_target] = single_alias_right[random_effect]

### Iterates through all unassigned taxpayers for scoped Character
### random_unassigned_taxpayers = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_unassigned_taxpayers] = single_alias_right[random_effect]

### Iterate through all unspent secrets known by the character
### random_unspent_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = secret
alias[effect:random_unspent_known_secret] = single_alias_right[random_effect]

### Iterate through all DIRECT vassals
### random_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_vassal] = single_alias_right[random_effect]

### Iterate through ALL vassals, not just direct vassals
### random_vassal_or_below = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_vassal_or_below] = single_alias_right[random_effect]

### Iterate through all direct war allies
### random_war_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_war_ally] = single_alias_right[random_effect]

### Iterate through all direct war enemies
### random_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_war_enemy] = single_alias_right[random_effect]

### Iterate through all hostages having this warden
### random_warden_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = character
## push_scope = character
alias[effect:random_warden_hostage] = single_alias_right[random_effect]

### Iterate over both sides ( attacker and defender ) of the given combat
### every_combat_side = { limit = { <triggers> } <effects> }
## scope = combat
## push_scope = combat_side
alias[effect:every_combat_side] = single_alias_right[every_effect]

### Iterate over both sides ( attacker and defender ) of the given combat
### ordered_combat_side = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = combat
## push_scope = combat_side
alias[effect:ordered_combat_side] = single_alias_right[ordered_effect]

### Iterate over both sides ( attacker and defender ) of the given combat
### random_combat_side = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = combat
## push_scope = combat_side
alias[effect:random_combat_side] = single_alias_right[random_effect]

### Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes
### every_claimant = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_claimant] = single_alias_right[every_effect]

### Iterate through all counties connected to this one. Is based on top liege
### any/every/whatever_connectec_county = {
### 
### max_naval_distance = 500
### 
### allow_one_county_land_gap = yes
### every_connected_county = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_connected_county] = single_alias_right[every_effect]

### Iterate through all faiths headed by a title
### every_controlled_faith = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = faith
alias[effect:every_controlled_faith] = single_alias_right[every_effect]

### Iterate through controlled title regiments
### every_controlled_title_maa_regiment = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:every_controlled_title_maa_regiment] = single_alias_right[every_effect]

### Iterate through all provinces in a county
### every_county_province = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = province
alias[effect:every_county_province] = single_alias_right[every_effect]

### Iterate through all situations that a county is involved in.
### every_county_situation = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = situation
alias[effect:every_county_situation] = single_alias_right[every_effect]

### Iterate through all situation sub-regions that a county is involved in.
### every_county_situation_sub_region = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = situation_sub_region
alias[effect:every_county_situation_sub_region] = single_alias_right[every_effect]

### Iterate through all struggles that a county is involved in.
### every_county_struggle = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = struggle
alias[effect:every_county_struggle] = single_alias_right[every_effect]

### Iterate through all counties within this dejure title
### every_de_jure_county = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_de_jure_county] = single_alias_right[every_effect]

### Iterate through all characters directly holding counties within this dejure title
### every_de_jure_county_holder = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_de_jure_county_holder] = single_alias_right[every_effect]

### Iterate through all top lieges of the counts within this dejure title
### every_de_jure_top_liege = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_de_jure_top_liege] = single_alias_right[every_effect]

### Iterate through all the vassal holders of the title
### every_dejure_vassal_title_holder = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_dejure_vassal_title_holder] = single_alias_right[every_effect]

### Iterate through all de facto vassal titles
### every_direct_de_facto_vassal_title = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_direct_de_facto_vassal_title] = single_alias_right[every_effect]

### Iterate through the all de jure vassals titles
### every_direct_de_jure_vassal_title = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_direct_de_jure_vassal_title] = single_alias_right[every_effect]

### Iterate through all characters who are valid candidates in an election for a title
### every_election_candidate = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_election_candidate] = single_alias_right[every_effect]

### Iterate through all characters who are valid electors in an election for a title
### every_elector = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_elector] = single_alias_right[every_effect]

### Iterate through all counties that are important for the scoped title
### every_important_location_for_title = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_important_location_for_title] = single_alias_right[every_effect]

### Iterate through all neighboring counties. Can only be used in county scope
### every_neighboring_county = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_neighboring_county] = single_alias_right[every_effect]

### Iterate through owned title MaA regiments
### every_owned_title_maa_regiment = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:every_owned_title_maa_regiment] = single_alias_right[every_effect]

### Iterate through all past owners of a title from earliest to latest
### every_past_holder = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_past_holder] = single_alias_right[every_effect]

### Iterate through all past owners of a title from latest to earliest
### every_past_holder_reversed = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_past_holder_reversed] = single_alias_right[every_effect]

### Iterate through this title and all its dejure liege titles
### every_this_title_or_de_jure_above = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_this_title_or_de_jure_above] = single_alias_right[every_effect]

### Line of succession for the scoped title
### every_title_heir = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:every_title_heir] = single_alias_right[every_effect]

### Iterate through titles that consider scoped county an important location
### every_title_interested_in_location = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_interested_in_location] = single_alias_right[every_effect]

### Iterate through all factions joined the scope landed title
### every_title_joined_faction = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = faction
alias[effect:every_title_joined_faction] = single_alias_right[every_effect]

### Iterate through title all MaA regiments
### every_title_maa_regiment = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:every_title_maa_regiment] = single_alias_right[every_effect]

### Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)
### every_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_and_across_water_county] = single_alias_right[every_effect]

### Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
### every_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_and_across_water_duchy] = single_alias_right[every_effect]

### Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)
### every_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_and_across_water_empire] = single_alias_right[every_effect]

### Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
### every_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_and_across_water_kingdom] = single_alias_right[every_effect]

### Scopes from a title to a neighboring county (looking trough the de Jure lieges)
### every_title_to_title_neighboring_county = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_county] = single_alias_right[every_effect]

### Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)
### every_title_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_duchy] = single_alias_right[every_effect]

### Scopes from a title to a neighboring empire (looking trough the de Jure lieges)
### every_title_to_title_neighboring_empire = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_empire] = single_alias_right[every_effect]

### Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)
### every_title_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:every_title_to_title_neighboring_kingdom] = single_alias_right[every_effect]

### Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes
### ordered_claimant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_claimant] = single_alias_right[ordered_effect]

### Iterate through all counties connected to this one. Is based on top liege
### any/every/whatever_connectec_county = {
### 
### max_naval_distance = 500
### 
### allow_one_county_land_gap = yes
### ordered_connected_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_connected_county] = single_alias_right[ordered_effect]

### Iterate through all faiths headed by a title
### ordered_controlled_faith = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = faith
alias[effect:ordered_controlled_faith] = single_alias_right[ordered_effect]

### Iterate through controlled title regiments
### ordered_controlled_title_maa_regiment = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:ordered_controlled_title_maa_regiment] = single_alias_right[ordered_effect]

### Iterate through all provinces in a county
### ordered_county_province = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = province
alias[effect:ordered_county_province] = single_alias_right[ordered_effect]

### Iterate through all situations that a county is involved in.
### ordered_county_situation = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = situation
alias[effect:ordered_county_situation] = single_alias_right[ordered_effect]

### Iterate through all situation sub-regions that a county is involved in.
### ordered_county_situation_sub_region = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = situation_sub_region
alias[effect:ordered_county_situation_sub_region] = single_alias_right[ordered_effect]

### Iterate through all struggles that a county is involved in.
### ordered_county_struggle = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = struggle
alias[effect:ordered_county_struggle] = single_alias_right[ordered_effect]

### Iterate through all counties within this dejure title
### ordered_de_jure_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_de_jure_county] = single_alias_right[ordered_effect]

### Iterate through all characters directly holding counties within this dejure title
### ordered_de_jure_county_holder = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_de_jure_county_holder] = single_alias_right[ordered_effect]

### Iterate through all top lieges of the counts within this dejure title
### ordered_de_jure_top_liege = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_de_jure_top_liege] = single_alias_right[ordered_effect]

### Iterate through all the vassal holders of the title
### ordered_dejure_vassal_title_holder = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_dejure_vassal_title_holder] = single_alias_right[ordered_effect]

### Iterate through all de facto vassal titles
### ordered_direct_de_facto_vassal_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_direct_de_facto_vassal_title] = single_alias_right[ordered_effect]

### Iterate through the all de jure vassals titles
### ordered_direct_de_jure_vassal_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_direct_de_jure_vassal_title] = single_alias_right[ordered_effect]

### Iterate through all characters who are valid candidates in an election for a title
### ordered_election_candidate = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_election_candidate] = single_alias_right[ordered_effect]

### Iterate through all characters who are valid electors in an election for a title
### ordered_elector = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_elector] = single_alias_right[ordered_effect]

### Iterate through all counties that are important for the scoped title
### ordered_important_location_for_title = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_important_location_for_title] = single_alias_right[ordered_effect]

### Iterate through all neighboring counties. Can only be used in county scope
### ordered_neighboring_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_neighboring_county] = single_alias_right[ordered_effect]

### Iterate through owned title MaA regiments
### ordered_owned_title_maa_regiment = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:ordered_owned_title_maa_regiment] = single_alias_right[ordered_effect]

### Iterate through all past owners of a title from earliest to latest
### ordered_past_holder = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_past_holder] = single_alias_right[ordered_effect]

### Iterate through all past owners of a title from latest to earliest
### ordered_past_holder_reversed = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_past_holder_reversed] = single_alias_right[ordered_effect]

### Iterate through this title and all its dejure liege titles
### ordered_this_title_or_de_jure_above = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_this_title_or_de_jure_above] = single_alias_right[ordered_effect]

### Line of succession for the scoped title
### ordered_title_heir = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = character
alias[effect:ordered_title_heir] = single_alias_right[ordered_effect]

### Iterate through titles that consider scoped county an important location
### ordered_title_interested_in_location = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_interested_in_location] = single_alias_right[ordered_effect]

### Iterate through all factions joined the scope landed title
### ordered_title_joined_faction = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = faction
alias[effect:ordered_title_joined_faction] = single_alias_right[ordered_effect]

### Iterate through title all MaA regiments
### ordered_title_maa_regiment = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:ordered_title_maa_regiment] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_and_across_water_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_and_across_water_county] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_and_across_water_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_and_across_water_duchy] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_and_across_water_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_and_across_water_empire] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_and_across_water_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_and_across_water_kingdom] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring county (looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_county = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_county] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_duchy = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_duchy] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring empire (looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_empire = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_empire] = single_alias_right[ordered_effect]

### Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)
### ordered_title_to_title_neighboring_kingdom = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:ordered_title_to_title_neighboring_kingdom] = single_alias_right[ordered_effect]

### Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes
### random_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_claimant] = single_alias_right[random_effect]

### Iterate through all counties connected to this one. Is based on top liege
### any/every/whatever_connectec_county = {
### 
### max_naval_distance = 500
### 
### allow_one_county_land_gap = yes
### random_connected_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_connected_county] = single_alias_right[random_effect]

### Iterate through all faiths headed by a title
### random_controlled_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = faith
alias[effect:random_controlled_faith] = single_alias_right[random_effect]

### Iterate through controlled title regiments
### random_controlled_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:random_controlled_title_maa_regiment] = single_alias_right[random_effect]

### Iterate through all provinces in a county
### random_county_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = province
alias[effect:random_county_province] = single_alias_right[random_effect]

### Iterate through all situations that a county is involved in.
### random_county_situation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = situation
alias[effect:random_county_situation] = single_alias_right[random_effect]

### Iterate through all situation sub-regions that a county is involved in.
### random_county_situation_sub_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = situation_sub_region
alias[effect:random_county_situation_sub_region] = single_alias_right[random_effect]

### Iterate through all struggles that a county is involved in.
### random_county_struggle = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = struggle
alias[effect:random_county_struggle] = single_alias_right[random_effect]

### Iterate through all counties within this dejure title
### random_de_jure_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_de_jure_county] = single_alias_right[random_effect]

### Iterate through all characters directly holding counties within this dejure title
### random_de_jure_county_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_de_jure_county_holder] = single_alias_right[random_effect]

### Iterate through all top lieges of the counts within this dejure title
### random_de_jure_top_liege = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_de_jure_top_liege] = single_alias_right[random_effect]

### Iterate through all the vassal holders of the title
### random_dejure_vassal_title_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_dejure_vassal_title_holder] = single_alias_right[random_effect]

### Iterate through all de facto vassal titles
### random_direct_de_facto_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_direct_de_facto_vassal_title] = single_alias_right[random_effect]

### Iterate through the all de jure vassals titles
### random_direct_de_jure_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_direct_de_jure_vassal_title] = single_alias_right[random_effect]

### Iterate through all characters who are valid candidates in an election for a title
### random_election_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_election_candidate] = single_alias_right[random_effect]

### Iterate through all characters who are valid electors in an election for a title
### random_elector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_elector] = single_alias_right[random_effect]

### Iterate through all counties that are important for the scoped title
### random_important_location_for_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_important_location_for_title] = single_alias_right[random_effect]

### Iterate through all neighboring counties. Can only be used in county scope
### random_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_neighboring_county] = single_alias_right[random_effect]

### Iterate through owned title MaA regiments
### random_owned_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:random_owned_title_maa_regiment] = single_alias_right[random_effect]

### Iterate through all past owners of a title from earliest to latest
### random_past_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_past_holder] = single_alias_right[random_effect]

### Iterate through all past owners of a title from latest to earliest
### random_past_holder_reversed = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_past_holder_reversed] = single_alias_right[random_effect]

### Iterate through this title and all its dejure liege titles
### random_this_title_or_de_jure_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_this_title_or_de_jure_above] = single_alias_right[random_effect]

### Line of succession for the scoped title
### random_title_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = character
alias[effect:random_title_heir] = single_alias_right[random_effect]

### Iterate through titles that consider scoped county an important location
### random_title_interested_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_interested_in_location] = single_alias_right[random_effect]

### Iterate through all factions joined the scope landed title
### random_title_joined_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = faction
alias[effect:random_title_joined_faction] = single_alias_right[random_effect]

### Iterate through title all MaA regiments
### random_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = regiment
alias[effect:random_title_maa_regiment] = single_alias_right[random_effect]

### Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)
### random_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_and_across_water_county] = single_alias_right[random_effect]

### Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)
### random_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_and_across_water_duchy] = single_alias_right[random_effect]

### Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)
### random_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_and_across_water_empire] = single_alias_right[random_effect]

### Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)
### random_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_and_across_water_kingdom] = single_alias_right[random_effect]

### Scopes from a title to a neighboring county (looking trough the de Jure lieges)
### random_title_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_county] = single_alias_right[random_effect]

### Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)
### random_title_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_duchy] = single_alias_right[random_effect]

### Scopes from a title to a neighboring empire (looking trough the de Jure lieges)
### random_title_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_empire] = single_alias_right[random_effect]

### Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)
### random_title_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = landed_title
## push_scope = landed_title
alias[effect:random_title_to_title_neighboring_kingdom] = single_alias_right[random_effect]

### Iterate through all faction county members
### every_faction_county_member = { limit = { <triggers> } <effects> }
## scope = faction
## push_scope = landed_title
alias[effect:every_faction_county_member] = single_alias_right[every_effect]

### Iterate through all faction character members
### every_faction_member = { limit = { <triggers> } <effects> }
## scope = faction
## push_scope = character
alias[effect:every_faction_member] = single_alias_right[every_effect]

### Iterate through all faction county members
### ordered_faction_county_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faction
## push_scope = landed_title
alias[effect:ordered_faction_county_member] = single_alias_right[ordered_effect]

### Iterate through all faction character members
### ordered_faction_member = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = faction
## push_scope = character
alias[effect:ordered_faction_member] = single_alias_right[ordered_effect]

### Iterate through all faction county members
### random_faction_county_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faction
## push_scope = landed_title
alias[effect:random_faction_county_member] = single_alias_right[random_effect]

### Iterate through all faction character members
### random_faction_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = faction
## push_scope = character
alias[effect:random_faction_member] = single_alias_right[random_effect]

### Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)
### every_side_commander = { limit = { <triggers> } <effects> }
## scope = combat_side
## push_scope = character
alias[effect:every_side_commander] = single_alias_right[every_effect]

### Iterate through all knights
### every_side_knight = { limit = { <triggers> } <effects> }
## scope = combat_side
## push_scope = character
alias[effect:every_side_knight] = single_alias_right[every_effect]

### Returns all participants in a combat side
### every_side_participant = { limit = { <triggers> } <effects> }
## scope = combat_side
## push_scope = character
alias[effect:every_side_participant] = single_alias_right[every_effect]

### Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)
### ordered_side_commander = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = combat_side
## push_scope = character
alias[effect:ordered_side_commander] = single_alias_right[ordered_effect]

### Iterate through all knights
### ordered_side_knight = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = combat_side
## push_scope = character
alias[effect:ordered_side_knight] = single_alias_right[ordered_effect]

### Returns all participants in a combat side
### ordered_side_participant = {
### limit = { <triggers> }
### order_by = script_value
### position = int
### min = int
### max = script_value
### check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
### <effects> }
## scope = combat_side
## push_scope = character
alias[effect:ordered_side_participant] = single_alias_right[ordered_effect]

### Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)
### random_side_commander = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = combat_side
## push_scope = character
alias[effect:random_side_commander] = single_alias_right[random_effect]

### Iterate through all knights
### random_side_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = combat_side
## push_scope = character
alias[effect:random_side_knight] = single_alias_right[random_effect]

### Returns all participants in a combat side
### random_side_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
## scope = combat_side
## push_scope = character
alias[effect:random_side_participant] = single_alias_right[random_effect]

