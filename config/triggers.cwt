# TODO: organise this?

# alias[trigger:trigger] = {
#     alias_name[trigger] = alias_match_left[trigger]
# }

#################################################
# DYNASTY SCOPE
#################################################

### How many perks in the lifestyle does this dynasty have?
## scope = dynasty
alias[trigger:<legacy>_perks] == alias_keys_field[int_value]

### How many perks in the lifestyle does this dynasty have?
## scope = dynasty
alias[trigger:<legacy>_perks] == single_alias_right[score_formula]

### How many perks in the lifestyle does this dynasty have?
## scope = dynasty
alias[trigger:<legacy>_perks] == value_field

### Does the scoped dynasty have a given modifier has_dynasty_modifier = name
## scope = dynasty
alias[trigger:has_dynasty_modifier] = <modifier_container>

# Unused trigger
### Does the scoped dynasty have the duration remaining on a given modifier has_dynasty_modifier_duration_remaining = name
## scope = dynasty
alias[trigger:has_dynasty_modifier_duration_remaining] = <modifier_container>

### Does the dynasty have this dynasty perk? has_dynasty_perk = key
## scope = dynasty
alias[trigger:has_dynasty_perk] = <dynasty_perk>

########################################################
# ACTIVITY SCOPE
########################################################

### Does the scoped activity have the designated locale active?
## scope = activity
alias[trigger:has_active_locale] = <activity_locale>

### Does the scoped activity have the option in the given category active
## scope = activity
alias[trigger:has_activity_option] = {
    category = enum[activity_option_category]
    option = enum[activity_option]
}

### Does the scoped activity have the given activity type
## scope = activity
alias[trigger:has_activity_type] = <activity>

### Does the scoped activity have the given phase active
## scope = activity
alias[trigger:has_current_phase] = value[activity_phase]

### Check if a phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.
## scope = activity
alias[trigger:has_phase] = value[activity_phase]

### Check if a phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.
## scope = activity
alias[trigger:has_phase] = {
    type = value[activity_phase]
    location = scope[province]
}

### Check if a future phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.
## scope = activity
alias[trigger:has_phase_future] = value[activity_phase]

### Check if a future phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.
## scope = activity
alias[trigger:has_phase_future] = {
    type = value[activity_phase]
    location = scope[province]
}

### Check if a past phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.
## scope = activity
alias[trigger:has_phase_past] = value[activity_phase]

### Check if a past phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.
## scope = activity
alias[trigger:has_phase_past] = {
    type = value[activity_phase]
    location = scope[province]
}

### Is the target character a required special guest in the scoped activity.
## scope = activity
alias[trigger:is_required_special_guest] = scope[character]

#######################################################
# CULTURE SCOPE
#######################################################

### The cultural acceptance of the scoped culture with the target culture
## scope = culture
alias[trigger:cultural_acceptance] = {
    target = scope[culture]
    value == alias_keys_field[int_value]
    value == value_field
}

### Checks if any county with this culture is in the given geographical region
## scope = culture
alias[trigger:culture_overlaps_geographical_region] == scope[geographical_region]

### Checks if any county with this culture is in the given geographical region
## scope = culture
alias[trigger:culture_overlaps_geographical_region] == <geographical_region>

### Has the culture discovered all innovations matching the filter?
## scope = culture
alias[trigger:has_all_innovations] == {
    ## cardinality = 0..1
    with_flag = value[innovation_flag]
    ## cardinality = 0..1
    without_flag = value[innovation_flag]
    ## cardinality = 0..1
    culture_era = <era>
}

### How many free tradition slot are in the scoped culture
## scope = culture
alias[trigger:has_building_gfx] = enum[building_gfx]

### How many free tradition slot are in the scoped culture
## scope = culture
alias[trigger:has_clothing_gfx] = enum[clothing_gfx]

### How many free tradition slot are in the scoped culture
## scope = culture
alias[trigger:has_coa_gfx] = enum[coa_gfx]

### Has this culture achieved specified era<culture> = { has_cultural_era_or_later = culture_era_early_medieval }
alias[trigger:has_cultural_era_or_later] = <era>

### Does the target culture possess this cultural parameter
## scope = culture
alias[trigger:has_cultural_parameter] = enum[cultural_parameter]

### Does the culture have this cultural pillar?
## scope = culture
alias[trigger:has_cultural_pillar] = <pillar>

### Does the culture have this cultural tradition?
## scope = culture
alias[trigger:has_cultural_tradition] = <tradition>

### Have the culture discovered this innovation?
## scope = culture
alias[trigger:has_innovation] = <innovation>

### Has the culture discovered an innovation with this flag? 
## scope = culture
alias[trigger:has_innovation_flag] = value[innovation_flag]

### Does the culture have this name list?
## scope = culture
alias[trigger:has_name_list] = <name_list>

### Does the culture have this name list as its first name list?
## scope = culture
alias[trigger:has_primary_name_list] = <name_list>

### Does the culture have this unit gfx?
## scope = culture
alias[trigger:has_unit_gfx] = enum[unit_gfx]

### Does the culture have the required number of discovered innovations?
## scope = culture
alias[trigger:num_discovered_innovations_in_era] == {
    era = <era>
    value == int_value_field
    value == alias_keys_field[int_value]
    value == single_alias_right[score_formula]
}

##################################################
# MEMORY SCOPE
##################################################

### Does the character memory have this memory category?
## scope = memory
alias[trigger:has_memory_category] = enum[memory_category]

### Does the character memory have this memory type?
## scope = memory
alias[trigger:has_memory_type] = <memory>

### Is the scoped memory a memory of a specific travel plan? 
## scope = memory
alias[trigger:is_memory_of_travel] = <travel_plan>

### Date when the memory was created.
## scope = memory
alias[trigger:memory_creation_date] == date_field

### Date when the memory will be forgotten. (this may change over time)
## scope = memory
alias[trigger:memory_end_date] == date_field


#####################################################
# REGIMENT SCOPE
#####################################################

###  Check MaA type of a regiment
## scope = regiment
alias[trigger:is_maa_type] = <maa_type>

###  Check base MaA type of a regiment
## scope = regiment
alias[trigger:is_unit_type] = <maa_type>

#####################################################
# TRAIT SCOPE
#####################################################

### Does the scoped trait belong to the given trait cateogry.
## scope = trait
alias[trigger:has_trait_category] = enum[trait_category]

### Does the scoped trait have the given flag.
## scope = trait
alias[trigger:has_trait_flag] = value[trait_flag]

### Is the scoped trait an opposite trait of the target trait.
## scope = trait
alias[trigger:is_opposite_of_trait] = <trait>

#####################################################
# HOUSE SCOPE
#####################################################

### Does the scoped house have the duration remaining on a given modifier has_house_modifier_duration_remaining = name
## scope = dynasty_house
alias[trigger:has_house_modifier_duration_remaining] = <modifier_container>

### Does the scoped house have a given modifier has_house_modifier = name
## scope = dynasty_house
alias[trigger:has_house_modifier] = <modifier_container>

### Does the scoped house with unity have a given modifier
## scope = dynasty_house
alias[trigger:has_house_unity_modifier] = <modifier_container>

### Does the scoped house with unity have a given modifier
## scope = dynasty_house
alias[trigger:has_house_unity_modifier_duration_remaining] = <modifier_container>

### Does the given house unity have the given parameter? Can only check for bool parameters.
## scope = dynasty_house
alias[trigger:has_house_unity_parameter] = enum[house_unity_parameter]

### Is the given house unity the given stage?. 
## scope = dynasty_house
alias[trigger:has_house_unity_stage] = <house_unity_stage>

### Calculate share of counties held in the target liege's realm by the house. Only rulers of liege's government type counts. house_land_share_in_realm = {		target = scope:liege		value > 0.5	}
## scope = dynasty_house
alias[trigger:has_house_unity_stage] = {
    target = scope[character]
    value = float
}

#####################################################
# TASK CONTRACT SCOPE
#####################################################

### Has task contract of the group
## scope = task_contract
alias[trigger:has_task_contract_group] = value[task_contract_group]

### has task contract with type
## scope = task_contract
alias[trigger:has_task_contract_type] = <task_contract>

#####################################################
# COUNCIL TASK SCOPE
#####################################################

### Check if the scope task's councillor can be fired. Will check both can_fire and things like it being illegal to reassing the position
## scope = council_task
alias[trigger:position_can_be_fired] == <bool>

#####################################################
# SECRET SCOPE
#####################################################

### Is the scope secret of the specified type?
## scope = secret
alias[trigger:secret_type] = <secret_type>

#####################################################
# RELIGION SCOPE
#####################################################

### Is the scoped faith in a given religious family is_in_family = abrhamic
alias[trigger:is_in_family] = <religion_family>

#####################################################
# ARMY SCOPE
#####################################################

#####################################################
# TRAVEL PLAN SCOPE
#####################################################

### Compare the date the travel plan started.
## scope = travel_plan
alias[trigger:departure_date] = date_field

### Estimation date of arrival at the final 
## scope = travel_plan
alias[trigger:final_destination_arrival_date] = date_field

### Does the travel plan have this travel option active?
## scope = travel_plan
alias[trigger:has_travel_option] = <travel_option>

###Does the scoped travel plan have a given modifier
## scope = travel_plan
alias[trigger:has_travel_plan_modifier] = <modifier_container>

### Does the scoped travel plan have the duration remaining on a given modifier
## scope = travel_plan
alias[trigger:has_travel_plan_modifier_duration_remaining] = <modifier_container>

### Estimation date of arrival at the next destination
## scope = travel_plan
alias[trigger:next_destination_arrival_date] = date_field

#####################################################
# FAITH SCOPE
#####################################################

### Does the faith control a holy site? controls_holy_site = key_of_holy_site
## scope = faith
alias[trigger:controls_holy_site] = <holy_site>

### Does the faith control a holy site with the given flag? controls_holy_site_with_flag = some flag
## scope = faith
alias[trigger:controls_holy_site_with_flag] = value[holy_site_flag]

### What is the faith's hostility level towards the target faith? faith_hostility_level { target = scope:some_faith value > 1 }
## scope = faith
alias[trigger:faith_hostility_level] = {
    target = scope[faith]
    value == alias_keys_field[int_value]
    value == value_field
}

### Compares the scoped faith's hostility level towards two other faiths. faith_hostility_level_comparison { faith1 > faith2 }
## scope = faith
alias[trigger:faith_hostility_level_comparison] = {
    scope[faith] == scope[faith]
}

### Does the given faith have the given doctrine?? has_doctrine = doctrine_key
## scope = faith
alias[trigger:has_doctrine] = <doctrine>


### Does the given faith have the given doctrine parameter? Can only check for bool parameters. has_doctrine_parameter = parameter_key
## scope = faith
alias[trigger:has_doctrine_parameter] = enum[doctrine_param]

### Does the faith have this graphical faith? <faith> = { has_graphical_faith = orthodoxgfx }
## scope = faith
alias[trigger:has_graphical_faith] = value[graphical_faith]

### Does the faith have the given icon has_icon = some_cool_custom_icon
## scope = faith
alias[trigger:has_icon] = filepath[game/gfx/interface/icons/faith/,.dds]

### checks the tag of the religion of the current faith
## scope = faith
alias[trigger:religion_tag] = <religion>

### Does the scoped faith consider the given trait a sin? trait_is_sin = lustful
## scope = faith
alias[trigger:trait_is_sin] = <trait>

### Does the scoped faith consider the given trait a sin? trait_is_sin = lustful
## scope = faith
alias[trigger:trait_is_sin] = scope[trait]

### Does the scoped faith consider the given trait a virtue? trait_is_virtue = lustful
## scope = faith
alias[trigger:trait_is_virtue] = <trait>

### Does the scoped faith consider the given trait a virtue? trait_is_virtue = lustful
## scope = faith
alias[trigger:trait_is_virtue] = scope[trait]

#####################################################
# STRUGGLE SCOPE
#####################################################

### Does the given struggle's current phase have the given parameter? Can only check for bool parameters. has_struggle_phase_parameter = parameter_key
## scope = struggle
alias[trigger:has_struggle_phase_parameter] = value[struggle_parameter]

### is the scope struggle's current phase particular phase?
## scope = struggle
alias[trigger:is_struggle_phase] = <struggle_phase>

### is the scope struggle's type particular type?
## scope = struggle
alias[trigger:is_struggle_type] = <struggle>

### Is any of the future phases affected by the given catalyst?
## scope = struggle
alias[trigger:phase_has_catalyst] = <struggle_catalyst>

#####################################################
# AGENT SLOT SCOPE
#####################################################

### Does the agent slot have provide the given type of contribution?
## scope = agent_slot
alias[trigger:agent_slot_has_contribution_type] = enum[contribution_type]

### Is any of the future phases affected by the given catalyst?
## scope = agent_slot
alias[trigger:is_agent_slot_type] = <agent_type>

#####################################################
# GREAT HOLY WAR SCOPE
#####################################################

#####################################################
# EPIDEMIC SCOPE
#####################################################

### Get the outbreak intensity of this epidemic.outbreak_intensity = major
## scope = epidemic
alias[trigger:outbreak_intensity] == enum[outbreak_intensity]

### Date when the epidemic outbreak began.
## scope = epidemic
alias[trigger:outbreak_start_date] == date_field

#####################################################
# TAX SLOT SCOPE
#####################################################

#####################################################
# ACCOLADE TYPE SCOPE
#####################################################

### Is the scoped Accolade Type's tier equal to?
## scope = accolade
alias[trigger:accolade_type_tier] = enum[accolade_tier]


### Does the scoped Accolade Type have the given category?
## scope = accolade_type
alias[trigger:type_has_accolade_category] = value[accolade_category]


#####################################################
# TRADITION SCOPE
#####################################################

### Does the scoped tradition belong to the specified category?
## scope = culture_tradition
alias[trigger:has_tradition_category] = enum[tradition_category]

#####################################################
# CASUS BELLI SCOPE
#####################################################


#####################################################
# ARTIFACT SCOPE
#####################################################

### is the artifact of the given inventory slot type?
## scope = artifact
alias[trigger:artifact_slot_type] = enum[artifact_slot_type]

### is the artifact of the given type?
## scope = artifact
alias[trigger:artifact_type] = <artifact_type>

### is the scoped artifact of given category?
## scope = artifact
alias[trigger:category] = enum[inventory_slot_category]

### Does the artifact have the given feature?
## scope = artifact
alias[trigger:has_artifact_feature] = <feature>

### Does the artifact have the given feature group?
## scope = artifact
alias[trigger:has_artifact_feature_group] = <feature_group>

### Does the artifact have the given modifier?
## scope = artifact
alias[trigger:has_artifact_modifier] = <modifier_container>

### is the scoped artifact of given rarity?
## scope = artifact
alias[trigger:rarity] = enum[artifact_rarity]


#####################################################
# MERCENARY COMPANY SCOPE
#####################################################

### Is the mercenary company within the hiring range of the target character.
alias[trigger:is_mercenary_in_hire_range] == scope[character]

### How many days are left in the mercenary contract. 0 if not hired.
alias[trigger:mercenary_company_expiration_days] == replace_me_comparison

#####################################################
# ANY SCOPE
#####################################################

### Saves a temporary target for use during the trigger execution  This is used to build lists in triggers. If used within an any-trigger, placement within the trigger is quite important. The game will iterate through every instance of the any-trigger until it finds a single instance that fulfills the requirements, and then it will stop. In order to add every instance of a scope that fulfills certain conditions, use "count = all" while also placing this "effect" at the very end of the any-trigger (so that every condition is evaluated for every iteration).
alias[trigger:add_to_temporary_list] = value_set[temporary_list]


### true if all children are false (equivalent to NOR)
alias[trigger:all_false] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### all inside trigger must be true
alias[trigger:and] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### Conditionally cause an assert during run time assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string
alias[trigger:assert_if] = {
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    text = localisation
}

### Conditionally cause an assert during read time assert_read = X, where X is yes or the string to be printed in the assert
alias[trigger:assert_read] = localisation

### Returns true if the specified number of sub-triggers return true calc_true_if = { amount = 2 <trigger> <trigger> <trigger> }
alias[trigger:calc_true_if] = {
    amount = int
    alias_name[trigger] = alias_match_left[trigger]
}

### Can the specified tutorial lesson be started? can_start_tutorial_lesson = reactive_advice_succession An interface trigger, can only be used in specific places
alias[trigger:can_start_tutorial_lesson] = replace_me

### Compare the current computer date.
alias[trigger:current_computer_date] == date_field

### Compare the current ingame date.
alias[trigger:current_date] == date_field

### Wraps triggers that get a custom description instead of the auto-generated one custom_description = { 	text = <trigger_localization_key> 	subject = <optional subject scope> #defaults to current scope 	object = <optional object scope> 	value = <optional script value> 	... triggers ... }
alias[trigger:custom_description] = {
    text = <trigger_localization>
    text = localisation
    ## cardinality = 0..1
    subject = scope_field
    ## cardinality = 0..1
    object = scope_field
    ## cardinality = 0..1
    value = scalar
    alias_name[trigger] = alias_match_left[trigger]
}

alias[trigger:custom_tooltip] = localisation

### Replaces the tooltips for the enclosed triggers with a custom text custom_tooltip = { 	text = <text> 	<trigger> }
alias[trigger:custom_tooltip] = {
    text = localisation
    alias_name[trigger] = alias_match_left[trigger]
}

### Checks whether the specified scope target exists (check for not being the null object) exists = from.owner.var:cool_var.mother
alias[trigger:exists] = scope_field

### Checks whether the specified scope target exists (check for not being the null object) exists = from.owner.var:cool_var.mother
alias[trigger:exists] = value_field # TODO: ?

### Compare the date of the bookmarked game launched.
alias[trigger:game_start_date] == date_field

### Checks the size of a variable list variable_list_size = { name = X target >= Y } Where X is the name of the variable Where Y is a script value or number
alias[trigger:global_variable_list_size] = {
    name = value[global_variable_list]
    ## cardinality = 0..1
    target == alias_keys_field[int_value] # TODO: Target is not used in vanilla, does it exist?
    ## cardinality = 0..1
    target == value_field
    ## cardinality = 0..1
    value == int_value_field
    ## cardinality = 0..1
    value == alias_keys_field[int_value]
    ## cardinality = 0..1
    value == single_alias_right[score_formula]
}

# ### Does the host have this DLC
# alias[trigger:has_dlc] = <dlc>

### Does the host have this DLC
alias[trigger:has_dlc] = enum[dlc_key]

### Does the host have DLC that enables this particular feature
alias[trigger:has_dlc_feature] = enum[dlc_feature]

### Is the given game rule setting enabled? has_game_rule = faster_conversion
alias[trigger:has_game_rule] = <game_rule>

### Checks whether the current scope has the specified variable set has_variable = name
alias[trigger:has_global_variable] = value[global_variable]

### Checks whether the current scope has the specified variable set has_variable = name
alias[trigger:has_global_variable_list] = value[global_variable_list]

### Checks if the current map mode is the specified one has_map_mode = realms An interface trigger, can only be used in specific places
alias[trigger:has_map_mode] = replace_me

### Checks whether the current scope has the specified variable set has_variable = name
alias[trigger:has_variable] = value[variable]

### Checks whether the current scope has the specified variable list set has_variable_list = name
alias[trigger:has_variable_list] = value[variable_list]

### Checks whether the current scope has the specified variable list set
### has_variable_list = name
alias[trigger:has_local_variable_list] = value[variable_list]

### Is there a war result message with the specified outcome? has_war_result_message_with_outcome = victory/defeat/white_peace/invalidated/any An interface trigger, can only be used in specific places
alias[trigger:has_war_result_message_with_outcome] = enum[war_result]

### Checks if a target in in a list
alias[trigger:is_in_list] = value[list]

### Checks whether the specified scope target has been set (includes being the null object)
alias[trigger:is_set] = scope_field

### Checks if a target is in a variable list is_target_in_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[trigger:is_target_in_global_variable_list] = {
    name = value[global_variable_list]
    target = scope_field
}

### Checks if a target is in a variable list is_target_in_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[trigger:is_target_in_local_variable_list] = {
    name = value[local_variable_list]
    target = scope_field
}

### Checks if a target is in a variable list is_target_in_variable_list = { name = X target = Y } Where X is the name of the variable Where Y is an event target
alias[trigger:is_target_in_variable_list] = {
    name = value[variable_list]
    target = scope_field
}

### is the tooltip with the specified name open?  - An interface trigger, can only be used in specific places
alias[trigger:is_tooltip_with_name_open] = replace_me

### has the tutorial lesson with the specified name been finished?  - An interface trigger, can only be used in specific places
alias[trigger:is_tutorial_lesson_completed] = replace_me

### Is this the current tutorial lesson? is_tutorial_lesson_active = reactive_advice_succession An interface trigger, can only be used in specific places
alias[trigger:is_tutorial_lesson_active] = replace_me

### Has the tutorial lesson chain with the specified key been finished? An interface trigger, can only be used in specific places
alias[trigger:is_tutorial_lesson_chain_completed] = replace_me

### Has the tutorial lesson step been finished? is_tutorial_lesson_step_completed = lesson_key:step_key An interface trigger, can only be used in specific places
alias[trigger:is_tutorial_lesson_step_completed] = replace_me

### is the war overview open at a specified tab (victory, defeat, white_peace)?  - An interface trigger, can only be used in specific places
alias[trigger:is_war_overview_tab_open] = replace_me

### Is the widget with the specified name open? Separting strings with dots will search for specific children of children eg: appa.foo vs baz.foo. Deprecated. Use `is_widgetid_open` instead for more stable and faster results.
alias[trigger:is_widget_open] = replace_me

###  Is the widget with the specified `widgetid` open (visible and not animating)? The fastest and safest way to check. (preferred over `is_widgetid_open`) An interface trigger, can only be used in specific places
alias[trigger:is_widgetid_open] = replace_me

### Checks the size of a list list_size = { name = X value >= Y } Where X is the name of the list Where Y is a script value
alias[trigger:list_size] = {
    name = value[list]
    value == alias_keys_field[int_value]
    value == value_field
}

### Checks the size of a variable list variable_list_size = { name = X target >= Y } Where X is the name of the variable Where Y is a script value or number
alias[trigger:local_variable_list_size] = {
    name = value[local_variable_list]
    value == alias_keys_field[int_value]
    value == value_field
}

### a negated AND trigger
alias[trigger:nand] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### a negated OR trigger
alias[trigger:nor] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### negates content of trigger
alias[trigger:not] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### at least one entry inside trigger must be true
alias[trigger:or] = {
    alias_name[trigger] = alias_match_left[trigger]
}



### Saves a temporary target for use during the trigger execution
alias[trigger:save_temporary_scope_as] = value_set[temporary_scope]

### Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect save_temporary_scope_value_as = { name = <string> value = x }
alias[trigger:save_temporary_scope_value_as] = {
    name = value_set[temporary_scope]
    value = alias_keys_field[int_value]
    value = single_alias_right[score_formula]
    value = value_field
}

### Switch on a trigger for the evaluation of another trigger with an optional fallback trigger. switch = { 	trigger = simple_assign_trigger 	case_1 = { <triggers> } 	case_2 = { <triggers> } 	case_n = { <triggers> } 	fallback = { <triggers> }
alias[trigger:switch] = {
    trigger = alias_keys_field[trigger]
    trigger = bool

    ## cardinality = 0..inf
    scope = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    int = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..inf
    scalar = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    ## cardinality = 0..1
    fallback = {
        alias_name[trigger] = alias_match_left[trigger]
    }
}

### Check if the current date is within the bounds time_of_year = {     min = 11.1 # default: beginning of year     max = 2.29 # default: end of year } Dates are formatted as "<month>.<day>" or just "<month>". The check includes the min and max dates. min can be larger than max, in this case we wrap around to the next year (i.e., February is between October and March).
alias[trigger:time_of_year] = {
    min = date_field
    max = date_field
}






### Evaluates the triggers if the display_triggers of preceding 'trigger_if' or 'trigger_else_if' is not mettrigger_if = { limit = { <display_triggers> } <triggers> }  trigger_else = { <triggers> }
alias[trigger:trigger_else] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### Evaluates the enclosed triggers if the display_triggers of the preceding `trigger_if` or `trigger_else_if` is not met and its own display_trigger of the limit is mettrigger_if = { limit = { <display_triggers> } <triggers> } trigger_else_if = { limit = { <display_triggers> } <triggers> }
alias[trigger:trigger_else_if] = {
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    alias_name[trigger] = alias_match_left[trigger]
}

### Evaluates the triggers if the display_triggers of the limit are met trigger_if = { limit = { <display_triggers> } <triggers> }
alias[trigger:trigger_if] = {
    limit = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    alias_name[trigger] = alias_match_left[trigger]
}

### Checks the size of a variable list variable_list_size = { name = X target >= Y } Where X is the name of the variable Where Y is a script value or number
alias[trigger:variable_list_size] = {
    name = value[variable_list]
    ## cardinality = 0..1
    target == alias_keys_field[int_value]
    ## cardinality = 0..1
    target == value_field
    ## cardinality = 0..1
    target == single_alias_right[score_formula]
    ## cardinality = 0..1
    value == alias_keys_field[int_value]
    ## cardinality = 0..1
    value == value_field
    ## cardinality = 0..1
    value == single_alias_right[score_formula]
}

### Returns true if the sum of weights of fulfilled sub-triggers amount to the specified sum weighted_calc_true_if = { amount = 10 5 = { <trigger> } 15 = { <trigger> } 7 = { <trigger> } }
alias[trigger:weighted_calc_true_if] = {
    amount == int_value_field
    ## cardinality = 1..inf
    int = {
        alias_name[trigger] = alias_match_left[trigger]
    }
}





### Checks whether the current scope has the specified variable set has_variable = name
alias[trigger:has_local_variable] = replace_me # TODO







#####################################################
# PROVINCE SCOPE
#####################################################

### Checks if a province is in a certain geographical region
## scope = province
alias[trigger:geographical_region] = <geographical_region>

### Checks if a province is in a certain geographical region
## scope = province
alias[trigger:geographical_region] = scope[geographical_region]

### does the scope province have a particular building? 	has_building = temple_01
## scope = province
alias[trigger:has_building] = <building>

### does the scope province have a building with a certain flag? 	has_building_with_flag = { flag = temple count >= 2 } 	has_building_with_flag = temple # count >= 1
## scope = province
alias[trigger:has_building_with_flag] = enum[building_flag]

### does the scope province have a building with a certain flag? 	has_building_with_flag = { flag = temple count >= 2 } 	has_building_with_flag = temple # count >= 1
## scope = province
alias[trigger:has_building_with_flag] = {
    flag = enum[building_flag]
    ## cardinality = 0..1
    count == alias_keys_field[int_value]
    ## cardinality = 0..1
    count == value_field
}

### does the scope province have a construction of a building with the specified flag? 	has_construction_with_flag = temple
## scope = province
alias[trigger:has_construction_with_flag] = enum[building_flag]

### does the scope province have a holding of particular type? 	has_holding_type = castle_holding
## scope = province
alias[trigger:has_holding_type] = <holding>

### Does the scoped province have a given modifier has_province_modifier = name
## scope = province
alias[trigger:has_province_modifier] = <modifier_container>

### Does the scoped province have the duration remaining on a given modifier has_province_modifier_duration_remaining = name
## scope = province
alias[trigger:has_province_modifier_duration_remaining] = <modifier_container>

### Does the province have stationed regiment of base type?
## scope = province
alias[trigger:has_stationed_regiment_of_base_type] = value[unit_type]

### Checks if there is a travel point of interest of type X in the province.
## scope = province
alias[trigger:has_travel_point_of_interest] = <point_of_interest>

### Date when the target epidemic infected the scoped province.
## scope = province
alias[trigger:province_infection_date] == date_field

### Checks if a province is of a specific terrain type
## scope = province
alias[trigger:terrain] = <terrain>

### How far away is the province/barony/county from the target? Measured in map pixels. Squared for performance reasons (square root is expensive). squared_distance = { target = some province/barony/county value > 10000 }
## scope = { province landed_title }
alias[trigger:squared_distance] == {
    ## cardinality = 0..1
    target = scope[landed_title]
    ## cardinality = 0..1
    target = scope[province]
    value == alias_keys_field[int_value]
    value == value_field
}

### Checks if a province's danger type is of a specific type for a specific travel plan
## scope = province
alias[trigger:travel_danger_type] == {
    travel_plan = scope[travel_plan]
    ## cardinality = 0..1
    type = enum[travel_danger]
    ## cardinality = 0..1
    terrain = <terrain>
}




#####################################################
# WAR SCOPE SCOPE
#####################################################

### does the war interaction still have a valid casus belli (those should be automatically removed on daily tick, but can exist for a tick)
## scope = war
alias[trigger:has_valid_casus_belli] == bool

### is the target character in the scope war as an attacker?
## scope = war
alias[trigger:is_attacker] == scope[character]

### Check if the scope war is a civil war or not
## scope = war
alias[trigger:is_civil_war] == bool

### is the target character in the scope war as a defender?
## scope = war
alias[trigger:is_defender] == scope[character]

### is the target character participating in the scope war as an attacker or defender?
## scope = war
alias[trigger:is_participant] == scope[character]

### is the target character leading one of the sides in the scope war?
## scope = war
alias[trigger:is_war_leader] == scope[character]

### Check if the scoped war's CB has is_white_peace_possible = yes
## scope = war
alias[trigger:is_white_peace_possible] == bool

### is the scope war using the specified CB? using_cb = religious_war
## scope = war
alias[trigger:using_cb] == <casus_belli_type>

### has the target character been called to the scope war already?
## scope = war
alias[trigger:was_called] == scope[character]

#####################################################
# HOLY ORDER SCOPE
#####################################################

#####################################################
# ACCOLADE SCOPE
#####################################################

### Does any of the Accolades types have the given category flag?
## scope = accolade
alias[trigger:has_accolade_category] == value[accolade_category]

### Does any of the Accolades unlocked ranks have the given parameter flag?
## scope = accolade
alias[trigger:has_accolade_parameter] == value[accoldate_parameter]

### Does the Accolade have the given type?
## scope = accolade
alias[trigger:has_accolade_type] == <accolade>

### Does the given Accolade's Owner have any character in their court ( including guests ) that could act as Successor of this Accolade if made into a Knight?
## scope = accolade
alias[trigger:has_potential_accolade_successors] == bool

###Is the scoped Accolade active, i.e. assinged by their Liege?
## scope = accolade
alias[trigger:is_accolade_active] == bool

### Is the scoped Accolade's primary type tier equal to?
## scope = accolade
alias[trigger:primary_tier] = enum[accolade_tier]

### Is the scoped Accolade's secondary type tier equal to?
## scope = accolade
alias[trigger:secondary_tier] = enum[accolade_tier]

#####################################################
# LEGEND SCOPE
#####################################################

### Does the legend have the given localization key set for the named chapter. has_legend_chapter = { name = opening localization_key = default_legend_opening }
## scope = legend
alias[trigger:has_legend_chapter] = localisation

# TODO
### Does the scoped legend have the specified legend chronicle.
## scope = legend
alias[trigger:has_legend_chronicle] = <chronicle>

### Does the scoped legend have a given modifier affecting the counties
## scope = legend
alias[trigger:has_legend_county_modifier] = <modifier_container>

### Does the scoped legend have the duration remaining on a given modifier affecting the counties
## scope = legend
alias[trigger:has_legend_county_modifier_duration_remaining] = <modifier_container>

### Does the scoped legend have a given modifier affecting the owner
## scope = legend
alias[trigger:has_legend_owner_modifier] = <modifier_container>

### Does the scoped legend have the duration remaining on a given modifier affecting the owner
## scope = legend
alias[trigger:has_legend_owner_modifier_duration_remaining] = <modifier_container>

### Does the scoped legend have a given modifier affecting the provinces
## scope = legend
alias[trigger:has_legend_province_modifier] = <modifier_container>

### Does the scoped legend have the duration remaining on a given modifier affecting the provinces
## scope = legend
alias[trigger:has_legend_province_modifier_duration_remaining] = <modifier_container>

### Date when the legend was completed.
## scope = legend
alias[trigger:legend_completion_date] == date_field

### Get the quality of this legend. legend_quality = famed
## scope = legend
alias[trigger:legend_quality] = enum[legend_quality]

### Date when the legend was created.
## scope = legend
alias[trigger:legend_start_date] == date_field

#####################################################
# SCHEME SCOPE
#####################################################

### Is the scheme currently affected by the specified modifier? has_scheme_modifier = X
## scope = scheme
alias[trigger:has_scheme_modifier] = <modifier_container>

###  Does the scheme have the given category? Supported categories: 'hostile', 'contract', 'political', and 'personal'.
## scope = scheme
alias[trigger:is_scheme_category] = enum[scheme_category]

###  Does the scheme have a target of the given type?
## scope = scheme
alias[trigger:is_scheme_target_type] = enum[scheme_target_type]

# NOTE: Incorrectly documented in log
### Scheme skill
## scope = scheme
alias[trigger:scheme_skill] = enum[attribute]

### Is the scheme of the specified type? scheme_type = X
## scope = scheme
alias[trigger:scheme_type] = <scheme>

#####################################################
# STORY SCOPE
#####################################################

### Is the story in scope of this type?
alias[trigger:story_type] = <story_cycle>



#####################################################
# COMBAT SCOPE
#####################################################

#####################################################
# LANDED TITLE SCOPE
#####################################################

### Can create MaA of specified type for the scoped title
## scope = landed_title
alias[trigger:can_create_title_maa] = landed_title

### can the title create the faction of the specified type against the specified character? can_title_create_faction = { type = X target = Y }
## scope = landed_title
alias[trigger:can_title_create_faction] = {
    type = <faction>
    target = scope[character]
}

### compares the county's opinion of the target character to the specified value, county_opinion_target = { target = X value >/</= Y }
## scope = landed_title
alias[trigger:county_opinion_target] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

### Compare drift progress towards target with value<drifting_title> = { de_jure_drif_progress = {     target = <drift_target_title>    value > 50 } }
## scope = landed_title
alias[trigger:de_jure_drift_progress] = {
    target = scope[landed_title]
    value == alias_keys_field[int_value]
    value == value_field
}

### Does the scoped county have a given modifier has_county_modifier = name
## scope = landed_title
alias[trigger:has_county_modifier] = <modifier_container>

### Does the scoped county have the duration remaining on a given modifier has_county_modifier_duration_remaining = name
## scope = landed_title
alias[trigger:has_county_modifier_duration_remaining] = <modifier_container>

### Does the county have a holy site with the given flag? has_holy_site_flag = some flag
## scope = landed_title
alias[trigger:has_holy_site_flag] = value[holy_site_flag]

### Does the scoped title have a given order of succession has_order_of_succession = election
## scope = landed_title
alias[trigger:has_order_of_succession] = enum[order_of_succession]

### Does the scoped title have the given title-specifc-law?
## scope = landed_title
alias[trigger:has_title_law] = <law>

### Does the scoped title have a title-specific law with the given flag?
## scope = landed_title
alias[trigger:has_title_law_flag] = value[law_flag]

### Is the county connected to the other county? Is based on top liege is_connected_to = { 	max_naval_distance = 500 	allow_one_county_land_gap = yes 	target = some other county }
## scope = landed_title
alias[trigger:is_connected_to] = {
    ## cardinality = 0..1
    max_naval_distance = int_value_field # TODO
    allow_one_county_land_gap = bool
    target = scope[landed_title]
}

### Is the county currently affected by the specified council task? Needs to be in a county title scope
## scope = landed_title
alias[trigger:is_target_of_council_task] = <council_task>




### What's the multiplier to the control decline rate? E.G., if there's just a +20% modifier, this would return 1.2
## scope = landed_title
alias[trigger:monthly_county_control_decline_factor] == float

### What's the multiplier to the control growth rate? E.G., if there's just a +20% modifier, this would return 1.2
## scope = landed_title
alias[trigger:monthly_county_control_growth_factor] == float


enums = {
    enum[recent_history_type] = { # TODO
        conquest
        conquest_holy_war
        conquest_claim
        conquest_populist
        election
        inheritance
        abdication
        created
        destroyed
        usurped
        granted
        revoked
        independency
        leased_out
        lease_revoked
        returned
        faction_demand
        swear_fealty
        stepped_down
        appointment
        appointment_succession
    }
}

### Does the scope title have a history entry of the specified type in recent history? recent_history = { type = X days/months/years = Y } (the type can be omitted, all history types are considered then)
## scope = landed_title
alias[trigger:recent_history] = {
    ## cardinality = 0..1
    type = enum[recent_history_type]
    enum[duration] = alias_keys_field[int_value]
    enum[duration] = value_field
}

### What tier is the scoped title? barony = 1, empire = 5. Use the script values please, not raw numbers
## scope = landed_title
alias[trigger:tier] = enum[title_tier]

### Check if the chance to create a faction against a target of the scope landed title is is true against the scripted value title_create_faction_type_chance = {     type = faction_type #An ongoing faction     target = target_character     value <|<=|>=|> 0 }
## scope = landed_title
alias[trigger:title_create_faction_type_chance] = {
    type = <faction>
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

### Check if the chance of the scope landed title to join the faction against the scripted value title_join_faction_chance = {     faction = faction_target #An ongoing faction     value <|<=|>=|> 0 }
## scope = landed_title
alias[trigger:title_join_faction_chance] = {
    faction = scope[faction]
    value == alias_keys_field[int_value]
    value == value_field
}



#####################################################
# FACTION SCOPE
#####################################################

### Is the faction of this type?
## scope = faction
alias[trigger:faction_is_type] = <faction>

#####################################################
# COMBAT SIDE SCOPE
#####################################################

### Does this combat side have at least one MaA of the given regiment type? has_maa_of_type = onager
## scope = combat_side
alias[trigger:has_maa_of_type] = <maa_type>

#####################################################
# DOMICILE SCOPE
#####################################################

### Does scoped domicile have building of specified type?
## scope = domicile
alias[trigger:has_domicile_building] = <domicile_building>

### Does scoped domicile have building or one of its upgrades?
## scope = domicile
alias[trigger:has_domicile_building_or_higher] = <domicile_building>

### Does scoped domicile have parameter in one or more of its buildings?
## scope = domicile
alias[trigger:has_domicile_parameter] = enum[domicile_parameter]

### Does the scoped domicile have an ongoing construction?) scope:domicile = {	has_ongoing_construction = yes/no }
## scope = domicile
alias[trigger:has_ongoing_domicile_construction] == bool

### Is the scoped domicile of domicile type?
## scope = domicile
alias[trigger:is_domicile_type] = <domicile_type>

#####################################################
# INSPIRATION SCOPE
#####################################################

### Checks if the scoped inspiration has the given inspiration 
## scope = inspiration
alias[trigger:has_inspiration_type] == <inspiration>

#####################################################
# COLOR SCOPE
#####################################################

#####################################################
# WAR SCOPE
#####################################################

### is the scope war using the specified CB? using_cb = religious_war
## scope = war
alias[trigger:using_cb] = <casus_belli_type>

### Checks how much a character has contributed to the scoped war
## scope = war
alias[trigger:war_contribution] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}


#####################################################
# CHARACTER SCOPE
#####################################################

# -A

### is the character old/young enough?
## scope = character
alias[trigger:age] == {
    ## cardinality = 0..2
    alias_keys_field[int_value]
    ## cardinality = 0..2
    value_field
}

enums = {
    enum[diplomacy_stance] = {
        enemy
        friend
        threat
        neutral
    }
}

### The AI's diplomatic view of the target character (enemy, friend, threat or neutral)  Takes the parameters "target" (character) and "stance" (enemy, friend, threat, neutral)
## scope = character
alias[trigger:ai_diplomacy_stance] = {
    target = scope[character]
    stance = enum[diplomacy_stance]
}

### check if all the scoped characters court artifact slots are empty or full
## scope = character
alias[trigger:all_court_artifact_slots] == enum[full_or_empty]

### check if all the scoped characters inventory artifact slots are empty or full
## scope = character
alias[trigger:all_inventory_artifact_slots] == enum[full_or_empty]

### Compares the scoped character's amenity level in the given type to the given value
## scope = character
alias[trigger:amenity_level] = {
    type = <court_amenity_category>
    value == alias_keys_field[int_value]
    value == value_field
}

### Charater's accumulated score for appointment for the target title.Only investment count, and not character personality.appointment_candidate_accumulated_score = {    title = scope:title    value >= scope:fixed_point }
## scope = character
alias[trigger:appointment_candidate_accumulated_score] = {
    title = scope[landed_title]
    value == float
}

### appointment_candidate_score - Charater's total score for appointment for the target title appointment_candidate_score = {    title = scope:title    value >= scope:fixed_point }
## scope = character
alias[trigger:appointment_candidate_score] = {
    title = scope[landed_title]
    value == float
}

### Is the amenity level of root's royal court better than the target
## scope = character
alias[trigger:aptitude] = {
    court_position = <court_position>
    value == alias_keys_field[int_value]
    value == value_field
}

### Average opinion of the character that are NOT powerful vassals of the faction scope target
## scope = character
alias[trigger:average_faction_opinion_not_powerful_vassal] == replace_me_comparison

# -B

# -C

### will trying to hook the target character override the current hook? (if no current hook, always returns true) can_add_hook = { target = <character> type = <hook type> days/months/year = whatever (optional; will use the duration from the type if not provided) }
## scope = character
alias[trigger:can_add_hook] = {
    target = scope[character]
    type = <hook>
    ##cardinality = 0..1
    enum[duration] = alias_keys_field[int_value]
    ##cardinality = 0..1
    enum[duration] = value_field
}

### Scoped character can be employed as target court position, uses valid_character trigger
## scope = character
alias[trigger:can_be_employed_as] = <court_position>

### Can the scoped character become owner of the provided legend? scope:character = {	can_become_owner_of_legend = <legend>}
## scope = character
alias[trigger:can_become_owner_of_legend] = scope[legend]

### can the character create the faction of the specified type against the specified character? can_create_faction = { type = X target = Y }
## scope = character
alias[trigger:can_create_faction] = {
    type = <faction>
    target = scope[character]
}

### Can target character create MaA of specified type
## scope = character
alias[trigger:can_create_maa] = <maa_type>

### scope:owner = { can_create_task_contact = { type_name = <key> employer = <character> } 
## scope = character
alias[trigger:can_create_task_contract] = {
    type_name = <task_contract>
    employer = scope[character]
}

### Can the scoped character declare war on the defender with the specified casus bellis on the defender character for the target titles with an optional claimant. can_declare_war = { defender = X casus_belli = Y target_titles = { Z } claimant = A }
## scope = character
alias[trigger:can_declare_war] = {
    defender = scope[character]
    casus_belli = <casus_belli_type>
    target_titles = {
        ## cardinality = 1..inf
        <landed_title>
        ## cardinality = 1..inf
        scope[landed_title]
    }
    claimant = scope[character]
}

### Can scoped charater embrace new culture tradition?
## scope = character
alias[trigger:can_embrace_tradition] = scope[tradition]
alias[trigger:can_embrace_tradition] = {
    tradition = scope[tradition]
    replace = <tradition>
}

### Can the scoped character employ the target court position type and is the position vacant?
## scope = character
alias[trigger:can_employ_court_position_type] = <court_position>

### Is the scoped character able to execute the asigned decision?
## scope = character
alias[trigger:can_execute_decision] = <decision>

### target_activity Can the scoped character host the target activity type
## scope = character
alias[trigger:can_host_activity] = <activity>
## scope = character
alias[trigger:can_join_or_create_faction_against] = {
    who = scope[character]
    ## cardinality = 0..1
    faction = <faction>
    ## cardinality = 0..1
    check_in_a_faction = bool
}

### can the character start the scheme? can_start_scheme = { type = X target = Y }
## scope = character
alias[trigger:can_start_scheme] = {
    type = <scheme>
    ## cardinality = 0..1
    target_character = scope[character]
    ## cardinality = 0..1
    target_title = scope[landed_title]
}

### Can the scoped character sponsor the target inspiration
## scope = character
alias[trigger:can_sponsor_inspiration] = {
    type = <scheme>
    target = scope[character]
}

### does the character controls all counties and baronies inside the specified region (no hostile occupation either)?
## scope = character
alias[trigger:completely_controls_region] = <geographical_region>

### Check if the chance to create a faction against a target of the scope character is is true against the scripted value create_faction_type_chance = {     type = faction_type #An ongoing faction     target = target_character     value <|<=|>=|> 0 }
## scope = character
alias[trigger:create_faction_type_chance] = {
    type = <faction>
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

# -D

### Does the scoped character have the given death reason? death_reason = death_natural_causes
## scope = character
alias[trigger:death_reason] = <death_reason>

### does the character have the required diplomacy skill level difference against target? diplomacy = { target = character value <= script_value abs = yes/no(optional, default no) }
## scope = character
alias[trigger:diplomacy_diff] == {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
    ## cardinality = 0..1
    abs == bool
}

### Is the scoped character's domain this big in comparison to their limit?
## scope = character
alias[trigger:domain_limit_percentage] == float[0.0..1.0]


# -E

### Scoped character employs target court position
## scope = character
alias[trigger:employs_court_position] = <court_position>

# -F



# -G

# NOTE: only used once for create_cadet_branches
### checks if the government of the character allows something
## scope = character
alias[trigger:government_allows] = enum[government_rule]

### checks if the government of the character disallows something
## scope = character
alias[trigger:government_disallows] = enum[government_rule]

### checks if the government of the character has a specific flag
# TODO: support autocomplete
## scope = character
alias[trigger:government_has_flag] = value[government_flag]

# -H

### Does the diarch have this mandate active?
## scope = character
alias[trigger:has_active_mandate] = <diarchy_mandate>

### Does the scoped character have the given activity intent
## scope = character
alias[trigger:has_activity_intent] = <activity_intent>

enums = {
    enum[activity_state] = {
        travel
        passive
        active
    }
}

### Does the scoped character have the given state in their currenty involved activity? Possible states: travel passive active
## scope = character
alias[trigger:has_activity_state] = enum[activity_state]

### does the scope character have the specified casus bellis on the taget character? Invalid target returns false automatically. has_cb_on = { target = X casus_belli/cb = Y }
## scope = character
alias[trigger:has_cb_on] = {
    target = scope[character]
    casus_belli = <casus_belli_type>
}

### Does the character have this flag?
## scope = character
alias[trigger:has_character_flag] = value[character_flag]

### Does the scoped character have a given modifier has_character_modifier = name
## scope = character
alias[trigger:has_character_modifier] = <modifier_container>

### Does the scoped character have the duration remaining on a given modifier has_character_modifier_duration_remaining = name
## scope = character
alias[trigger:has_character_modifier_duration_remaining] = <modifier_container>

### Has the scoped character completed an intent of the given type in their involved activity, optionally against a specific target.
## scope = character
alias[trigger:has_completed_activity_intent] = { 
    type = <activity_intent>
    target = scope[character]
}

### Has the scoped character completed an intent of the given type in their involved activity, optionally against a specific target.
## scope = character
alias[trigger:has_completed_activity_intent] = <activity_intent>

### Does the scoped character have the given position?
## scope = character
alias[trigger:has_council_position] = <council_position>

### does the scope character have a councillor for the specified skill? 	has_councillor_for_skill = X, where X is a skill name or 'general'
## scope = character
alias[trigger:has_councillor_for_skill] = enum[attribute]

### does the scope character have a councillor for the specified skill? 	has_councillor_for_skill = X, where X is a skill name or 'general'
## scope = character
alias[trigger:has_councillor_for_skill] = general

### Is the character's court language the given language?
## scope = character
alias[trigger:has_court_language] = <pillar.language>

### Trigger to check if the target character has a court position. 
## scope = character
alias[trigger:has_court_position] = <court_position>

### Does the character have this court type?
## scope = character
alias[trigger:has_court_type] = <court_type>

### Does the dead character have this flag?
## scope = character
alias[trigger:has_dead_character_flag] = scope[flag]

### Does the dead character have this variable?
## scope = character
alias[trigger:has_dead_character_variable] = value[dead_variable]

### Does active diarchy have this parameter active for current power level?
## scope = character
alias[trigger:has_diarchy_active_parameter] = value[diarchy_parameter]

### Can active diarchy have this parameter at some power level?
## scope = character
alias[trigger:has_diarchy_parameter] = value[diarchy_parameter]

### Is scope character in a diarchy of a specific type?
## scope = character
alias[trigger:has_diarchy_type] = <diarchy>

### How much is scared the scope character agains the target. 0 = not intimidated, 1 = intimidated, 2 = cowed. has_dread_level_towards = { target = X level >/</>=/<=/= Y  }
## scope = character
alias[trigger:has_dread_level_towards] = {
    target = scope[character]
    level == alias_keys_field[int_value]
    level == int_value_field
}

### Is the target character voting for the scoped character in the election of the target title has_election_vote_of = { who = scope:actor title = primary_title }
## scope = character
alias[trigger:has_election_vote_of] = {
    who = scope[character]
    title = scope[landed_title]
}

### Does the character have this focus?
## scope = character
alias[trigger:has_focus] = <focus>

### Does the character have the specified gene template? Only works for morph genes. An interface trigger. has_gene = { category = X template = Y } An interface trigger, can only be used in specific places
## scope = character
alias[trigger:has_gene] = {
    category = <morph_gene>
    category = <special_morph_gene>
    template = <morph_gene_template>
    template = <special_morph_gene_template>
}

### checks if the character has a specific government type
## scope = character
alias[trigger:has_government] = <government>

### does the character have a hook on the target of the given type?, has_hook_of_type = { target = X type = Y }
## scope = character
alias[trigger:has_hook_of_type] = {
    target = scope[character]
    type = <hook>
}

### Does the character have this trait or a trait of this trait group amongst their inactive traits?
## scope = character
alias[trigger:has_inactive_trait] = <trait>

### Does the scoped character's current legitimacy level have the given flag
## scope = character
alias[trigger:has_legitimacy_flag] = value[legitimacy_flag]

### Does the character have this trait or a trait of this trait group amongst their inactive traits?
## scope = character
alias[trigger:has_inactive_trait] = value[trait_group]

### Does the character have this lifestyle?
## scope = character
alias[trigger:has_lifestyle] = <lifestyle>

### Does the character have this nickname?
## scope = character
alias[trigger:has_nickname] = <nickname>

### does the character have the specified opinion modifier on the target? (optional *value <|<=|=|>=|> X* or *value = { MIN MAX }* inclusive)
## scope = character
alias[trigger:has_opinion_modifier] = {
    modifier = <opinion_modifier>
    target = scope[character]
    ## cardinality = 0..1
    value == int_value_field
    ## cardinality = 0..1
    value == alias_keys_field[int_value]
    ## cardinality = 0..1
    value == single_alias_right[score_formula]
}

### Does the scope character have an opposite relationship of the relation value with the target character? target = , relation =
## scope = character
alias[trigger:has_opposite_relation] = {
    target = scope[character]
    relation = <scripted_relation>
}


### Does the character have a pending interaction of the type? Only works if the scope is player-controlled. Example: has_pending_interaction = interaction_key
## scope = character
alias[trigger:has_pending_interaction_of_type] = <character_interaction>

### Does the scoped character have a legend seed of the specified legend type?.
## scope = character
alias[trigger:has_personal_legend_seed] = <legend_type>

### Does the character have this perk?
## scope = character
alias[trigger:has_perk] = <lifestyle_perk>

### Does the scoped character have the given realm law?
## scope = character
alias[trigger:has_realm_law] = <law>

### Does the scoped character have a law with the given flag?
## scope = character
alias[trigger:has_realm_law_flag] = value[law_flag]

### Check if has a relation flag in a particular relation with the target character.
## scope = character
alias[trigger:has_relation_flag] = single_alias_right[relation_flag_clause]

### Does the given ruler, or the liege of the given courtier, have a countermeasure with the given parameter? Can only check for boolean parameters.
## scope = character
alias[trigger:has_scheme_countermeasure_parameter] = enum[scheme_countermeasure_parameter]

### Does the character's sexuality match the scripted? (heterosexual, homosexual, bisexual, asexual, none). Characters that have yet to get a sexuality (children) have the none set.
## scope = character
alias[trigger:has_sexuality] = <game_concept.sexuality>

### Does the character's sexuality match the scripted? (heterosexual, homosexual, bisexual, asexual, none). Characters that have yet to get a sexuality (children) have the none set.
## scope = character
alias[trigger:has_sexuality] = none

### Does the character have this trait?  Can also specify a trait group, in which case the trigger will return true if the scope character has any trait from that trait group.
## scope = character
alias[trigger:has_trait] = value[trait_group]

### Does the character have this trait?  Can also specify a trait group, in which case the trigger will return true if the scope character has any trait from that trait group.
## scope = character
alias[trigger:has_trait] = <trait>

### Does the character have this trait?  Can also specify a trait group, in which case the trigger will return true if the scope character has any trait from that trait group.
## scope = character
alias[trigger:has_trait] = scope[trait]

### Compare the trait rank of a character to a value or other character. Note that not having the trait and having rank 0 counts as the same thing. rank < X on its own will therefore always return true for a character that does not have the trait. has_trait_rank = { trait = TRAIT_GROUP rank <=> number (can be script value) character <=> character target }. need only one of rank or character
## scope = character
alias[trigger:has_trait_rank] = {
    trait = value[trait_group]
    ## cardinality = 0..1
    rank == alias_keys_field[int_value]
    ## cardinality = 0..1
    rank == value_field
    ## cardinality = 0..1
    character == scope[character]
}

### does the scope character have a trait with a certain flag? 	has_trait_with_flag = can_not_marry
## scope = character
alias[trigger:has_trait_with_flag] = value[trait_flag]

### Checks if the scopd character has the given amount of XP in the trait level track. Track name is required if the trait has multiple tracks, otherwise should not be provided.
## scope = character
alias[trigger:has_trait_xp] = {
    trait = <trait>
    ## cardinality = 0..1
    track = enum[trait_track]
    value == alias_keys_field[int_value]
    value == value_field
}

### Does the scoped character qualify for the specified triggered legend seed?.
## scope = character
alias[trigger:has_triggered_legend_seed] = <legend_type>

### Does the scoped vassal character have the given vassal stance
## scope = character
alias[trigger:has_vassal_stance] = <vassal_stance>

### Is the skill the highest skill of the character? True even when there are multiple skills with the same highest value.
## scope = character
alias[trigger:highest_skill] = enum[attribute]

### what is the highest held landed title tier of the character?
## scope = character
alias[trigger:highest_held_title_tier] = enum[title_tier]

### For how long has the scope character been a hostage? { days/months/years =,>,< X }
## scope = character
alias[trigger:hostage_duration] = single_alias_right[duration_block]


# -I

### is there an important action available to the character, but they dismissed it? important_action_is_valid_but_invisible = important_action_key
## scope = character
alias[trigger:important_action_is_valid_but_invisible] = <suggestion>

### is there an important action shown to the character? important_action_is_visible = important_action_key
## scope = character
alias[trigger:important_action_is_visible] = <suggestion>

### does the character have the required intrigue skill level difference against target? intrigue = { target = character value <= script_value abs = yes/no(optional, default no) }
## scope = character
alias[trigger:intrigue_diff] == {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
    ## cardinality = 0..1
    abs = bool
}


### Is the given activity type on cooldown for the current character.
## scope = character
alias[trigger:is_activity_type_on_cooldown] = <activity>

### Is the character interaction specified available and potentially accepted for the target character? is_character_interaction_potentially_accepted = { recipient = character interaction = interaction_name secondary_actor = character <optional> secondary_recipient = character <optional> target_title = title <optional>}
## scope = character
alias[trigger:is_character_interaction_potentially_accepted] = {
    recipient = scope[character]
    interaction = <character_interaction>
    ## cardinality = 0..1
    secondary_actor = scope[character]
    ## cardinality = 0..1
    secondary_recipient = scope[character]
    ## cardinality = 0..1
    target_title = scope[landed_title]
}

### Is the character interaction specified shown for the target character? is_character_interaction_shown = {     recipient = character     interaction = interaction_name }
## scope = character
alias[trigger:is_character_interaction_shown] = {
    recipient = scope[character]
    interaction = <character_interaction>
}

### Is the character interaction specified valid (shown and usable) for the target character? is_character_interaction_valid = {     recipient = character     interaction = interaction_name }
## scope = character
alias[trigger:is_character_interaction_valid] = {
    recipient = scope[character]
    interaction = <character_interaction>
}

### Check if the task of the scope councillor is valid { task_type = council_position_type_key target = for_targeted_tasks }
## scope = character
alias[trigger:is_council_task_valid] = {
    task_type = <council_task>
    ## cardinality == 0..1
    target = scope
}

### is the scoped character employed in the target position by target character
## scope = character
alias[trigger:is_court_position_employer] = {
    court_position = <court_position>
	who = scope[character]
}

### is the target character in the scope war as a defender?
## scope = character
alias[trigger:is_decision_on_cooldown] = <decision>

### Is the scoped decision an important decision for the target character?
## scope = character
alias[trigger:is_important_decision] = <decision>

### Is the scoped character in the specified guest subset in the activity they are involved in? 
## scope = character
alias[trigger:is_in_guest_subset] = {
    name = value[guest_subset]
    ## cardinality = 0..1
    phase = value[activity_phase]
}

### is the character imprisoned in a prison of the specified type?  Accepts "dungeon" or "house_arrest"
## scope = character
alias[trigger:is_in_prison_type] = enum[prison_type]

### Is the character leading a faction of the specified type?
## scope = character
alias[trigger:is_leading_faction_type] = <faction>

### Is the scoped character performing the given task?
## scope = character
alias[trigger:is_performing_council_task] = <council_task>

### Checks whether the scope character is an owner or an owner agent in a scheme agains target. There are 3 possible ways to use it: is_scheming_against = { target = X type = Y } limits to schemes of type Y is_scheming_against = { target = X scheme_skill = Y } limits to schemes of Y skill category is_scheming_against = { target = X } considers all schemes
## scope = character
alias[trigger:is_scheming_against] = {
    target = scope[character]
    ## cardinality = 0..1
    alias_name[scheming_against_target] = alias_match_left[scheming_against_target]
}

### is the scoped character valid for the given event, without checking event cooldown? NOTE: this is only for debug purposes and will not work in release mode!
## scope = character
alias[trigger:is_valid_for_event_debug] = <event>

### is the scoped character valid for the given event, including a cooldown check? NOTE: this is only for debug purposes and will not work in release mode!
## scope = character
alias[trigger:is_valid_for_event_debug_cooldown] = <event>

### Does the scoped character fulfill the requirements for being employed as the targeted court position type?
## scope = character
alias[trigger:is_valid_to_hire_court_position_type] = <court_position>




# -J

### Check if the chance of the scope character to join the faction against the scripted value join_faction_chance = {     faction = faction_target #An ongoing faction     value <|<=|>=|> 0 }
## scope = character
alias[trigger:join_faction_chance] = {
    target = scope[faction]
    value == alias_keys_field[int_value]
    value == value_field
}



### Check if the change of the scope character is between the given range (being min and max exclusive) join_scheme_chance = {     scheme = scheme_target #An ongoing scheme     max = 0     min = -10 }
## scope = character
alias[trigger:join_scheme_chance] = {
    scheme = scope[scheme]
    ## cardinality = 0..1
    max == alias_keys_field[int_value]
    ## cardinality = 0..1
    max == value_field
    ## cardinality = 0..1
    min == alias_keys_field[int_value]
    ## cardinality = 0..1
    min == value_field
}

# -K

### Does the character know the court language of the target character?
## scope = character
alias[trigger:knows_court_language_of] == scope[character]

### Does the character know the language?
## scope = character
alias[trigger:knows_language] == <pillar.language>

### Does the character know the language of the target culture?
## scope = character
alias[trigger:knows_language_of_culture] == scope[culture]

# -L

### does the character have the required learning skill level difference against target? learning = { target = character value <= script_value abs = yes/no(optional, default no) }
## scope = character
alias[trigger:learning_diff] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
    ## cardinality = 0..1
    abs = bool
}


# -M

### does the character have the required martial skill level?
## scope = character
alias[trigger:martial] == single_alias_right[score_formula]

### does the character have the required martial skill level difference against target? martial = { target = character value <= script_value abs = yes/no(optional, default no) }
## scope = character
alias[trigger:martial_diff] == {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
    ## cardinality = 0..1
    abs = bool
}

### Is the scoped character's monthly military prestige expenses this big? (unraised maa costs). character = { morph_gene_attribute = { category = gene_height attribute = body_height value < 0.05 } }
## scope = character
alias[trigger:morph_gene_attribute] == {
    category = <gene>
    attribute = <gene>
    value == alias_keys_field[int_value]
    value == value_field
}

### Compare value of specific gene. Does NOT take into account trait modifiers scope:character = {	morph_gene_attribute = {		category = gene_height		value < 0.05	}}scope:character = {	morph_gene_value:gene_baldness > 0.05	0.05 < morph_gene_value:gene_baldness}An interface trigger, can only be used in specific places
## scope = character
alias[trigger:morph_gene_value] == {
    category = <gene>
    value == alias_keys_field[int_value]
    value == value_field
}



# -N


### Does the scoped character have this number of virtous traits? num_virtous_traits > 5 ORnum_virtous_traits = { value > 5 faith = scope:faith }, to base it on what a specific faith considers virtuous
## scope = character
alias[trigger:num_sinful_traits] = {
    value == alias_keys_field[int_value]
    value == value_field
    faith = scope[faith]
}

### Does the scoped character have this number of virtous traits? num_virtous_traits > 5 ORnum_virtous_traits = { value > 5 faith = scope:faith }, to base it on what a specific faith considers virtuous
## scope = character
alias[trigger:num_virtuous_traits] == {
    value == alias_keys_field[int_value]
    value == value_field
    faith = scope[faith]
}

### Does the scope character have value amount of MaA of the base type?
## scope = character
alias[trigger:number_maa_regiments_of_base_type] == {
    type = value[unit_type]
    value == alias_keys_field[int_value]
    value == int_value_field
}

### Does the scope character have value amount of MaA of the type?
## scope = character
alias[trigger:number_maa_regiments_of_type] == {
    type = <maa_type>
    value == alias_keys_field[int_value]
    value == int_value_field
}

### Does the scope character have value amount of soldiers of MaA of the base type?
## scope = character
alias[trigger:number_maa_soldiers_of_base_type] == {
    type = value[unit_type]
    value == alias_keys_field[int_value]
    value == int_value_field
}

### Does the scope character have value amount of soldiers of MaA of the type?
## scope = character
alias[trigger:number_maa_soldiers_of_type] == {
    type = <maa_type>
    value == alias_keys_field[int_value]
    value == int_value_field
}

### does the character and the target have a number of commander traits in common? number_of_personality_traits_in_common = { target = X value >/</>=/<= Y }
## scope = character
alias[trigger:number_of_commander_traits_in_common] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

### Check the number of votes the scoped character has in the target title number_of_election_votes = { title = scope:actor.primary_title value = 0 }
## scope = character
alias[trigger:number_of_election_votes] = {
    title = scope[landed_title]
    value == alias_keys_field[int_value]
    value == value_field
}


### does the character and the target have a number of opposing personality traits? number_of_opposing_personality_traits = { target = X value >/</>=/<= Y }
## scope = character
alias[trigger:number_of_opposing_personality_traits] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

### does the character and the target have a number of opposing traits? number_of_opposing_traits = { target = X value >/</>=/<= Y }
## scope = character
alias[trigger:number_of_opposing_traits] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

### does the character and the target have a number of personality traits in common? number_of_personality_traits_in_common = { target = X value >/</>=/<= Y }
## scope = character
alias[trigger:number_of_personality_traits_in_common] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

### do the two characters share a number of traits that is considered sinful by both of their respective faiths?
## scope = character
alias[trigger:number_of_sinful_traits_in_common] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

### does the character and the target have a number of traits in common? number_of_traits_in_common = { target = X value >/</>=/<= Y }
## scope = character
alias[trigger:number_of_traits_in_common] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}
### do the two characters share a number of traits that is considered virtuous by both of their respective faiths?
## scope = character
alias[trigger:number_of_virtue_traits_in_common] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}

# Poorly documented
### Does the scope character have value amount of MaA of the type for their controlled title troops?
## scope = character
alias[trigger:number_title_maa_regiments_of_type] = {
    type = <maa_type>
    value == alias_keys_field[int_value]
    value == value_field
}


# -O

### is the character's opinion of the target greater or equal than the value? opinion = { target = X [*value >/</>=/<= Y* or *value = { min max }*  }
## scope = character
alias[trigger:opinion] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
    value == single_alias_right[score_formula]
}

### Does the character own a story of this type?
## scope = character
alias[trigger:owns_story_of_type] = <story_cycle>

# -P

### what place in line of succession does the character hold?
## scope = landed_title
alias[trigger:place_in_line_of_succession] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == int_value_field
}

### does the character have the required prowess skill level difference against target? prowess = { target = character value <= script_value abs = yes/no(optional, default no) }
## scope = character
alias[trigger:prowess_diff] == {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
    ## cardinality = 0..1
    abs = bool
}

# -Q

# -R

### Is the character's realm within this distance of the title? Distance is in pixels, squared for performance reasons. realm_to_title_distance_squared = { title = some_title value > 10000 }
## scope = character
alias[trigger:realm_to_title_distance_squared] = {
    title = scope[landed_title]
    value == alias_keys_field[int_value]
    value == value_field
}

### is the target character's opinion of the scope character greater or equal than the value? opinion = { target = X value >/</>=/<= Y }
## scope = character
alias[trigger:reverse_opinion] = {
    target = scope[character]
    value == int_value_field
    value == alias_keys_field[int_value]
}

### does the target have the specified opinion modifier on the character? (optional *value <|<=|=|>=|> X* or *value = { MIN MAX }* inclusive)
alias[trigger:reverse_has_opinion_modifier] = {
    target = scope[character]
    modifier = <opinion_modifier>
}

# -S

### Is the scoped decision an important decision for the target character?
## scope = character
alias[trigger:should_decision_create_alert] == <decision>

### Should the scoped character be alerted that they can host the target activity type
## scope = character
alias[trigger:should_notify_can_host_activity] == <activity>

### Should the scoped character be alerted that they can join the target activity type
## scope = character
alias[trigger:should_notify_can_join_open_activity] == <activity>

### Check if this character 'matches' a group, with a certain match percentage. A match value can range from 0.0 to 1.0. (0% to 100%) A static group filter means: this character will always get the same result against the same group. (there is no 'random' involved beyond the name of the group) On average (across all characters), an 0.1 match means you would get 'yes' for 10% of the characters to match this group, and it would always be the same characters for the same group. static_group_filter = {    group = <a_group_id>    match = 0.1} Instead of a group id, you can supply a scope, and it will use that scope's value as the group 'id'. static_group_filter = {    scope = <any_scope>    match = 0.1}
## scope = character
alias[trigger:static_group_filter] = {
    ## cardinality = 0..1
    group = value_set[static_group_filter] # TODO
    ## cardinality = 0..1
    scope = scope_field
    match == float
    match == single_alias_right[score_formula]
}

### does the character have the required stewardship skill level difference against target? stewardship = { target = character value <= script_value abs = yes/no(optional, default no) }
## scope = character
alias[trigger:stewardship_diff] == {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
    ## cardinality = 0..1
    abs = bool
}

# -T

### What is the scoped character's Tax Collector aptitude in the target tax slot type? 
## scope = character
alias[trigger:tax_collector_aptitude] = {
    tax_slot_type = <tax_slot>
    value == alias_keys_field[int_value]
    value == value_field
}

### What is the difference in highest title tiers between the scoped character and the target character (-5 to 5) For example, this is true: scope:a_baron = {     tier_difference = {         target = scope:a_king         value = -3     } }  Checks the difference in highest_held_title_tier between two characters. The formatting is: scope:actor = { tier_difference = { target = scope:recipient value = 1 } }
## scope = character
alias[trigger:tier_difference] = {
    target = scope[character]
    value = int[-5..5]
}

### How much time passed after diarch was designated?
## scope = character
alias[trigger:time_after_diarch_designated] = single_alias_right[single_duration_block]

### for how long has the character been imprisoned? time_in_prison = { days/months/years =,>,< X }
## scope = character
alias[trigger:time_in_prison] = single_alias_right[single_duration_block]



### for how long has the character been imprisoned with the current type? time_in_prison_type = { days/months/years =,>,< X }
## scope = character
alias[trigger:time_in_prison_type] = single_alias_right[single_duration_block]

### for how long has the character is dead? time_since_death  = { days/months/years =,>,< X }
## scope = character
alias[trigger:time_since_death] = single_alias_right[single_duration_block]

### The # of days until the scoped character's hook on the target expires. time_to_hook_expiry = { target = someone value > 50 }
## scope = character
alias[trigger:time_to_hook_expiry] = single_alias_right[single_duration_block]

### target = other character value >/</= sum of trait compatibility values
## scope = character
alias[trigger:trait_compatibility] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == value_field
}



# -U

# -V

### Do any of the current active obligations in the scoped character's vassal contract have the given flag
## scope = character
alias[trigger:vassal_contract_has_flag] = value[vassal_contract_flag]

### Date when this vassal's liege's dynasty started ruling over this vassal
## scope = character
alias[trigger:vassal_contract_liege_dynasty_reign_start_date] == date_field


# -W

### can the scoped character be employed as court position by the employer?scope:character = {	would_be_valid_for_court_position = {		employer = scope:employer		court_position = court_physician_court_position	}}
## scope = character
alias[trigger:would_be_valid_for_court_position] = {
    employer = scope[character]
    court_position = <court_position>
}

# -X

# -Y

### does the scope province have a particular building or its successor?
## scope = province
alias[trigger:has_building_or_higher] = <building>

### Checks if sub-region has phase parameter or not
## scope = situation_sub_region
alias[trigger:has_sub_region_phase_parameter] = enum[situation_phase_param]

### Is the scoped participant group of a specific type?
## scope = situation_participant_group
alias[trigger:participant_group_type] = enum[participant_groups]

### Checks if sub-region current phase equals phase_type
## scope = situation_sub_region
alias[trigger:sub_region_current_phase] = enum[situation_phases]

### Is the target character a special guest in the scoped activity, optionally for a specific type.
## scope = activity
alias[trigger:is_special_guest] = {
    target = scope[character]
    ## cardinality = 0..1
    type = replace_me
}

### Is the target character a special guest in the scoped activity, optionally for a specific type.
## scope = activity
alias[trigger:is_special_guest] = scope[character]

### Get random applicable innovation from another culture
## scope = culture
alias[trigger:can_get_innovation_from] = scope[character]

### Does the Army have the given raid intent?
## scope = army
alias[trigger:raid_intent] = <raid_intent>

### Is geographical region part of situation sub-region?
## scope = situation_sub_region
alias[trigger:situation_sub_region_has_geographical_region] = scope[geographical_region]

### Is this the current active tax obligation?
## scope = tax_slot
alias[trigger:is_active_obligation] = <tax_obligation>

### Log whether the parent trigger succeeded or failed
## scope = any
alias[trigger:debug_log] = bool #TODO: Unsure

### Log whether the parent trigger succeeded or failed. Log which children succeeded or failed
## scope = any
alias[trigger:debug_log_details] = bool #TODO: Unsure

### Does the player have a reward item
## scope = any
alias[trigger:has_reward_item] = replace_me #TODO: Unsure

### Does the player have a reward item
## scope = any
alias[trigger:is_bad_nickname] = <nickname>

### is the specified front end character selected (also can be used with "= yes" and "= no")?
### An interface trigger, can only be used in specific places
## scope = any
alias[trigger:is_frontend_character_selected] = replace_me #TODO: Unsure

### is the specified front end character selected (also can be used with "= yes" and "= no")?
### An interface trigger, can only be used in specific places
## scope = any
alias[trigger:is_frontend_character_selected] = bool

### is the specified in-game view open?
### An interface trigger, can only be used in specific places
## scope = any
alias[trigger:is_game_view_open] = replace_me #TODO: Unsure

### Saves the scoped character's opinion of the target character as an arbitrarily-named target to be referenced later in the in the same trigger
### save_temporary_opinion_value_as = { name = <string> target = x
## scope = any
alias[trigger:save_temporary_opinion_value_as] = {
    name = value_set[temporary_scope] # TODO: Standardize the scope/variable `value_set`s
    target = scope[character]
}

### Does the scoped holding type have the given parameter?
## scope = holding_type
alias[trigger:has_holding_parameter] = enum[holding_parameter]

### Checks if top sub-region has phase parameter or not
## scope = situation
alias[trigger:has_situation_top_phase_parameter] = enum[situation_phase_param]

### Checks if situation current phase equals phase_type_key (will take first sub-region)
## scope = situation
alias[trigger:situation_current_phase] = enum[situation_phases]

### Date when the situation was completed.
## scope = situation
alias[trigger:situation_end_date] == date_field

### Checks if any sub-region of the situation has any of their future phases affected by the given catalyst.
## scope = situation
alias[trigger:situation_has_catalyst] = <catalyst>

### Date when the situation started.
## scope = situation
alias[trigger:situation_start_date] == date_field

### Checks if top sub-region of situation has any of the future phases affected by the given catalyst
## scope = situation
alias[trigger:situation_top_has_catalyst] = <catalyst>

### Is the scoped situation of a specific situation type?
## scope = situation
alias[trigger:situation_type] = <situation>

### target = other character value >/</= sum of differences in ai values
## scope = character
alias[trigger:ai_values_divergence] = {
    target = scope[character]
    value == alias_keys_field[int_value]
    value == int_value_field
}

### Does the target character have access to MaA of specified type (excluding through tributaries)
## scope = character
alias[trigger:has_access_to_maa] = <maa_type>

### Does the scoped character have an opinion toward anyone with the target reason?
## scope = character
alias[trigger:has_any_opinion_with_reason] = alias_keys_field[opinion_reason]

### Is the scoped character a player that has automated the target court position to auto-assign the best candidate?
## scope = character
alias[trigger:has_player_court_position_automation_assign_best] = scope[court_position_type]

### Is the scoped character a player that has automated the target court position to auto-assign the best candidate?
## scope = character
alias[trigger:has_player_court_position_automation_assign_best] = <court_position>

### Is the scoped character a player that has automated the target court position to auto-assign the best candidate (or else show an event)?
## scope = character
alias[trigger:has_player_court_position_automation_assign_best_or_event] = scope[court_position_type]

### Is the scoped character a player that has automated the target court position to auto-assign the best candidate (or else show an event)?
## scope = character
alias[trigger:has_player_court_position_automation_assign_best_or_event] = <court_position>

### Is the scoped character a player that has automated the target court position to show events?
## scope = character
alias[trigger:has_player_court_position_automation_event] = scope[court_position_type]

### Is the scoped character a player that has automated the target court position to show events?
## scope = character
alias[trigger:has_player_court_position_automation_event] = <court_position>

### Is the scoped character a player that has NOT automated the target court position?
## scope = character
alias[trigger:has_player_court_position_automation_none] = scope[court_position_type]

### Is the scoped character a player that has NOT automated the target court position?
## scope = character
alias[trigger:has_player_court_position_automation_none] = <court_position>

### Was this mandate selected for the diarch?
## scope = character
alias[trigger:has_selected_mandate] = diarchy_mandate # TODO: Unsure

### Check if the character has a specific contract group
## scope = character
alias[trigger:has_subject_contract_group] = <subject_contract_group>

### Is the skill the highest skill (including Prowess) of the character? True even when there are multiple skills with the same highest value.
## scope = character
alias[trigger:highest_skill_including_prowess] = enum[attribute]

### Do any of the current active obligations in the scoped character's subject contract have the given flag
## scope = character
alias[trigger:subject_contract_has_flag] = value[vassal_contract_flag]

### Checks if the character would get an alliance with the target character through such a marriage.
## scope = character
alias[trigger:yields_alliance] = {
    candidate = scope[character]
    target = scope[character]
    target_candidate = scope[character]
}

### has_domicile_construction - Is the scoped domicile currently constructing the specified building?
### scope:domicile = { has_domicile_construction = domicile building key }
## scope = domicile
alias[trigger:has_domicile_construction] = <domicile_building>

### How many perks from this lifestyle does the character have?
## scope = character
alias[trigger:<lifestyle>_perks] == alias_keys_field[int_value]

### How many perks from this lifestyle does the character have?
## scope = character
alias[trigger:<lifestyle>_perks] == single_alias_right[score_formula]

### How many perks from this lifestyle does the character have?
## scope = character
alias[trigger:<lifestyle>_perks] == value_field

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_perk_points] == alias_keys_field[int_value]

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_perk_points] == single_alias_right[score_formula]

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_perk_points] == value_field

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_unlockable_perks] == alias_keys_field[int_value]

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_unlockable_perks] == single_alias_right[score_formula]

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_unlockable_perks] == value_field

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_xp] == alias_keys_field[int_value]

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_xp] == single_alias_right[score_formula]

### How many perk points available does the character have?
## scope = character
alias[trigger:<lifestyle>_xp] == value_field

### Does the character have this many perk points assigned to this tree? perks_in_tree = { tree = tree_key value > 5 }
## scope = character
alias[trigger:perks_in_tree] == alias_keys_field[int_value]

### Does the character have this many perk points assigned to this tree? perks_in_tree = { tree = tree_key value > 5 }
## scope = character
alias[trigger:perks_in_tree] == single_alias_right[score_formula]

### Does the character have this many perk points assigned to this tree? perks_in_tree = { tree = tree_key value > 5 }
## scope = character
alias[trigger:perks_in_tree] == value_field

### How many perks does this lifestyle have?
## scope = character
alias[trigger:perks_in_<lifestyle>] == alias_keys_field[int_value]

### How many perks does this lifestyle have?
## scope = character
alias[trigger:perks_in_<lifestyle>] == single_alias_right[score_formula]

### How many perks does this lifestyle have?
## scope = character
alias[trigger:perks_in_<lifestyle>] == value_field

### Compares the number of scripted relations a character has of the type
## scope = character
alias[trigger:num_of_relation_<scripted_relation>] == alias_keys_field[int_value]

### Compares the number of scripted relations a character has of the type
## scope = character
alias[trigger:num_of_relation_<scripted_relation>] == single_alias_right[score_formula]

### Compares the number of scripted relations a character has of the type
## scope = character
alias[trigger:num_of_relation_<scripted_relation>] == value_field

### Total number of days since this travel plan started.
## scope = travel_plan
alias[trigger:days_travelled] == alias_keys_field[int_value]

### Total number of days since this travel plan started.
## scope = travel_plan
alias[trigger:days_travelled] == single_alias_right[score_formula]

### Total number of days since this travel plan started.
## scope = travel_plan
alias[trigger:days_travelled] == int_value_field

### AI boldness modified by the dread of the specified character dread_modified_ai_boldness = { 	character = root	# the character whose dread is affecting the target character 	value >= 5 }
## scope = character
alias[trigger:dread_modified_ai_boldness] = {
    character = scope[character]
    value = alias_keys_field[int_value]
    value = single_alias_right[score_formula]
    value = int_value_field
}

###  the obligation level of the scoped character's vassal contract be decreasde?
## scope = character
alias[trigger:vassal_contract_obligation_level_can_be_decreased] = <subject_contract>

###  Can the obligation level of the scoped character's vassal contract be increased?
## scope = character
alias[trigger:vassal_contract_obligation_level_can_be_increased] = <subject_contract>

### checks if the assigned yes/no value is true
### always = yes # always succeeds
### always = no  # always fails
### always = scope:a_boolean_value # evaluated at runtime
alias[trigger:always] = scope[bool] # Scoped boolean

###How much has the scoped character invested in the target title towards the target candidate?
### scope:character = {
### 	succession_appointment_score_invested = {
### 		title = scope:title
### 		candidate = scope:character
### 		value < 0
### 	}
### }
## scope = character
alias[trigger:succession_appointment_score_invested] = {
    title = scope[landed_title]
    candidate = scope[character]
    value == int_value_field
    value == alias_keys_field[int_value]
    value == single_alias_right[score_formula]
}

# -Z

###